[{"uri":"https://saturnframework.org/explanations/directory-structure.html","title":"Directory Structure","content":"\r\n# Directory Structure\r\n\r\nAfter creating a new Saturn project, let's take a deeper look into what files are created.\r\n\r\n```bash\r\n├── .fake\r\n├── .paket\r\n├── .vs\r\n├── .packages\r\n├── paket-files\r\n├── src\r\n|   ├── Migrations\r\n|   └── SaturnSample\r\n├── .gitignore\r\n├── build.fsx\r\n├── global.json\r\n├── paket.dependencies\r\n├── paket.lock\r\n└── SaturnSample.sln\r\n```\r\n\r\nAt this level most of it is basic configuration files to help with running Saturn. From looking at the `.paket`, `paket-files`, `paket.dependencies`, `paket.lock` folders and files, you can see that by default Saturn uses [paket](https://fsprojects.github.io/Paket/) to handle package management. You won't be working with these files directly but rather through the command line tools instead.\r\n\r\nSaturn also uses [FAKE](https://fake.build/) to build the project. You can see how it is set up by looking at the `.fake` folder and `build.fsx` file.\r\n\r\nSaturn also provides a `.gitignore` file that prevents some folders from being tracked by git when they don't need to.\r\n\r\nLastly, there is the `SaturnSample.sln` solution file so you can open the project in an IDE like Visual Sudio and a `global.json` file to configure the solution file.\r\n\r\n### Project structure\r\n\r\nMost of the work you will do in this project however, will be in `src/SaturnSample`, which looks like the following when expanded:\r\n\r\n```bash\r\n  ├── bin\r\n  ├── Books\r\n  |   ├── BooksController.fs\r\n  |   ├── BooksModel.fs\r\n  |   ├── BooksRepository.fs\r\n  |   └── BooksView.fs\r\n  ├── obj\r\n  ├── static\r\n  |   ├── app.css\r\n  |   └── app.js\r\n  ├── Templates\r\n  |   ├── App.fs\r\n  |   ├── Index.fs\r\n  |   ├── InternalError.fs\r\n  |   └── NotFound.fs\r\n  ├── Config.fs\r\n  ├── Database.fs\r\n  ├── database.sqlite\r\n  ├── paket.references\r\n  ├── Program.fs\r\n  ├── Router.fs\r\n  └── SaturnSample.fsproj\r\n```\r\n\r\n`bin` and `obj` folders store the compiled version of the program after you build the project.\r\n\r\nThe convention for Saturn is that the model and everything associated with it are inside one folder. Everything is also named with the plural form of the model so \"Books\" instead of \"Book\".\r\n\r\nYour static files like css, js, and images should be inside the `static` folder.\r\n\r\n`Config.fs` contains a `Config` record that stores settings that you can use inside your application. By default, the record only contains the `connectionString` field.\r\n\r\n`Database.fs` contains functions to execute SQL queries within the program through [Dapper](https://stackexchange.github.io/Dapper/).\r\n\r\nIf you did not run `dotnet saturn migration` as in the [how to start guide](../tutorials/how-to-start.html), you might not see `database.sqlite`, but that is the database file that your Saturn project is using to store data.\r\n\r\n`paket.references` shows the packages that your project is using.\r\n\r\n`Program.fs` handles intializing the program and loading up various settings.\r\n\r\n`Router.fs` is where you will set the route of the site and what page to load.\r\n\r\nLastly, `SaturnSample.fsproj` is the project file itself."},{"uri":"https://saturnframework.org/explanations/endpoint-routing.html","title":"Endpoint Routing","content":"\r\n# Endpoint Routing\r\n\r\nSaturn from version `0.15` supports [ASP.NET Endpoint Routing](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1) additionally to custom routing implementation provided by Giraffe. The main difference between old routing and new one is that Endpoint Routing assumes total separation of routing from behavior - it works by statically defining list of all possible routes on startup of application. This impacts design of some of our Saturn abstractions, and means new routing is not 100% compatible with old one. On the bright side, theoretically, Endpoint Routing should provide noticeable performance boost, and in the future it will allow for better ecosystem integration.\r\n\r\n> Currently endpoint routing API is treated as an experimental API - it's subject to changes.\r\n\r\nTo use Endpoint Routing you need to open `Saturn.Endpoint` namespace - this will override known `router` and `controller` Computation Expressions with their Endpoint Routing versions. In `application` CE instead of using `use_router` operation you should use `use_endpoint_router` operation. For many simple applications this may be enough to get things working - we've been trying to keep API as compatible as possible.\r\n\r\nHowever there are differences:\r\n\r\n* With Endpoint Routing `router` and `controller` computation expressions are not transformed to `HttpHandler` but rather to `Endpoint list`. This has a huge impact on composability of those abstractions - you can't do things like `myHttpHandler >=> router { ... }` any more. Such code should be replaced with `plug/pipe_through` functionality in both `router` and `controller`. `Endpoint list` can basically be used in 2 places - in `forward` operation in `router` and `use_endpoint_router` in `application`.\r\n* Lack of `subroutef` in Giraffe-EndpointRouting - beacuse EndpointRouting needs to have all possible route templates at the application startup it's really hard to emulate some of previous Giraffe's routing composibility capabilities. From Saturn point of view this created 2 major changes:\r\n  - there's no `forwardf` in `router` CE anymore - it should be replaced with set of `getf/postf/putf ... ` operations in child router.\r\n  - `subController` in `controller` CE doesn't work well in Endpoint Routing - you can use as subcontrollers only old, HttpHandler based controllers (even if you parent controller is Endpoint Routing controller). In `Saturn.Endpoint` we provide additonal `subcontroller` CE - it's an alias to old `controller` CE\r\n* Lack of `case_insensitive` in `router` and `controller` - with Endpoint Routing all routes are case insensitive by default and there's no easy way to change it\r\n* Lack of `not_found_handler` in `router` and `controller` - as Endpoint Routing creates global table of routing having scoped not-found handlers is really tricky. Use built-in ways of handle 404 in ASP.NET (such as `UseDeveloperExceptionPage`)\r\n* Unlike Giraffe routing, Endpoint Routing doesn't ensure order of routing checks - this shouldn't be a problem in most cases, but I can imagine some edge cases in which this would matter.\r\n\r\nIn general, to reiterate - Endpoint Routing API in Giraffe/Saturn is still experimental. However, it probably is a future of Giraffe/Saturn so if possible please check if your applications can move to the Endpoint Routing API, and try it out. It's important for everyone involved to get feedback on this new routing engine."},{"uri":"https://saturnframework.org/explanations/overview.html","title":"Saturn Overview","content":"\r\n# Saturn Overview\r\n\r\nSaturn is a web development framework written in F# which implements the server-side MVC pattern. Many of its components and concepts will seem familiar to those of us with experience in other web frameworks like Ruby on Rails or Python’s Django. It's heavily inspired by Elixir's [Phoenix](http://phoenixframework.org/).\r\n\r\nBuilt on top of the battle-tested ASP.NET Core foundation and the highly flexible, extendable model of Giraffe, Saturn provides high level abstractions, helpers and tools to enable high developer productivity, at the same time keeping high application performance provided by Kestrel and Giraffe.\r\n\r\nSaturn is made up of a number of distinct parts, each with its own purpose and role to play in building a web application.\r\n\r\n - Application\r\n    - the start and end of the request life cycle\r\n    - handles all aspects of requests up until the point where the router takes over\r\n    - provides a core set of plugs to apply to all requests\r\n    - dispatches requests into a router\r\n    - enables application and hosting configuration\r\n - [Router](routing.html)\r\n    - parses incoming requests and dispatches them to the correct controller/action, passing parameters as needed\r\n    - provides helpers to generate route paths or urls to resources\r\n    - defines named pipelines through which we may pass our requests\r\n    - allows easy application of groups of plugs to a set of routes\r\n - [Controllers](controller.html)\r\n    - provide functions, called *actions*, to handle requests\r\n    - actions:\r\n        - prepare data and pass it into views\r\n        - invoke rendering via views\r\n        - perform redirects\r\n        - return data as JSON or XML\r\n        - and much more\r\n - [Views](view.html)\r\n    - render templates\r\n    - act as a presentation layer\r\n    - define helper functions, available in templates, to decorate data for presentation\r\n - Channels\r\n    - manage sockets for easy realtime communication\r\n    - are analogous to controllers except that they allow bi-directional communication with persistent connections\r\n - [Scaffolding scripts](scaffolding.html)\r\n    - `dotnet new` template providing good starting point for new applications - [https://github.com/SaturnFramework/Saturn.Template](https://github.com/SaturnFramework/Saturn.Template)\r\n    - `dotnet saturn` CLI tool that controls migrations and let you easily scaffold new parts of application - [https://github.com/SaturnFramework/Saturn.Dotnet](https://github.com/SaturnFramework/Saturn.Dotnet)\r\n\r\n\r\n### Saturn rings\r\n\r\nSaturn itself is the top layer of a multi-layer system designed to create a flexible, productive environment for creating web applications.\r\n\r\n#### Kestrel and ASP.NET Core\r\n\r\nASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-based, Internet-connected applications. Kestrel is a cross-platform web server for ASP.NET Core based on `libuv`, a cross-platform asynchronous I/O library. ASP.NET Core documentation can be found [here](https://docs.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-3.1)\r\n\r\n#### [Giraffe](https://github.com/giraffe-fsharp/Giraffe)\r\n\r\nGiraffe is an F# micro web framework for building rich web applications. It has been heavily inspired and is similar to [Suave](https://suave.io), but has been specifically designed with ASP.NET Core in mind and can be plugged into the ASP.NET Core pipeline via middleware. Giraffe applications are composed of so-called HttpHandler functions which can be thought of as a mixture of Suave's WebParts and ASP.NET Core's middleware. As Saturn shares many basic helper functions with Giraffe it's highly recommended to also check out [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n\r\n### Saturn moons\r\n\r\nSaturn is not only a library building on top of Giraffe, but also a set of opinionated tooling for scaffolding a whole project and then generating some boilerplate code. At the moment our template is using (by default):\r\n\r\n#### [Dapper](https://github.com/StackExchange/Dapper)\r\n\r\nA simple, focused on performance object mapper for .Net that you can add in to your project and will extend your `IDbConnection` interface.\r\n\r\n#### [Simple.Migrations](https://github.com/canton7/Simple.Migrations)\r\n\r\nSimple.Migrations is a simple bare-bones migration framework for .NET Core (.NET Standard 1.2 and .NET 4.5). It doesn't provide SQL generation, nor an out-of-the-box command-line tool, nor any other fancy feature. It does however provide a set of simple, extendable, and composable tools for integrating migrations into your application.\r\n\r\n\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/scaffolding.html","title":"Scaffolding","content":"\r\n# Scaffolding\r\n\r\nSaturn provides a command line scaffolding tool to generate a model, database migration, controller, and associated views.\r\n\r\nTo use the generator, run the `dotnet saturn` command from the root of your application application.  If you have used the template to generate your project, this is the directory with `build.fsx` or `paket.dependencies` file.\r\n\r\nThere are three flavors of generators that provide flexibility about what types of code is generated to support your model.\r\n\r\n| Command      |  Generates                                                                     |\r\n|--------------|--------------------------------------------------------------------------------|\r\n| gen          | Creates a model, database layer, HTML views, and a controller.                 |\r\n| gen.json     | Creates a model, database layer, and an API controller to access the model.    |\r\n| gen.model    | Creates only the model and database layer (no controller or views)             |\r\n\r\nEach of these commands will generate a migration for your model as well as a folder containing generated files.\r\n\r\nFor example:\r\n\r\n`dotnet saturn gen Book Books id:string title:string`\r\n\r\nGenerates the following structure:\r\n\r\n```bash\r\nsrc\r\n├── Migrations\r\n│   └── 201903192143.Book.fs\r\n│\r\n└── SaturnSample\r\n    └── Books\r\n        ├── BooksController.fs\r\n        ├── BooksModel.fs\r\n        ├── BooksRepository.fs\r\n        └── BooksViews.fs\r\n```\r\n\r\nEach of the generators takes arguments in the same format:\r\n\r\n`dotnet saturn gen <SingularModelName> <PluralModelName> <List of model fields with types>`\r\n\r\nThe list of model fields are names and types separated by a colon.\r\n\r\n`<fieldname>:<type>`\r\n\r\nCurrently supported types are:\r\n\r\n* string\r\n* int\r\n* float\r\n* double\r\n* decimal\r\n* guid\r\n* datetime\r\n* bool\r\n\r\n## Migrations\r\n\r\nUsing the generator to create a model will also create a migration file that will create a supporting table in the database. Execute the migration script using:\r\n\r\n`dotnet saturn migration`"},{"uri":"https://saturnframework.org/explanations/view.html","title":"View Engine","content":"\r\n# View Engine\r\n\r\n> This post has been originally part of the [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine)\r\n\r\nSaturn is built on top of Giraffe and can use any helpers it provides. This is a case for suggested view engine that you can use in Saturn - Giraffe has its own functional view engine which can be used to build rich UIs for web applications. The single biggest and best contrast to other view engines (e.g. Razor, Liquid, etc.) is that the Giraffe View Engine is entirely functional written in normal (and compiled) F# code.\r\n\r\nThis means that the Giraffe View Engine is by definition one of the most feature rich view engines available, requires no disk IO to load a view and views are automatically compiled at build time.\r\n\r\nThe Giraffe View Engine uses traditional functions and F# record types to generate rich HTML/XML views.\r\n\r\n### HTML Elements and Attributes\r\n\r\nHTML elements and attributes are defined as F# objects:\r\n\r\n```fsharp\r\nlet indexView =\r\n    html [] [\r\n        head [] [\r\n            title [] [ str \"Giraffe Sample\" ]\r\n        ]\r\n        body [] [\r\n            h1 [] [ str \"I |> F#\" ]\r\n            p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                str \"Hello World\"\r\n            ]\r\n        ]\r\n    ]\r\n```\r\n\r\nA HTML element can either be a `ParentNode`, a `VoidElement` or a `Text` element.\r\n\r\nFor example the `<html>` or `<div>` tags are typical `ParentNode` elements. They can hold an `XmlAttribute list` and a second `XmlElement list` for their child elements:\r\n\r\n```fsharp\r\nlet someHtml = div [] []\r\n```\r\n\r\nAll `ParentNode` elements accept these two parameters:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [ _id \"someId\"; _class \"css-class\" ] [\r\n        a [ _href \"https://example.org\" ] [ str \"Some text...\" ]\r\n    ]\r\n```\r\n\r\nMost HTML tags are `ParentNode` elements, however there is a few HTML tags which cannot hold any child elements, such as `<br>`, `<hr>` or `<meta>` tags. These are represented as `VoidElement` objects and only accept the `XmlAttribute list` as single parameter:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        br []\r\n        hr [ _class \"css-class-for-hr\" ]\r\n        p [] [ str \"bla blah\" ]\r\n    ]\r\n```\r\n\r\nAttributes are further classified into two different cases. First and most commonly there are `KeyValue` attributes:\r\n\r\n```fsharp\r\na [\r\n    _href \"http://url.com\"\r\n    _target \"_blank\"\r\n    _class \"class1\" ] [ str \"Click here\" ]\r\n```\r\n\r\nAs the name suggests, they have a key, such as `class` and a value such as the name of a CSS class.\r\n\r\nThe second category of attributes are `Boolean` flags. There are not many but some HTML attributes which do not require any value (e.g. `async` or `defer` in script tags). The presence of such an attribute means that the feature is turned on, otherwise it is turned off:\r\n\r\n```fsharp\r\nscript [ _src \"some.js\"; _async ] []\r\n```\r\n\r\nThere's also a wealth of [accessibility attributes](https://www.w3.org/TR/html-aria/) available under the `Giraffe.GiraffeViewEngine.Accessibility` module (needs to be explicitly opened).\r\n\r\n### Text Content\r\n\r\nNaturally the most frequent content in any HTML document is pure text:\r\n\r\n```html\r\n<div>\r\n    <h1>This is text content</h1>\r\n    <p>This is even more text content!</p>\r\n</div>\r\n```\r\n\r\nThe Giraffe View Engine lets one create pure text content as a `Text` element. A `Text` element can either be generated via the `rawText` or `encodedText` (or the short alias `str`) functions:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        p [] [ rawText \"<div>Hello World</div>\" ]\r\n        p [] [ encodedText \"<div>Hello World</div>\" ]\r\n    ]\r\n```\r\n\r\nThe `rawText` function will create an object of type `XmlNode` where the content will be rendered in its original form and the `encodedText`/`str` function will output a string where the content has been HTML encoded.\r\n\r\nIn this example the first `p` element will literally output the string as it is (`<div>Hello World</div>`) while the second `p` element will output the value as HTML encoded string `&lt;div&gt;Hello World&lt;/div&gt;`.\r\n\r\nPlease be aware that the the usage of `rawText` is mainly designed for edge cases where someone would purposefully want to inject HTML (or JavaScript) code into a rendered view. If not used carefully this could potentially lead to serious security vulnerabilities and therefore should be used only when explicitly required.\r\n\r\nMost cases and particularly any user provided content should always be output via the `encodedText`/`str` function.\r\n\r\n### Javascript event handlers\r\n\r\nIt is possible to add JavaScript event handlers to HTML elements using the Giraffe View Engine.  These event handlers (all prefixed with names starting with `_on`, for example `_onclick`, `_onmouseover`) can either execute inline JavaScript code or can invoke functions that are part of the `window` scope.\r\n\r\nThis example illustrates how inline JavaScript could be used to log to the console when a button is clicked:\r\n\r\n```fsharp\r\nlet inlineJSButton =\r\n    button [_id \"inline-js\"\r\n            _onclick \"console.log(\\\"Hello from the 'inline-js' button!\\\");\"] [str \"Say Hello\" ]\r\n```\r\n\r\nThere are some caveats with this approach, namely that\r\n* it is not very scalable to write JavaScript inline in this manner, and more pressing\r\n* the Giraffe View Engine HTML-encodes the text provided to the `_onX` attributes.\r\n\r\nTo get around this, you can write dedicated scripts in your HTML and reference the functions from your event handlers:\r\n\r\n```fsharp\r\nlet page =\r\n    div [] [\r\n        script [_type \"application/javascript\"] [\r\n            rawText \"\"\"\r\n            window.greet = function () {\r\n                console.log(\"ping from the greet method\");\r\n            }\r\n            \"\"\"\r\n        ]\r\n        button [_id \"script-tag-js\"\r\n                _onclick \"greet();\"] [str \"Say Hello\"]\r\n    ]\r\n```\r\n\r\nHere it's important to note that we've included the text of our script using the `rawText` tag.  This ensures that our text is not encoded by Giraffe so that it remains as we have written it.\r\n\r\nHowever, writing large quantities of JavaScript in this manner can be difficult, because you don't have access to the large ecosystem of javascript editor tooling.  In this case you should write your functions in another script and use a `script` tag element to reference your script, then add the desired function to your HTML element's event handler.\r\n\r\nSay you had a JavaScript file named `greet.js` and had configured Giraffe to serve that script from the WebRoot. Let us also say that the content of that script was:\r\n\r\n```javascript\r\nfunction greet() {\r\n    console.log(\"Hello from the greet function of greet.js!\");\r\n}\r\n```\r\n\r\nThen, you could reference that javascript via a script element, and use `greet` in your event handler like so:\r\n\r\n```fsharp\r\nlet page =\r\n    html [] [\r\n        head [] [\r\n            script [_type \"application/javascript\"\r\n                    _src \"/greet.js\"] [] // include our `greet.js` function dynamically\r\n        ]\r\n        body [] [\r\n            button [_id \"greet-btn\"\r\n                    _onclick \"greet()\"] [] // use the `greet()` function from `greet.js` to say hello\r\n        ]\r\n    ]\r\n```\r\n\r\nIn this way, you can write `greet.js` with all of your expected tooling, and still hook up the event handlers all in one place in Giraffe.\r\n\r\n### Naming Convention\r\n\r\nThe Giraffe View Engine has a naming convention which lets you easily determine the correct function name without having to know anything about the view engine's implementation.\r\n\r\nAll HTML tags are defined as `XmlNode` elements under the exact same name as they are named in HTML. For example the `<html>` tag would be `html [] []`, an `<a>` tag would be `a [] []` and a `<span>` or `<canvas>` would be the `span [] []` or `canvas [] []` function.\r\n\r\nHTML attributes follow the same naming convention except that attributes have an underscore prepended. For example the `class` attribute would be `_class` and the `src` attribute would be `_src` in Giraffe.\r\n\r\nThe underscore does not only help to distinguish an attribute from an element, but also avoid a naming conflict between tags and attributes of the same name (e.g. `<form>` vs. `<input form=\"form1\">`).\r\n\r\nIf a HTML attribute has a hyphen in the name (e.g. `accept-charset`) then the equivalent Giraffe attribute would be written in camel case notion (e.g. `acceptCharset`).\r\n\r\n*Should you find a HTML tag or attribute missing in the Giraffe View Engine then you can either [create it yourself](#custom-elements-and-attributes) or send a [pull request on GitHub](https://github.com/giraffe-fsharp/Giraffe/pulls).*\r\n\r\n### View Engine Best Practices\r\n\r\nDue to the huge amount of available HTML tags and their fairly generic (and short) names (e.g. `<form>`, `<option>`, `<select>`, etc.) there is a significant danger of accidentally overriding a function of the same name in an application's codebase. For that reason the Giraffe View Engine becomes only available after opening the `GiraffeViewEngine` module.\r\n\r\nAs a measure of good practice it is recommended to create all views in a separate module:\r\n\r\n```fsharp\r\nmodule MyWebApplication\r\n\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let index =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str \"Giraffe Sample\" ]\r\n            ]\r\n            body [] [\r\n                h1 [] [ str \"I |> F#\" ]\r\n                p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                    str \"Hello World\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let other = //...\r\n```\r\n\r\nThis ensures that the opening of the `GiraffeViewEngine` is only contained in a small context of an application's codebase and therefore less of a threat to accidental overrides. In the above example views can always be accessed through the `Views` sub module (e.g. `Views.index`).\r\n\r\n### Custom Elements and Attributes\r\n\r\nAdding new elements or attributes is normally as simple as a single line of code:\r\n\r\n```fsharp\r\nopen Giraffe.GiraffeViewEngine\r\n\r\n// If there was a new <foo></foo> HTML element:\r\nlet foo = tag \"foo\"\r\n\r\n// If <foo> is an element which cannot hold any content then create it as voidTag:\r\nlet foo = voidTag \"foo\"\r\n\r\n// If <foo> has a new attribute called bar then create a new bar attribute:\r\nlet _bar = attr \"bar\"\r\n\r\n// if the bar attribute is a boolean flag:\r\nlet _bar = flag \"bar\"\r\n```\r\n\r\nAlternatively you can also create new elements and attributes from inside another element:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n```\r\n\r\n### Rendering Views\r\n\r\nRendering views in Giraffe is done through one of the following functions:\r\n\r\n- `renderHtmlDocument`\r\n- `renderHtmlNodes`\r\n- `renderHtmlNode`\r\n- `renderXmlNodes`\r\n- `renderXmlNode`\r\n\r\nThe Giraffe View Engine cannot only be used to render HTML views, but also for any other XML based content such as `<svg>` images or other arbitrary XML based data.\r\n\r\nThe `renderHtmlDocument` function takes a single `XmlNode` as input parameter and renders a HTML page with a `DOCTYPE` declaration. This function should be used for rendering a complete HTML document. The `WriteHtmlViewAsync` extension method and the `htmlView` http handler both use the `renderHtmlDocument` function under the covers.\r\n\r\nThe `renderHtmlNodes` function takes an `XmlNode list` as input parameter and will output a single HTML string containing all the rendered HTML code. The `renderHtmlNode` function renders a single `XmlNode` element into a valid HTML string. Both, the `renderHtmlNodes` and `renderHtmlNode` function are useful for use cases where a HTML snippet needs to be created without a `DOCTYPE` declaration (e.g. templated emails, etc.).\r\n\r\nThe `renderXmlNodes` and `renderXmlNode` function are identical to `renderHtmlNodes` and `renderHtmlNode`, except that they will render void elements differently:\r\n\r\n```fsharp\r\nlet someTag = voidTag \"foo\"\r\nlet someContent = someTag []\r\n\r\n// Void tag will be rendered to valid HTML: <foo>\r\nlet output1 = renderHtmlNode someContent\r\n\r\n// Void tag will be rendered to valid XML: <foo />\r\nlet output2 = renderXmlNode someContent\r\n```\r\n\r\nAll `GiraffeViewEngine` http handlers are using a thread static `StringBuilderPool` to avoid the creation of large `StringBuilder` objects for each render call and dynamically grow/shrink that pool based on the application's needs. However if the application is running into any memory issues then this performance feature can be disabled by setting `StringBuilderPool.IsEnabled <- false`.\r\n\r\nAdditionally with Giraffe 3.0.0 or higher there is a new module called `ViewBuilder` under the `Giraffe.GiraffeViewEngine` namespace. This module exposes additional view rendering functions which compile a view into a `StringBuilder` object instead of returning a single `string`:\r\n\r\n- `ViewBuilder.buildHtmlDocument`\r\n- `ViewBuilder.buildHtmlNodes`\r\n- `ViewBuilder.buildHtmlNode`\r\n- `ViewBuilder.buildXmlNodes`\r\n- `ViewBuilder.buildXmlNode`\r\n\r\nThe `ViewBuilder.build[...]` functions can be useful if there is additional string processing required before/after composing a view by the `GiraffeViewEngine` (e.g. embedding HTML snippets in an email template, etc.). These functions also serve as the lower level building blocks of the equivalent `render[...]` functions.\r\n\r\nExample usage:\r\n\r\n```fsharp\r\nopen System.Text\r\nopen Giraffe.GiraffeViewEngine\r\n\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n\r\nlet sb = new StringBuilder()\r\n\r\n// Perform actions on the `sb` object...\r\nsb.AppendLine \"This is a HTML snippet inside a markdown string:\"\r\n  .AppendLine \"\"\r\n  .AppendLine \"```html\" |> ignore\r\n\r\nlet sb' = ViewBuilder.buildHtmlNode sb someHtml\r\n\r\n// Perform more actions on the `sb` object...\r\nsb'.AppendLine \"```\" |> ignore\r\n\r\nlet markdownOutput = sb'.ToString()\r\n```\r\n\r\n### Common View Engine Features\r\n\r\nThe Giraffe View Engine doesn't have any specially built functions for commonly known features such as master pages or partial views, mainly because the nature of the view engine itself doesn't require it in most cases.\r\n\r\n#### Master Pages\r\n\r\nCreating a master page is a simple matter of piping two functions together:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n... or even have multiple nested master pages:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master1 (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let master2 (content: XmlNode list) =\r\n        [\r\n            main [] content\r\n            footer [] [\r\n                p [] [\r\n                    str \"Copyright ...\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master2 |> master1 pageTitle\r\n```\r\n\r\n#### Partial Views\r\n\r\nA partial view is nothing more than one function or object being called from within another function:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n#### Working with Models\r\n\r\nA view which accepts a model is basically a function with an additional parameter:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index (model : IndexViewModel) =\r\n        [\r\n            h1 [] [ str model.PageTitle ]\r\n            p [] [ str model.WelcomeText ]\r\n        ] |> master model.PageTitle\r\n```\r\n\r\n#### If Statements, Loops, etc.\r\n\r\nThings like if statements, loops and other normal F# language constructs work just as expected:\r\n\r\n```fsharp\r\nlet partial (books : Book list) =\r\n    ul [] [\r\n        yield!\r\n            books\r\n            |> List.map (fun b -> li [] [ str book.Title ])\r\n    ]\r\n```\r\n\r\nOverall the Giraffe View Engine is extremely flexible and feature rich by nature based on the fact that it is generated via normal compiled F# code."},{"uri":"https://saturnframework.org/tutorials/adding-pages.html","title":"Adding Pages","content":"\r\n# Adding Pages\r\n\r\nThis guide uses the same project from the [how to start guide](how-to-start.html). Let's add two pages to it - one hello page and a page that can get your name from the URL.\r\n\r\n## Creating the View\r\n\r\nTo begin, create a `Hello` folder inside the `src/SaturnSample` folder.\r\n\r\nInside the folder, create a new file called \"HelloViews.fs\". This file will contain the functions to create the page.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Giraffe.GiraffeViewEngine\r\nopen Saturn\r\n\r\nmodule Views =\r\n  let index =\r\n    div [] [\r\n        h2 [] [rawText \"Hello from Saturn!\"]\r\n    ]\r\n```\r\n\r\nOne of the dependencies required is [Giraffe View Engine](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine). This will allow your project to define HTML within your function. The `index` function will result in the following HTML code:\r\n\r\n```html\r\n<div>\r\n    <h2>Hello from Saturn!</h2>\r\n</div>\r\n```\r\n\r\n## Creating the Controller\r\n\r\nCreate a `HelloController.fs` file inside the `Hello` folder.\r\n\r\nThe `index` function tells us what the HTML will be but we still need to tell Saturn to return it as an HTML page. We also need to tell Saturn where the page is.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Saturn\r\nopen Giraffe.ResponseWriters\r\n\r\nmodule Controller =\r\n    let indexAction =\r\n        htmlView (Views.index)\r\n\r\n    let helloView = router {\r\n        get \"/\" indexAction\r\n    }\r\n```\r\n\r\nThe `indexAction` tells Saturn to create an HTML page using the `index` function inside \"HelloViews.fs\"\r\n\r\n`helloView` lets Saturn know that the page is located at the root.\r\n\r\n## Adding the 2 new files to the project\r\n\r\nFor the project to see the new files, modify SaturnSample.fsproj as below:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <Compile Include=\"Database.fs\" />\r\n    <Compile Include=\"Config.fs\" />\r\n\r\n    <Compile Include=\"Hello\\HelloViews.fs\" />\r\n    <Compile Include=\"Hello\\HelloController.fs\" />\r\n    ...\r\n```\r\n\r\n## Adding it to Router.fs\r\n\r\n\r\nAfter setting up the route, you need to update the project with the new route.\r\n\r\nIn \"Router.fs\", add the following to the inside of the `browserRouter` function:\r\n\r\n\r\n```fsharp\r\nforward \"/hello\" Hello.Controller.helloView\r\n```\r\n\r\nThis means that when we navigate to [http://localhost:8085/hello](http://localhost:8085/hello), the `helloView` function will determine what page to load there. Looking inside the `helloView` function, we said that `indexAction` is called at the root. In conclusion, the page will be located at [http://localhost:8085/hello/](http://localhost:8085/hello/). (Note the \"/\" at the end)\r\n\r\nNow run the program and go to [http://localhost:8085/hello/](http://localhost:8085/hello/) and you will see a page saying \"Hello from Saturn!\"\r\n\r\n## Sending a parameter to your page\r\n\r\nWhat if you want the page to display your name?\r\n\r\nOne way to retrieve your name is to get it from the route. So when you go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) with {yourname} being your actual name, it will grab your name which can then be used to display on the page.\r\n\r\nTo begin, add a new view in your `HelloViews.fs`:\r\n\r\n```fsharp\r\n  let index2 (name : string) =\r\n    div [] [\r\n        h2 [] [rawText (\"Hello \" + name + \"!\")]\r\n    ]\r\n```\r\n\r\nThis function requires passing in the name to be displayed. The name will be retrieved from the route.\r\n\r\nAdd the following to the `HelloController.fs` file below the `helloView` handler:\r\n\r\n```fsharp\r\nlet index2Action name=\r\n    htmlView (Hello.Views.index2 name)\r\n```\r\n\r\nNow to set up the route. Add the following to the `HelloView` handler:\r\n\r\n```fsharp\r\ngetf \"/%s\" index2Action\r\n```\r\n\r\n\"%s\" is a format string. This lets Saturn know to save whatever you type in that spot. Since we want to save a name, we want to save it as a string so we use `%s`.\r\n\r\nThere are other format strings for different types:\r\n\r\n| Format String | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nNow run the program and go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) and replace `{yourname}` with your name to see a page that will greet you.\r\n"},{"uri":"https://saturnframework.org/tutorials/adding-saturn-to-an-existing-giraffe-app.html","title":"Adding Saturn to an existing Giraffe application","content":"\r\n# Adding Saturn to an existing Giraffe application\r\n\r\nThe previous chapter showed how to get started with a new application.\r\n\r\nIf you already have a working Giraffe webserver, you can gradually opt-in to Saturn.\r\n\r\nFor example, if your existing app looks like this:\r\n\r\n```fsharp\r\n\r\ntype Customer = {\r\n    Name : string\r\n    Address : string\r\n}\r\n\r\nlet customers =\r\n    choose [\r\n      GET >=> (json { Name = \"Mr. Smith\"; Address = \"Santa Monika\"})\r\n      PUT >=> (bindJson<Customer> (fun customer -> printfn \"Adding customer %A\" customer; setStatusCode 200))\r\n    ]\r\n\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"               >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n    ]\r\n```\r\n\r\nand you need to add \"vendor\" functionality, you could implement it as a Saturn ``router`` while keeping everything else intact:\r\n\r\n\r\n```fsharp\r\n// the new Saturn router\r\nlet vendors = router {\r\n    getf \"/%i\" (fun vendorId -> (json (readVendorFromDb vendorId)))\r\n    post \"/\" (bindJson<Vendor> (fun customer -> addVendor vendor; setStatusCode 200))\r\n}\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"                >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n        // plug the new Saturn router into the Giraffe app\r\n        route \"/api/vendors\"     >=> vendors\r\n    ]\r\n```\r\n\r\n## Embedding Giraffe Handlers into Saturn\r\n\r\nOf course the other way around also works.\r\n\r\nFor example, [Elmish.Bridge](https://github.com/Nhowka/Elmish.Bridge) does not provide a specialized implementation for Saturn. And it doesn't need to, because we can just use the Giraffe implementation!\r\n\r\n```fsharp\r\n\r\nopen Elmish\r\nopen Elmish.Bridge\r\n\r\nlet elmishBridgeHandler : HttpHandler =\r\n  Bridge.mkServer Shared.endpoint init update\r\n  |> Bridge.run Giraffe.server\r\n\r\n// our existing Saturn router\r\nlet router = router {\r\n\r\n    // ...\r\n\r\n    forward \"\" elmishBridgeHandler\r\n}\r\n```\r\n"},{"uri":"https://saturnframework.org/tutorials/how-to-start.html","title":"Getting started","content":"\r\n# How to start in 60 seconds\r\n\r\nRequirements:\r\n\r\n* `dotnet` SDK 3.1 [https://dotnet.microsoft.com/download/dotnet-core/3.1](https://dotnet.microsoft.com/download/dotnet-core/3.1)\r\n\r\n## Template\r\n\r\nThe easiest way to get started is to use the provided template:\r\n\r\n1. Install the `dotnet` template with `dotnet new -i Saturn.Template`\r\n2. Create a new folder and move into it - `mkdir SaturnSample && cd SaturnSample`\r\n3. Create a new Saturn application - `dotnet new saturn -lang F#`\r\n4. Install all necessary dev tools - `dotnet tool restore`\r\n6. Create a new controller with `dotnet saturn gen Book Books id:string title:string author:string`\r\n7. Run migrations that will create the database and Books table (as for now, the generator is using only SQLite DB) - `dotnet saturn migration`\r\n8. Open the folder in your favourite editor (VSCode) and insert the line (`forward \"/books\" Books.Controller.resource`) into `browserRouter` in `Router.fs` file\r\n9. Start the application by running `dotnet fake build -t run` from the root of the solution. This will start the application in watch mode (automatic recompilation on changes) and open your browser on [http://localhost:8085](http://localhost:8085) which should display the index page.\r\n10. Go to [http://localhost:8085/books](http://localhost:8085/books) to see the generated view. All buttons should be working; you can add new entries, and remove or edit old ones.\r\n\r\n\r\n## Hello World\r\n\r\nIf you want to start from scratch with a minimal Saturn webserver:\r\n\r\n1. Create a new F# Project (for example with `dotnet new console -lang F#`)\r\n2. Add the `Saturn` NuGet Package\r\n\r\n```fsharp\r\nopen Saturn\r\nopen Giraffe\r\n\r\nlet app = application {\r\n    use_router (text \"Hello World from Saturn\")\r\n}\r\n\r\nrun app\r\n```\r\n\r\nIf you compile and run this application, it will unconditionally return the text regardless of the path.\r\n\r\nFrom here on out you can add [routers](../explanations/routing.html), [controllers](../explanations/controller.html) and [views](../explanations/view.html).\r\n\r\n## Deep Dive\r\n\r\nTo get a better understanding of Saturn and the whole SAFE Stack you can look at the [SAFE-Dojo](https://github.com/CompositionalIT/SAFE-Dojo).\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/controller.html","title":"Controllers","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Controller\r\n\r\nIn Saturn, a **controller** is a list of routes that is focused on a **model** (an object that contains your data). So if you have a user model, some common operations are to display the list of users, show details of a user, add a user, update or user, or remove a user. A controller is a great way to organize all of these actions.\r\n\r\nEach of the operations is a separate route and a controller is an easy way to group these routes together.\r\n\r\nA basic user controller is shown below:\r\n\r\n*)\r\nopen Saturn\r\n\r\nlet userController = controller {\r\n    index (fun ctx -> \"Index handler version 1\" |> Controller.text ctx) //View list of users\r\n    add (fun ctx -> \"Add handler version 1\" |> Controller.text ctx) //Add a user\r\n    create (fun ctx -> \"Create handler version 1\" |> Controller.text ctx) //Create a user\r\n    show (fun ctx id -> (sprintf \"Show handler version 1 - %i\" id) |> Controller.text ctx) //Show details of a user\r\n    edit (fun ctx id -> (sprintf \"Edit handler version 1 - %i\" id) |> Controller.text ctx)  //Edit a user\r\n    update (fun ctx id -> (sprintf \"Update handler version 1 - %i\" id) |> Controller.text ctx)  //Update a user\r\n}\r\n\r\n(**\r\nHere we can see the `index`, `add`, `create`, `show`, `edit`, and `update` operations but there are more operations that are not shown here like `patch` and `delete`. You can see all the operations int the [API Reference](../reference/Saturn/saturn-controller-controllerbuilder-10.html). You do not have to handle all of the operations.\r\n\r\nYou might be wondering what the difference is between `add` and `create` or `edit` and `update`. The `add` operation tells the application to return the form so that the user can enter the data for the user to be added. The `create` operation will commit the data to the database of the application. It is the same with `edit` for displaying the form and `update` for committing the change.\r\n\r\nTo add the controller for the routes, you can add it to the `defaultView` router like so:\r\n\r\n*)\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n    forward \"/users\" userController\r\n}\r\n\r\n(**\r\nThe route will now be:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            ├── \"/default.html\"     -redirect to yoursite.com/\r\n            └── \"/users\"\r\n                ├── index \"/\"           -yoursite.com/users/\r\n                ├── add \"/add\"          -yoursite.com/users/add\r\n                ├── create              -POST yoursite.com/users/add\r\n                ├── show \"/%i\"          -yoursite.com/users/%i\r\n                ├── edit \"/%i/edit\"     -yoursite.com/users/%i/edit\r\n                └── update \"\"           -POST yoursite.com/users/%i/edit\r\n```\r\n\r\nThe create and update operations make changes to the database so you have to make a POST request containing the information you want to save to the database.\r\n\r\n## Subcontroller\r\n\r\nNow that you know how to chain routers together to create routes, we can look at a common scenario for a website. A website usually has users and each user can create multiple comments.\r\n\r\n```bash\r\nyoursite.com\r\n└── \"/users\"\r\n    └── \"/%i\"           -yoursite.com/users/%i\r\n        └── \"/comments\" (commentController)\r\n            ├── index \"/\"           -yoursite.com/users/{userId}/comments/\r\n            └── show \"/%i\"          -yoursite.com/users/{userId}/comments/{commentId}\r\n```\r\n\r\nIn Saturn, you can make the comment controller a subcontroller of the user controller. It looks like the following code:\r\n\r\n*)\r\n\r\nlet commentController userId = controller {\r\n    index (fun ctx -> (sprintf \"Comment Index handler for user %i\" userId ) |> Controller.text ctx)\r\n    add (fun ctx -> (sprintf \"Comment Add handler for user %i\" userId ) |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show comment %s handler for user %i\" id userId ) |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit comment %s handler for user %i\" id userId )  |> Controller.text ctx)\r\n}\r\n\r\nlet userController = controller {\r\n    subController \"/comments\" commentController\r\n\r\n    plug [All] (setHttpHeader \"user-controller-common\" \"123\")\r\n    plug [Index; Show] (setHttpHeader \"user-controller-specialized\" \"123\")\r\n\r\n    index (fun ctx -> \"Index handler no version\" |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show handler no version - %i\" id) |> Controller.text ctx)\r\n    add (fun ctx -> \"Add handler no version\" |> Controller.text ctx)\r\n    create (fun ctx -> \"Create handler no version\" |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit handler no version - %i\" id) |> Controller.text ctx)\r\n    update (fun ctx id -> (sprintf \"Update handler no version - %i\" id) |> Controller.text ctx)\r\n    delete (fun ctx id -> failwith (sprintf \"Delete handler no version failed - %i\" id) |> Controller.text ctx)\r\n    error_handler (fun ctx ex -> sprintf \"Error handler no version - %s\" ex.Message |> Controller.text ctx)\r\n}\r\n\r\n(**\r\n\r\nTo create a subcontroller, start with creating a controller for your model. After that, define it as a subcontroller inside the main controller with the following code:\r\n\r\n```fsharp\r\n    subController \"/yourModel\" yourModelController\r\n```\r\n\r\n\r\n## API Reference\r\n\r\nFull API reference for `controller` CE can be found [here](../reference/Saturn/saturn-controller-controllerbuilder-10.html)\r\n\r\nFull API reference for `Controller` module containing useful helpers can be found [here](../reference/Saturn/saturn-controllerhelpers-controller.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/pipeline.html","title":"Pipeline","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Pipelines\r\n\r\nPipeline is a computation expression used to combine `HttpHandlers` in a declarative manner.\r\n\r\nThe result of the computation expression is a standard Giraffe `HttpHandler` which means that it's easily composable with other parts of the Giraffe ecosystem.\r\n\r\n**Example:**\r\n\r\n*)\r\n\r\nopen Saturn\r\n\r\nlet headerPipe = pipeline {\r\n    set_header \"myCustomHeader\" \"abcd\"\r\n    set_header \"myCustomHeader2\" \"zxcv\"\r\n}\r\n\r\nlet endpointPipe = pipeline {\r\n    plug fetchSession\r\n    plug head\r\n    plug requestId\r\n}\r\n\r\n\r\n(**\r\n## API Reference\r\n\r\nFull API reference for `pipeline` CE can be found [here](../reference/Saturn/saturn-pipeline-pipelinebuilder.html)\r\n\r\nFull API reference for `PipelineHelpers` module containing useful helpers can be found [here](../reference/Saturn/saturn-pipelinehelpers.html)\r\n\r\nYou can also use in pipelines (using `plug`) any `HttpHandler` defined in Giraffe - documentation can be found [here](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/routing.html","title":"Router","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\nmodule Index =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nmodule NotFound =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nlet someScopeOrController = Giraffe.ResponseWriters.text \"\"\r\n\r\n(**\r\n# Routing\r\n\r\nRoutes are how Saturn connects all the HTTP requests to the different actions. Think of a route as the URL of the application. The site is yoursite.com but you may have a route for your about page such as yoursite.com/about.\r\n\r\nIn Saturn, `Routers` contain all the routes of your application. A router is a list of routes. A website can have a router that handles the different routes to your page like so:\r\n\r\n```bash\r\nyoursite.com\r\n├── \"/\"             -yoursite.com/\r\n├── \"/about\"        -yoursite.com/about\r\n├── \"/contact\"      -yoursite.com/contact\r\n├── \"/news\"         -yoursite.com/news\r\n└── \"/investors\"    -yoursite.com/investors\r\n```\r\n\r\nSince this is at the root, this is your router at `\"\"` path. You can then add a router inside another router to have the following:\r\n\r\n```bash\r\nyoursite.com\r\n├── books           -yoursite.com/books\r\n|   ├── list        -yoursite.com/books/list\r\n|   ├── add         -yoursite.com/books/add\r\n|   ├── update      -yoursite.com/books/update\r\n|   └── delete      -yoursite.com/books/update\r\n├── about           -yoursite.com/about\r\n├── contact         -yoursite.com/contact\r\n├── news            -yoursite.com/news\r\n└── investors       -yoursite.com/investors\r\n```\r\n\r\nNow you have a router for the `\"/books\"` path inside another router for the `\"\"` path.\r\n\r\nNow to see it in code, create a Saturn project from the template and you will have a `Router.fs` file like this:\r\n\r\n*)\r\n\r\n\r\nopen Saturn\r\nopen Giraffe.Core\r\nopen Giraffe.ResponseWriters\r\n\r\n\r\nlet browser = pipeline {\r\n    plug acceptHtml\r\n    plug putSecureBrowserHeaders\r\n    plug fetchSession\r\n    set_header \"x-pipeline-type\" \"Browser\"\r\n}\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\nlet browserRouter = router {\r\n    not_found_handler (htmlView NotFound.layout) //Use the default 404 webpage\r\n    pipe_through browser //Use the default browser pipeline\r\n\r\n    forward \"\" defaultView //Use the default view\r\n}\r\n\r\n//Other scopes may use different pipelines and error handlers\r\n\r\n// let api = pipeline {\r\n//     plug acceptJson\r\n//     set_header \"x-pipeline-type\" \"Api\"\r\n// }\r\n\r\n// let apiRouter = router {\r\n//     not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n//     pipe_through api\r\n//\r\n//     forward \"/someApi\" someScopeOrController\r\n// }\r\n\r\nlet appRouter = router {\r\n    // forward \"/api\" apiRouter\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nFirst, take a look at the `router` function.\r\n\r\n*)\r\n\r\nlet appRouter' = router {\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nThe `appRouter` value is a `router`. Inside is the `forward \"\" browserRouter` line. The `forward` function needs a path and a router. In this case, the path is an empty string and the router is `browserRouter`. That means that the `browserRouter` router will handle the routes at the current location. Since `appRouter` is the first router called, the current location is the root of the application.\r\n\r\nNow let's look at `browserRouter`:\r\n\r\n*)\r\n\r\nlet browserRouter' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    forward \"\" defaultView\r\n}\r\n\r\n(**\r\n\r\nThere are three lines. The first line, `not_found_handler (htmlView NotFound.layout)` tells `browserRouter` to display a not found page if the user enters a route that the application does not handle. The second line tells the application to use the `browser` pipeline defined above. The pipeline is a list of settings on how the website will deliver the pages. Lastly, `forward \"\" defaultView` is like `forward \"\" browserRouter` from the `appRouter`. Again, `browserRouter` does not contain any routes but it tells the `defaultView` router to handle them. Finally, we get to the part where the application is told how to handle the routes. Inside `defaultView`, we created 3 routes:\r\n\r\n*)\r\n\r\nlet defaultView' = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nHere, we see that `get` is used to define the routes. There are 3 routes here but 2 of them redirect to the first route. To illustrate, the routes are:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            └── \"/default.html\"     -redirect to yoursite.com/\r\n```\r\n\r\nLooking at the first line inside `defaultView`, `get \"/\" (htmlView Index.layout)` tells the application to display `Index.layout` at the root of the application. The `get` corresponds to the HTTP verb GET so when you type in a link, the browser tries to GET the page. The first parameter of `get` is \"/\", so basically when getting the root, the `get` function will return something. The second parameter is `(htmlView Index.layout)` so the `get` function returns an HTML page specified by Index.layout. The second and third line have `(redirectTo false \"/\")`, telling the application to go to \"yoursite.com/\" when going to \"yoursite.com/index\" or \"yoursite.com/default\"\r\n\r\n## Best Practices\r\n\r\nYou can combine all 3 routers into one router like so:\r\n\r\n*)\r\n\r\n\r\nlet appRouter'' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nThe template splits them into 3 to encourage good practices. In the first router, you can see the commented out code `forward \"/api\" apiRouter`. This is a good suggestion in the template to have a separate router to handle your API routes. We set up how to deliever the webpage with `pipe_through browser` in `browserRouter`. The settings are important for a browser to know how to handle your routes but not for a different application to access your routes as an API.\r\n\r\nThe template provides an example of how to set up the API routes in the commented out code, which I copied below:\r\n\r\n*)\r\n\r\nlet api = pipeline {\r\n    plug acceptJson\r\n    set_header \"x-pipeline-type\" \"Api\"\r\n}\r\n\r\nlet apiRouter = router {\r\n    not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n    pipe_through api\r\n\r\n    forward \"/someApi\" someScopeOrController\r\n}\r\n\r\n(**\r\n\r\nHere we have the `apiRouter` router which does not return a 404 page but a 404 text instead which is appropriate for an API. The router also uses a pipeline that is more appropriate for an API such as accepting JSON inputs instead of HTML as in the `browser` pipeline.\r\n\r\n## Format Strings\r\n\r\nYou might be wondering how to make routes that accept a numerical ID. You can make multiple routes for each ID like so\r\n\r\n```fsharp\r\nget \"/1\" (getApplication 1)\r\nget \"/2\" (getApplication 2)\r\nget \"/3\" (getApplication 3)\r\n...\r\n```\r\n\r\nBut this is impracticle because there can be a large number of items or new items are constantly being created with new IDs. Instead the solution is to use format strings. Remember that in the [Adding Pages Guide](../tutorials/adding-pages.html), we used `getf \"/%s\" index2Action` to pass a string to page.\r\n\r\n| Format Char | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nFor a numerical ID, we want to pass an int which is `%i` in the list above, so you can replace the lines above with\r\n\r\n```fsharp\r\ngetf \"/%i\" getApplication\r\n```\r\n\r\nNotice that `getf` is used instead of get. This is a separate version of get that handles `f`ormat characters.\r\n\r\n    You can use format strings with \"forward\" too by using \"forwardf\"\r\n\r\n## API Reference\r\n\r\nFull API reference for `router` CE can be found [here](../reference/Saturn/saturn-router-routerbuilder.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/directory-structure.html","title":"Directory Structure","content":"\r\n# Directory Structure\r\n\r\nAfter creating a new Saturn project, let's take a deeper look into what files are created.\r\n\r\n```bash\r\n├── .fake\r\n├── .paket\r\n├── .vs\r\n├── .packages\r\n├── paket-files\r\n├── src\r\n|   ├── Migrations\r\n|   └── SaturnSample\r\n├── .gitignore\r\n├── build.fsx\r\n├── global.json\r\n├── paket.dependencies\r\n├── paket.lock\r\n└── SaturnSample.sln\r\n```\r\n\r\nAt this level most of it is basic configuration files to help with running Saturn. From looking at the `.paket`, `paket-files`, `paket.dependencies`, `paket.lock` folders and files, you can see that by default Saturn uses [paket](https://fsprojects.github.io/Paket/) to handle package management. You won't be working with these files directly but rather through the command line tools instead.\r\n\r\nSaturn also uses [FAKE](https://fake.build/) to build the project. You can see how it is set up by looking at the `.fake` folder and `build.fsx` file.\r\n\r\nSaturn also provides a `.gitignore` file that prevents some folders from being tracked by git when they don't need to.\r\n\r\nLastly, there is the `SaturnSample.sln` solution file so you can open the project in an IDE like Visual Sudio and a `global.json` file to configure the solution file.\r\n\r\n### Project structure\r\n\r\nMost of the work you will do in this project however, will be in `src/SaturnSample`, which looks like the following when expanded:\r\n\r\n```bash\r\n  ├── bin\r\n  ├── Books\r\n  |   ├── BooksController.fs\r\n  |   ├── BooksModel.fs\r\n  |   ├── BooksRepository.fs\r\n  |   └── BooksView.fs\r\n  ├── obj\r\n  ├── static\r\n  |   ├── app.css\r\n  |   └── app.js\r\n  ├── Templates\r\n  |   ├── App.fs\r\n  |   ├── Index.fs\r\n  |   ├── InternalError.fs\r\n  |   └── NotFound.fs\r\n  ├── Config.fs\r\n  ├── Database.fs\r\n  ├── database.sqlite\r\n  ├── paket.references\r\n  ├── Program.fs\r\n  ├── Router.fs\r\n  └── SaturnSample.fsproj\r\n```\r\n\r\n`bin` and `obj` folders store the compiled version of the program after you build the project.\r\n\r\nThe convention for Saturn is that the model and everything associated with it are inside one folder. Everything is also named with the plural form of the model so \"Books\" instead of \"Book\".\r\n\r\nYour static files like css, js, and images should be inside the `static` folder.\r\n\r\n`Config.fs` contains a `Config` record that stores settings that you can use inside your application. By default, the record only contains the `connectionString` field.\r\n\r\n`Database.fs` contains functions to execute SQL queries within the program through [Dapper](https://stackexchange.github.io/Dapper/).\r\n\r\nIf you did not run `dotnet saturn migration` as in the [how to start guide](../tutorials/how-to-start.html), you might not see `database.sqlite`, but that is the database file that your Saturn project is using to store data.\r\n\r\n`paket.references` shows the packages that your project is using.\r\n\r\n`Program.fs` handles intializing the program and loading up various settings.\r\n\r\n`Router.fs` is where you will set the route of the site and what page to load.\r\n\r\nLastly, `SaturnSample.fsproj` is the project file itself."},{"uri":"https://saturnframework.org/explanations/endpoint-routing.html","title":"Endpoint Routing","content":"\r\n# Endpoint Routing\r\n\r\nSaturn from version `0.15` supports [ASP.NET Endpoint Routing](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1) additionally to custom routing implementation provided by Giraffe. The main difference between old routing and new one is that Endpoint Routing assumes total separation of routing from behavior - it works by statically defining list of all possible routes on startup of application. This impacts design of some of our Saturn abstractions, and means new routing is not 100% compatible with old one. On the bright side, theoretically, Endpoint Routing should provide noticeable performance boost, and in the future it will allow for better ecosystem integration.\r\n\r\n> Currently endpoint routing API is treated as an experimental API - it's subject to changes.\r\n\r\nTo use Endpoint Routing you need to open `Saturn.Endpoint` namespace - this will override known `router` and `controller` Computation Expressions with their Endpoint Routing versions. In `application` CE instead of using `use_router` operation you should use `use_endpoint_router` operation. For many simple applications this may be enough to get things working - we've been trying to keep API as compatible as possible.\r\n\r\nHowever there are differences:\r\n\r\n* With Endpoint Routing `router` and `controller` computation expressions are not transformed to `HttpHandler` but rather to `Endpoint list`. This has a huge impact on composability of those abstractions - you can't do things like `myHttpHandler >=> router { ... }` any more. Such code should be replaced with `plug/pipe_through` functionality in both `router` and `controller`. `Endpoint list` can basically be used in 2 places - in `forward` operation in `router` and `use_endpoint_router` in `application`.\r\n* Lack of `subroutef` in Giraffe-EndpointRouting - beacuse EndpointRouting needs to have all possible route templates at the application startup it's really hard to emulate some of previous Giraffe's routing composibility capabilities. From Saturn point of view this created 2 major changes:\r\n  - there's no `forwardf` in `router` CE anymore - it should be replaced with set of `getf/postf/putf ... ` operations in child router.\r\n  - `subController` in `controller` CE doesn't work well in Endpoint Routing - you can use as subcontrollers only old, HttpHandler based controllers (even if you parent controller is Endpoint Routing controller). In `Saturn.Endpoint` we provide additonal `subcontroller` CE - it's an alias to old `controller` CE\r\n* Lack of `case_insensitive` in `router` and `controller` - with Endpoint Routing all routes are case insensitive by default and there's no easy way to change it\r\n* Lack of `not_found_handler` in `router` and `controller` - as Endpoint Routing creates global table of routing having scoped not-found handlers is really tricky. Use built-in ways of handle 404 in ASP.NET (such as `UseDeveloperExceptionPage`)\r\n* Unlike Giraffe routing, Endpoint Routing doesn't ensure order of routing checks - this shouldn't be a problem in most cases, but I can imagine some edge cases in which this would matter.\r\n\r\nIn general, to reiterate - Endpoint Routing API in Giraffe/Saturn is still experimental. However, it probably is a future of Giraffe/Saturn so if possible please check if your applications can move to the Endpoint Routing API, and try it out. It's important for everyone involved to get feedback on this new routing engine."},{"uri":"https://saturnframework.org/explanations/overview.html","title":"Saturn Overview","content":"\r\n# Saturn Overview\r\n\r\nSaturn is a web development framework written in F# which implements the server-side MVC pattern. Many of its components and concepts will seem familiar to those of us with experience in other web frameworks like Ruby on Rails or Python’s Django. It's heavily inspired by Elixir's [Phoenix](http://phoenixframework.org/).\r\n\r\nBuilt on top of the battle-tested ASP.NET Core foundation and the highly flexible, extendable model of Giraffe, Saturn provides high level abstractions, helpers and tools to enable high developer productivity, at the same time keeping high application performance provided by Kestrel and Giraffe.\r\n\r\nSaturn is made up of a number of distinct parts, each with its own purpose and role to play in building a web application.\r\n\r\n - Application\r\n    - the start and end of the request life cycle\r\n    - handles all aspects of requests up until the point where the router takes over\r\n    - provides a core set of plugs to apply to all requests\r\n    - dispatches requests into a router\r\n    - enables application and hosting configuration\r\n - [Router](routing.html)\r\n    - parses incoming requests and dispatches them to the correct controller/action, passing parameters as needed\r\n    - provides helpers to generate route paths or urls to resources\r\n    - defines named pipelines through which we may pass our requests\r\n    - allows easy application of groups of plugs to a set of routes\r\n - [Controllers](controller.html)\r\n    - provide functions, called *actions*, to handle requests\r\n    - actions:\r\n        - prepare data and pass it into views\r\n        - invoke rendering via views\r\n        - perform redirects\r\n        - return data as JSON or XML\r\n        - and much more\r\n - [Views](view.html)\r\n    - render templates\r\n    - act as a presentation layer\r\n    - define helper functions, available in templates, to decorate data for presentation\r\n - Channels\r\n    - manage sockets for easy realtime communication\r\n    - are analogous to controllers except that they allow bi-directional communication with persistent connections\r\n - [Scaffolding scripts](scaffolding.html)\r\n    - `dotnet new` template providing good starting point for new applications - [https://github.com/SaturnFramework/Saturn.Template](https://github.com/SaturnFramework/Saturn.Template)\r\n    - `dotnet saturn` CLI tool that controls migrations and let you easily scaffold new parts of application - [https://github.com/SaturnFramework/Saturn.Dotnet](https://github.com/SaturnFramework/Saturn.Dotnet)\r\n\r\n\r\n### Saturn rings\r\n\r\nSaturn itself is the top layer of a multi-layer system designed to create a flexible, productive environment for creating web applications.\r\n\r\n#### Kestrel and ASP.NET Core\r\n\r\nASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-based, Internet-connected applications. Kestrel is a cross-platform web server for ASP.NET Core based on `libuv`, a cross-platform asynchronous I/O library. ASP.NET Core documentation can be found [here](https://docs.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-3.1)\r\n\r\n#### [Giraffe](https://github.com/giraffe-fsharp/Giraffe)\r\n\r\nGiraffe is an F# micro web framework for building rich web applications. It has been heavily inspired and is similar to [Suave](https://suave.io), but has been specifically designed with ASP.NET Core in mind and can be plugged into the ASP.NET Core pipeline via middleware. Giraffe applications are composed of so-called HttpHandler functions which can be thought of as a mixture of Suave's WebParts and ASP.NET Core's middleware. As Saturn shares many basic helper functions with Giraffe it's highly recommended to also check out [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n\r\n### Saturn moons\r\n\r\nSaturn is not only a library building on top of Giraffe, but also a set of opinionated tooling for scaffolding a whole project and then generating some boilerplate code. At the moment our template is using (by default):\r\n\r\n#### [Dapper](https://github.com/StackExchange/Dapper)\r\n\r\nA simple, focused on performance object mapper for .Net that you can add in to your project and will extend your `IDbConnection` interface.\r\n\r\n#### [Simple.Migrations](https://github.com/canton7/Simple.Migrations)\r\n\r\nSimple.Migrations is a simple bare-bones migration framework for .NET Core (.NET Standard 1.2 and .NET 4.5). It doesn't provide SQL generation, nor an out-of-the-box command-line tool, nor any other fancy feature. It does however provide a set of simple, extendable, and composable tools for integrating migrations into your application.\r\n\r\n\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/scaffolding.html","title":"Scaffolding","content":"\r\n# Scaffolding\r\n\r\nSaturn provides a command line scaffolding tool to generate a model, database migration, controller, and associated views.\r\n\r\nTo use the generator, run the `dotnet saturn` command from the root of your application application.  If you have used the template to generate your project, this is the directory with `build.fsx` or `paket.dependencies` file.\r\n\r\nThere are three flavors of generators that provide flexibility about what types of code is generated to support your model.\r\n\r\n| Command      |  Generates                                                                     |\r\n|--------------|--------------------------------------------------------------------------------|\r\n| gen          | Creates a model, database layer, HTML views, and a controller.                 |\r\n| gen.json     | Creates a model, database layer, and an API controller to access the model.    |\r\n| gen.model    | Creates only the model and database layer (no controller or views)             |\r\n\r\nEach of these commands will generate a migration for your model as well as a folder containing generated files.\r\n\r\nFor example:\r\n\r\n`dotnet saturn gen Book Books id:string title:string`\r\n\r\nGenerates the following structure:\r\n\r\n```bash\r\nsrc\r\n├── Migrations\r\n│   └── 201903192143.Book.fs\r\n│\r\n└── SaturnSample\r\n    └── Books\r\n        ├── BooksController.fs\r\n        ├── BooksModel.fs\r\n        ├── BooksRepository.fs\r\n        └── BooksViews.fs\r\n```\r\n\r\nEach of the generators takes arguments in the same format:\r\n\r\n`dotnet saturn gen <SingularModelName> <PluralModelName> <List of model fields with types>`\r\n\r\nThe list of model fields are names and types separated by a colon.\r\n\r\n`<fieldname>:<type>`\r\n\r\nCurrently supported types are:\r\n\r\n* string\r\n* int\r\n* float\r\n* double\r\n* decimal\r\n* guid\r\n* datetime\r\n* bool\r\n\r\n## Migrations\r\n\r\nUsing the generator to create a model will also create a migration file that will create a supporting table in the database. Execute the migration script using:\r\n\r\n`dotnet saturn migration`"},{"uri":"https://saturnframework.org/explanations/view.html","title":"View Engine","content":"\r\n# View Engine\r\n\r\n> This post has been originally part of the [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine)\r\n\r\nSaturn is built on top of Giraffe and can use any helpers it provides. This is a case for suggested view engine that you can use in Saturn - Giraffe has its own functional view engine which can be used to build rich UIs for web applications. The single biggest and best contrast to other view engines (e.g. Razor, Liquid, etc.) is that the Giraffe View Engine is entirely functional written in normal (and compiled) F# code.\r\n\r\nThis means that the Giraffe View Engine is by definition one of the most feature rich view engines available, requires no disk IO to load a view and views are automatically compiled at build time.\r\n\r\nThe Giraffe View Engine uses traditional functions and F# record types to generate rich HTML/XML views.\r\n\r\n### HTML Elements and Attributes\r\n\r\nHTML elements and attributes are defined as F# objects:\r\n\r\n```fsharp\r\nlet indexView =\r\n    html [] [\r\n        head [] [\r\n            title [] [ str \"Giraffe Sample\" ]\r\n        ]\r\n        body [] [\r\n            h1 [] [ str \"I |> F#\" ]\r\n            p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                str \"Hello World\"\r\n            ]\r\n        ]\r\n    ]\r\n```\r\n\r\nA HTML element can either be a `ParentNode`, a `VoidElement` or a `Text` element.\r\n\r\nFor example the `<html>` or `<div>` tags are typical `ParentNode` elements. They can hold an `XmlAttribute list` and a second `XmlElement list` for their child elements:\r\n\r\n```fsharp\r\nlet someHtml = div [] []\r\n```\r\n\r\nAll `ParentNode` elements accept these two parameters:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [ _id \"someId\"; _class \"css-class\" ] [\r\n        a [ _href \"https://example.org\" ] [ str \"Some text...\" ]\r\n    ]\r\n```\r\n\r\nMost HTML tags are `ParentNode` elements, however there is a few HTML tags which cannot hold any child elements, such as `<br>`, `<hr>` or `<meta>` tags. These are represented as `VoidElement` objects and only accept the `XmlAttribute list` as single parameter:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        br []\r\n        hr [ _class \"css-class-for-hr\" ]\r\n        p [] [ str \"bla blah\" ]\r\n    ]\r\n```\r\n\r\nAttributes are further classified into two different cases. First and most commonly there are `KeyValue` attributes:\r\n\r\n```fsharp\r\na [\r\n    _href \"http://url.com\"\r\n    _target \"_blank\"\r\n    _class \"class1\" ] [ str \"Click here\" ]\r\n```\r\n\r\nAs the name suggests, they have a key, such as `class` and a value such as the name of a CSS class.\r\n\r\nThe second category of attributes are `Boolean` flags. There are not many but some HTML attributes which do not require any value (e.g. `async` or `defer` in script tags). The presence of such an attribute means that the feature is turned on, otherwise it is turned off:\r\n\r\n```fsharp\r\nscript [ _src \"some.js\"; _async ] []\r\n```\r\n\r\nThere's also a wealth of [accessibility attributes](https://www.w3.org/TR/html-aria/) available under the `Giraffe.GiraffeViewEngine.Accessibility` module (needs to be explicitly opened).\r\n\r\n### Text Content\r\n\r\nNaturally the most frequent content in any HTML document is pure text:\r\n\r\n```html\r\n<div>\r\n    <h1>This is text content</h1>\r\n    <p>This is even more text content!</p>\r\n</div>\r\n```\r\n\r\nThe Giraffe View Engine lets one create pure text content as a `Text` element. A `Text` element can either be generated via the `rawText` or `encodedText` (or the short alias `str`) functions:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        p [] [ rawText \"<div>Hello World</div>\" ]\r\n        p [] [ encodedText \"<div>Hello World</div>\" ]\r\n    ]\r\n```\r\n\r\nThe `rawText` function will create an object of type `XmlNode` where the content will be rendered in its original form and the `encodedText`/`str` function will output a string where the content has been HTML encoded.\r\n\r\nIn this example the first `p` element will literally output the string as it is (`<div>Hello World</div>`) while the second `p` element will output the value as HTML encoded string `&lt;div&gt;Hello World&lt;/div&gt;`.\r\n\r\nPlease be aware that the the usage of `rawText` is mainly designed for edge cases where someone would purposefully want to inject HTML (or JavaScript) code into a rendered view. If not used carefully this could potentially lead to serious security vulnerabilities and therefore should be used only when explicitly required.\r\n\r\nMost cases and particularly any user provided content should always be output via the `encodedText`/`str` function.\r\n\r\n### Javascript event handlers\r\n\r\nIt is possible to add JavaScript event handlers to HTML elements using the Giraffe View Engine.  These event handlers (all prefixed with names starting with `_on`, for example `_onclick`, `_onmouseover`) can either execute inline JavaScript code or can invoke functions that are part of the `window` scope.\r\n\r\nThis example illustrates how inline JavaScript could be used to log to the console when a button is clicked:\r\n\r\n```fsharp\r\nlet inlineJSButton =\r\n    button [_id \"inline-js\"\r\n            _onclick \"console.log(\\\"Hello from the 'inline-js' button!\\\");\"] [str \"Say Hello\" ]\r\n```\r\n\r\nThere are some caveats with this approach, namely that\r\n* it is not very scalable to write JavaScript inline in this manner, and more pressing\r\n* the Giraffe View Engine HTML-encodes the text provided to the `_onX` attributes.\r\n\r\nTo get around this, you can write dedicated scripts in your HTML and reference the functions from your event handlers:\r\n\r\n```fsharp\r\nlet page =\r\n    div [] [\r\n        script [_type \"application/javascript\"] [\r\n            rawText \"\"\"\r\n            window.greet = function () {\r\n                console.log(\"ping from the greet method\");\r\n            }\r\n            \"\"\"\r\n        ]\r\n        button [_id \"script-tag-js\"\r\n                _onclick \"greet();\"] [str \"Say Hello\"]\r\n    ]\r\n```\r\n\r\nHere it's important to note that we've included the text of our script using the `rawText` tag.  This ensures that our text is not encoded by Giraffe so that it remains as we have written it.\r\n\r\nHowever, writing large quantities of JavaScript in this manner can be difficult, because you don't have access to the large ecosystem of javascript editor tooling.  In this case you should write your functions in another script and use a `script` tag element to reference your script, then add the desired function to your HTML element's event handler.\r\n\r\nSay you had a JavaScript file named `greet.js` and had configured Giraffe to serve that script from the WebRoot. Let us also say that the content of that script was:\r\n\r\n```javascript\r\nfunction greet() {\r\n    console.log(\"Hello from the greet function of greet.js!\");\r\n}\r\n```\r\n\r\nThen, you could reference that javascript via a script element, and use `greet` in your event handler like so:\r\n\r\n```fsharp\r\nlet page =\r\n    html [] [\r\n        head [] [\r\n            script [_type \"application/javascript\"\r\n                    _src \"/greet.js\"] [] // include our `greet.js` function dynamically\r\n        ]\r\n        body [] [\r\n            button [_id \"greet-btn\"\r\n                    _onclick \"greet()\"] [] // use the `greet()` function from `greet.js` to say hello\r\n        ]\r\n    ]\r\n```\r\n\r\nIn this way, you can write `greet.js` with all of your expected tooling, and still hook up the event handlers all in one place in Giraffe.\r\n\r\n### Naming Convention\r\n\r\nThe Giraffe View Engine has a naming convention which lets you easily determine the correct function name without having to know anything about the view engine's implementation.\r\n\r\nAll HTML tags are defined as `XmlNode` elements under the exact same name as they are named in HTML. For example the `<html>` tag would be `html [] []`, an `<a>` tag would be `a [] []` and a `<span>` or `<canvas>` would be the `span [] []` or `canvas [] []` function.\r\n\r\nHTML attributes follow the same naming convention except that attributes have an underscore prepended. For example the `class` attribute would be `_class` and the `src` attribute would be `_src` in Giraffe.\r\n\r\nThe underscore does not only help to distinguish an attribute from an element, but also avoid a naming conflict between tags and attributes of the same name (e.g. `<form>` vs. `<input form=\"form1\">`).\r\n\r\nIf a HTML attribute has a hyphen in the name (e.g. `accept-charset`) then the equivalent Giraffe attribute would be written in camel case notion (e.g. `acceptCharset`).\r\n\r\n*Should you find a HTML tag or attribute missing in the Giraffe View Engine then you can either [create it yourself](#custom-elements-and-attributes) or send a [pull request on GitHub](https://github.com/giraffe-fsharp/Giraffe/pulls).*\r\n\r\n### View Engine Best Practices\r\n\r\nDue to the huge amount of available HTML tags and their fairly generic (and short) names (e.g. `<form>`, `<option>`, `<select>`, etc.) there is a significant danger of accidentally overriding a function of the same name in an application's codebase. For that reason the Giraffe View Engine becomes only available after opening the `GiraffeViewEngine` module.\r\n\r\nAs a measure of good practice it is recommended to create all views in a separate module:\r\n\r\n```fsharp\r\nmodule MyWebApplication\r\n\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let index =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str \"Giraffe Sample\" ]\r\n            ]\r\n            body [] [\r\n                h1 [] [ str \"I |> F#\" ]\r\n                p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                    str \"Hello World\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let other = //...\r\n```\r\n\r\nThis ensures that the opening of the `GiraffeViewEngine` is only contained in a small context of an application's codebase and therefore less of a threat to accidental overrides. In the above example views can always be accessed through the `Views` sub module (e.g. `Views.index`).\r\n\r\n### Custom Elements and Attributes\r\n\r\nAdding new elements or attributes is normally as simple as a single line of code:\r\n\r\n```fsharp\r\nopen Giraffe.GiraffeViewEngine\r\n\r\n// If there was a new <foo></foo> HTML element:\r\nlet foo = tag \"foo\"\r\n\r\n// If <foo> is an element which cannot hold any content then create it as voidTag:\r\nlet foo = voidTag \"foo\"\r\n\r\n// If <foo> has a new attribute called bar then create a new bar attribute:\r\nlet _bar = attr \"bar\"\r\n\r\n// if the bar attribute is a boolean flag:\r\nlet _bar = flag \"bar\"\r\n```\r\n\r\nAlternatively you can also create new elements and attributes from inside another element:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n```\r\n\r\n### Rendering Views\r\n\r\nRendering views in Giraffe is done through one of the following functions:\r\n\r\n- `renderHtmlDocument`\r\n- `renderHtmlNodes`\r\n- `renderHtmlNode`\r\n- `renderXmlNodes`\r\n- `renderXmlNode`\r\n\r\nThe Giraffe View Engine cannot only be used to render HTML views, but also for any other XML based content such as `<svg>` images or other arbitrary XML based data.\r\n\r\nThe `renderHtmlDocument` function takes a single `XmlNode` as input parameter and renders a HTML page with a `DOCTYPE` declaration. This function should be used for rendering a complete HTML document. The `WriteHtmlViewAsync` extension method and the `htmlView` http handler both use the `renderHtmlDocument` function under the covers.\r\n\r\nThe `renderHtmlNodes` function takes an `XmlNode list` as input parameter and will output a single HTML string containing all the rendered HTML code. The `renderHtmlNode` function renders a single `XmlNode` element into a valid HTML string. Both, the `renderHtmlNodes` and `renderHtmlNode` function are useful for use cases where a HTML snippet needs to be created without a `DOCTYPE` declaration (e.g. templated emails, etc.).\r\n\r\nThe `renderXmlNodes` and `renderXmlNode` function are identical to `renderHtmlNodes` and `renderHtmlNode`, except that they will render void elements differently:\r\n\r\n```fsharp\r\nlet someTag = voidTag \"foo\"\r\nlet someContent = someTag []\r\n\r\n// Void tag will be rendered to valid HTML: <foo>\r\nlet output1 = renderHtmlNode someContent\r\n\r\n// Void tag will be rendered to valid XML: <foo />\r\nlet output2 = renderXmlNode someContent\r\n```\r\n\r\nAll `GiraffeViewEngine` http handlers are using a thread static `StringBuilderPool` to avoid the creation of large `StringBuilder` objects for each render call and dynamically grow/shrink that pool based on the application's needs. However if the application is running into any memory issues then this performance feature can be disabled by setting `StringBuilderPool.IsEnabled <- false`.\r\n\r\nAdditionally with Giraffe 3.0.0 or higher there is a new module called `ViewBuilder` under the `Giraffe.GiraffeViewEngine` namespace. This module exposes additional view rendering functions which compile a view into a `StringBuilder` object instead of returning a single `string`:\r\n\r\n- `ViewBuilder.buildHtmlDocument`\r\n- `ViewBuilder.buildHtmlNodes`\r\n- `ViewBuilder.buildHtmlNode`\r\n- `ViewBuilder.buildXmlNodes`\r\n- `ViewBuilder.buildXmlNode`\r\n\r\nThe `ViewBuilder.build[...]` functions can be useful if there is additional string processing required before/after composing a view by the `GiraffeViewEngine` (e.g. embedding HTML snippets in an email template, etc.). These functions also serve as the lower level building blocks of the equivalent `render[...]` functions.\r\n\r\nExample usage:\r\n\r\n```fsharp\r\nopen System.Text\r\nopen Giraffe.GiraffeViewEngine\r\n\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n\r\nlet sb = new StringBuilder()\r\n\r\n// Perform actions on the `sb` object...\r\nsb.AppendLine \"This is a HTML snippet inside a markdown string:\"\r\n  .AppendLine \"\"\r\n  .AppendLine \"```html\" |> ignore\r\n\r\nlet sb' = ViewBuilder.buildHtmlNode sb someHtml\r\n\r\n// Perform more actions on the `sb` object...\r\nsb'.AppendLine \"```\" |> ignore\r\n\r\nlet markdownOutput = sb'.ToString()\r\n```\r\n\r\n### Common View Engine Features\r\n\r\nThe Giraffe View Engine doesn't have any specially built functions for commonly known features such as master pages or partial views, mainly because the nature of the view engine itself doesn't require it in most cases.\r\n\r\n#### Master Pages\r\n\r\nCreating a master page is a simple matter of piping two functions together:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n... or even have multiple nested master pages:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master1 (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let master2 (content: XmlNode list) =\r\n        [\r\n            main [] content\r\n            footer [] [\r\n                p [] [\r\n                    str \"Copyright ...\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master2 |> master1 pageTitle\r\n```\r\n\r\n#### Partial Views\r\n\r\nA partial view is nothing more than one function or object being called from within another function:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n#### Working with Models\r\n\r\nA view which accepts a model is basically a function with an additional parameter:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index (model : IndexViewModel) =\r\n        [\r\n            h1 [] [ str model.PageTitle ]\r\n            p [] [ str model.WelcomeText ]\r\n        ] |> master model.PageTitle\r\n```\r\n\r\n#### If Statements, Loops, etc.\r\n\r\nThings like if statements, loops and other normal F# language constructs work just as expected:\r\n\r\n```fsharp\r\nlet partial (books : Book list) =\r\n    ul [] [\r\n        yield!\r\n            books\r\n            |> List.map (fun b -> li [] [ str book.Title ])\r\n    ]\r\n```\r\n\r\nOverall the Giraffe View Engine is extremely flexible and feature rich by nature based on the fact that it is generated via normal compiled F# code."},{"uri":"https://saturnframework.org/tutorials/adding-pages.html","title":"Adding Pages","content":"\r\n# Adding Pages\r\n\r\nThis guide uses the same project from the [how to start guide](how-to-start.html). Let's add two pages to it - one hello page and a page that can get your name from the URL.\r\n\r\n## Creating the View\r\n\r\nTo begin, create a `Hello` folder inside the `src/SaturnSample` folder.\r\n\r\nInside the folder, create a new file called \"HelloViews.fs\". This file will contain the functions to create the page.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Giraffe.GiraffeViewEngine\r\nopen Saturn\r\n\r\nmodule Views =\r\n  let index =\r\n    div [] [\r\n        h2 [] [rawText \"Hello from Saturn!\"]\r\n    ]\r\n```\r\n\r\nOne of the dependencies required is [Giraffe View Engine](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine). This will allow your project to define HTML within your function. The `index` function will result in the following HTML code:\r\n\r\n```html\r\n<div>\r\n    <h2>Hello from Saturn!</h2>\r\n</div>\r\n```\r\n\r\n## Creating the Controller\r\n\r\nCreate a `HelloController.fs` file inside the `Hello` folder.\r\n\r\nThe `index` function tells us what the HTML will be but we still need to tell Saturn to return it as an HTML page. We also need to tell Saturn where the page is.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Saturn\r\nopen Giraffe.ResponseWriters\r\n\r\nmodule Controller =\r\n    let indexAction =\r\n        htmlView (Views.index)\r\n\r\n    let helloView = router {\r\n        get \"/\" indexAction\r\n    }\r\n```\r\n\r\nThe `indexAction` tells Saturn to create an HTML page using the `index` function inside \"HelloViews.fs\"\r\n\r\n`helloView` lets Saturn know that the page is located at the root.\r\n\r\n## Adding the 2 new files to the project\r\n\r\nFor the project to see the new files, modify SaturnSample.fsproj as below:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <Compile Include=\"Database.fs\" />\r\n    <Compile Include=\"Config.fs\" />\r\n\r\n    <Compile Include=\"Hello\\HelloViews.fs\" />\r\n    <Compile Include=\"Hello\\HelloController.fs\" />\r\n    ...\r\n```\r\n\r\n## Adding it to Router.fs\r\n\r\n\r\nAfter setting up the route, you need to update the project with the new route.\r\n\r\nIn \"Router.fs\", add the following to the inside of the `browserRouter` function:\r\n\r\n\r\n```fsharp\r\nforward \"/hello\" Hello.Controller.helloView\r\n```\r\n\r\nThis means that when we navigate to [http://localhost:8085/hello](http://localhost:8085/hello), the `helloView` function will determine what page to load there. Looking inside the `helloView` function, we said that `indexAction` is called at the root. In conclusion, the page will be located at [http://localhost:8085/hello/](http://localhost:8085/hello/). (Note the \"/\" at the end)\r\n\r\nNow run the program and go to [http://localhost:8085/hello/](http://localhost:8085/hello/) and you will see a page saying \"Hello from Saturn!\"\r\n\r\n## Sending a parameter to your page\r\n\r\nWhat if you want the page to display your name?\r\n\r\nOne way to retrieve your name is to get it from the route. So when you go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) with {yourname} being your actual name, it will grab your name which can then be used to display on the page.\r\n\r\nTo begin, add a new view in your `HelloViews.fs`:\r\n\r\n```fsharp\r\n  let index2 (name : string) =\r\n    div [] [\r\n        h2 [] [rawText (\"Hello \" + name + \"!\")]\r\n    ]\r\n```\r\n\r\nThis function requires passing in the name to be displayed. The name will be retrieved from the route.\r\n\r\nAdd the following to the `HelloController.fs` file below the `helloView` handler:\r\n\r\n```fsharp\r\nlet index2Action name=\r\n    htmlView (Hello.Views.index2 name)\r\n```\r\n\r\nNow to set up the route. Add the following to the `HelloView` handler:\r\n\r\n```fsharp\r\ngetf \"/%s\" index2Action\r\n```\r\n\r\n\"%s\" is a format string. This lets Saturn know to save whatever you type in that spot. Since we want to save a name, we want to save it as a string so we use `%s`.\r\n\r\nThere are other format strings for different types:\r\n\r\n| Format String | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nNow run the program and go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) and replace `{yourname}` with your name to see a page that will greet you.\r\n"},{"uri":"https://saturnframework.org/tutorials/adding-saturn-to-an-existing-giraffe-app.html","title":"Adding Saturn to an existing Giraffe application","content":"\r\n# Adding Saturn to an existing Giraffe application\r\n\r\nThe previous chapter showed how to get started with a new application.\r\n\r\nIf you already have a working Giraffe webserver, you can gradually opt-in to Saturn.\r\n\r\nFor example, if your existing app looks like this:\r\n\r\n```fsharp\r\n\r\ntype Customer = {\r\n    Name : string\r\n    Address : string\r\n}\r\n\r\nlet customers =\r\n    choose [\r\n      GET >=> (json { Name = \"Mr. Smith\"; Address = \"Santa Monika\"})\r\n      PUT >=> (bindJson<Customer> (fun customer -> printfn \"Adding customer %A\" customer; setStatusCode 200))\r\n    ]\r\n\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"               >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n    ]\r\n```\r\n\r\nand you need to add \"vendor\" functionality, you could implement it as a Saturn ``router`` while keeping everything else intact:\r\n\r\n\r\n```fsharp\r\n// the new Saturn router\r\nlet vendors = router {\r\n    getf \"/%i\" (fun vendorId -> (json (readVendorFromDb vendorId)))\r\n    post \"/\" (bindJson<Vendor> (fun customer -> addVendor vendor; setStatusCode 200))\r\n}\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"                >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n        // plug the new Saturn router into the Giraffe app\r\n        route \"/api/vendors\"     >=> vendors\r\n    ]\r\n```\r\n\r\n## Embedding Giraffe Handlers into Saturn\r\n\r\nOf course the other way around also works.\r\n\r\nFor example, [Elmish.Bridge](https://github.com/Nhowka/Elmish.Bridge) does not provide a specialized implementation for Saturn. And it doesn't need to, because we can just use the Giraffe implementation!\r\n\r\n```fsharp\r\n\r\nopen Elmish\r\nopen Elmish.Bridge\r\n\r\nlet elmishBridgeHandler : HttpHandler =\r\n  Bridge.mkServer Shared.endpoint init update\r\n  |> Bridge.run Giraffe.server\r\n\r\n// our existing Saturn router\r\nlet router = router {\r\n\r\n    // ...\r\n\r\n    forward \"\" elmishBridgeHandler\r\n}\r\n```\r\n"},{"uri":"https://saturnframework.org/tutorials/how-to-start.html","title":"Getting started","content":"\r\n# How to start in 60 seconds\r\n\r\nRequirements:\r\n\r\n* `dotnet` SDK 3.1 [https://dotnet.microsoft.com/download/dotnet-core/3.1](https://dotnet.microsoft.com/download/dotnet-core/3.1)\r\n\r\n## Template\r\n\r\nThe easiest way to get started is to use the provided template:\r\n\r\n1. Install the `dotnet` template with `dotnet new -i Saturn.Template`\r\n2. Create a new folder and move into it - `mkdir SaturnSample && cd SaturnSample`\r\n3. Create a new Saturn application - `dotnet new saturn -lang F#`\r\n4. Install all necessary dev tools - `dotnet tool restore`\r\n6. Create a new controller with `dotnet saturn gen Book Books id:string title:string author:string`\r\n7. Run migrations that will create the database and Books table (as for now, the generator is using only SQLite DB) - `dotnet saturn migration`\r\n8. Open the folder in your favourite editor (VSCode) and insert the line (`forward \"/books\" Books.Controller.resource`) into `browserRouter` in `Router.fs` file\r\n9. Start the application by running `dotnet fake build -t run` from the root of the solution. This will start the application in watch mode (automatic recompilation on changes) and open your browser on [http://localhost:8085](http://localhost:8085) which should display the index page.\r\n10. Go to [http://localhost:8085/books](http://localhost:8085/books) to see the generated view. All buttons should be working; you can add new entries, and remove or edit old ones.\r\n\r\n\r\n## Hello World\r\n\r\nIf you want to start from scratch with a minimal Saturn webserver:\r\n\r\n1. Create a new F# Project (for example with `dotnet new console -lang F#`)\r\n2. Add the `Saturn` NuGet Package\r\n\r\n```fsharp\r\nopen Saturn\r\nopen Giraffe\r\n\r\nlet app = application {\r\n    use_router (text \"Hello World from Saturn\")\r\n}\r\n\r\nrun app\r\n```\r\n\r\nIf you compile and run this application, it will unconditionally return the text regardless of the path.\r\n\r\nFrom here on out you can add [routers](../explanations/routing.html), [controllers](../explanations/controller.html) and [views](../explanations/view.html).\r\n\r\n## Deep Dive\r\n\r\nTo get a better understanding of Saturn and the whole SAFE Stack you can look at the [SAFE-Dojo](https://github.com/CompositionalIT/SAFE-Dojo).\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/controller.html","title":"Controllers","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Controller\r\n\r\nIn Saturn, a **controller** is a list of routes that is focused on a **model** (an object that contains your data). So if you have a user model, some common operations are to display the list of users, show details of a user, add a user, update or user, or remove a user. A controller is a great way to organize all of these actions.\r\n\r\nEach of the operations is a separate route and a controller is an easy way to group these routes together.\r\n\r\nA basic user controller is shown below:\r\n\r\n*)\r\nopen Saturn\r\n\r\nlet userController = controller {\r\n    index (fun ctx -> \"Index handler version 1\" |> Controller.text ctx) //View list of users\r\n    add (fun ctx -> \"Add handler version 1\" |> Controller.text ctx) //Add a user\r\n    create (fun ctx -> \"Create handler version 1\" |> Controller.text ctx) //Create a user\r\n    show (fun ctx id -> (sprintf \"Show handler version 1 - %i\" id) |> Controller.text ctx) //Show details of a user\r\n    edit (fun ctx id -> (sprintf \"Edit handler version 1 - %i\" id) |> Controller.text ctx)  //Edit a user\r\n    update (fun ctx id -> (sprintf \"Update handler version 1 - %i\" id) |> Controller.text ctx)  //Update a user\r\n}\r\n\r\n(**\r\nHere we can see the `index`, `add`, `create`, `show`, `edit`, and `update` operations but there are more operations that are not shown here like `patch` and `delete`. You can see all the operations int the [API Reference](../reference/Saturn/saturn-controller-controllerbuilder-10.html). You do not have to handle all of the operations.\r\n\r\nYou might be wondering what the difference is between `add` and `create` or `edit` and `update`. The `add` operation tells the application to return the form so that the user can enter the data for the user to be added. The `create` operation will commit the data to the database of the application. It is the same with `edit` for displaying the form and `update` for committing the change.\r\n\r\nTo add the controller for the routes, you can add it to the `defaultView` router like so:\r\n\r\n*)\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n    forward \"/users\" userController\r\n}\r\n\r\n(**\r\nThe route will now be:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            ├── \"/default.html\"     -redirect to yoursite.com/\r\n            └── \"/users\"\r\n                ├── index \"/\"           -yoursite.com/users/\r\n                ├── add \"/add\"          -yoursite.com/users/add\r\n                ├── create              -POST yoursite.com/users/add\r\n                ├── show \"/%i\"          -yoursite.com/users/%i\r\n                ├── edit \"/%i/edit\"     -yoursite.com/users/%i/edit\r\n                └── update \"\"           -POST yoursite.com/users/%i/edit\r\n```\r\n\r\nThe create and update operations make changes to the database so you have to make a POST request containing the information you want to save to the database.\r\n\r\n## Subcontroller\r\n\r\nNow that you know how to chain routers together to create routes, we can look at a common scenario for a website. A website usually has users and each user can create multiple comments.\r\n\r\n```bash\r\nyoursite.com\r\n└── \"/users\"\r\n    └── \"/%i\"           -yoursite.com/users/%i\r\n        └── \"/comments\" (commentController)\r\n            ├── index \"/\"           -yoursite.com/users/{userId}/comments/\r\n            └── show \"/%i\"          -yoursite.com/users/{userId}/comments/{commentId}\r\n```\r\n\r\nIn Saturn, you can make the comment controller a subcontroller of the user controller. It looks like the following code:\r\n\r\n*)\r\n\r\nlet commentController userId = controller {\r\n    index (fun ctx -> (sprintf \"Comment Index handler for user %i\" userId ) |> Controller.text ctx)\r\n    add (fun ctx -> (sprintf \"Comment Add handler for user %i\" userId ) |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show comment %s handler for user %i\" id userId ) |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit comment %s handler for user %i\" id userId )  |> Controller.text ctx)\r\n}\r\n\r\nlet userController = controller {\r\n    subController \"/comments\" commentController\r\n\r\n    plug [All] (setHttpHeader \"user-controller-common\" \"123\")\r\n    plug [Index; Show] (setHttpHeader \"user-controller-specialized\" \"123\")\r\n\r\n    index (fun ctx -> \"Index handler no version\" |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show handler no version - %i\" id) |> Controller.text ctx)\r\n    add (fun ctx -> \"Add handler no version\" |> Controller.text ctx)\r\n    create (fun ctx -> \"Create handler no version\" |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit handler no version - %i\" id) |> Controller.text ctx)\r\n    update (fun ctx id -> (sprintf \"Update handler no version - %i\" id) |> Controller.text ctx)\r\n    delete (fun ctx id -> failwith (sprintf \"Delete handler no version failed - %i\" id) |> Controller.text ctx)\r\n    error_handler (fun ctx ex -> sprintf \"Error handler no version - %s\" ex.Message |> Controller.text ctx)\r\n}\r\n\r\n(**\r\n\r\nTo create a subcontroller, start with creating a controller for your model. After that, define it as a subcontroller inside the main controller with the following code:\r\n\r\n```fsharp\r\n    subController \"/yourModel\" yourModelController\r\n```\r\n\r\n\r\n## API Reference\r\n\r\nFull API reference for `controller` CE can be found [here](../reference/Saturn/saturn-controller-controllerbuilder-10.html)\r\n\r\nFull API reference for `Controller` module containing useful helpers can be found [here](../reference/Saturn/saturn-controllerhelpers-controller.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/pipeline.html","title":"Pipeline","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Pipelines\r\n\r\nPipeline is a computation expression used to combine `HttpHandlers` in a declarative manner.\r\n\r\nThe result of the computation expression is a standard Giraffe `HttpHandler` which means that it's easily composable with other parts of the Giraffe ecosystem.\r\n\r\n**Example:**\r\n\r\n*)\r\n\r\nopen Saturn\r\n\r\nlet headerPipe = pipeline {\r\n    set_header \"myCustomHeader\" \"abcd\"\r\n    set_header \"myCustomHeader2\" \"zxcv\"\r\n}\r\n\r\nlet endpointPipe = pipeline {\r\n    plug fetchSession\r\n    plug head\r\n    plug requestId\r\n}\r\n\r\n\r\n(**\r\n## API Reference\r\n\r\nFull API reference for `pipeline` CE can be found [here](../reference/Saturn/saturn-pipeline-pipelinebuilder.html)\r\n\r\nFull API reference for `PipelineHelpers` module containing useful helpers can be found [here](../reference/Saturn/saturn-pipelinehelpers.html)\r\n\r\nYou can also use in pipelines (using `plug`) any `HttpHandler` defined in Giraffe - documentation can be found [here](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/routing.html","title":"Router","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\nmodule Index =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nmodule NotFound =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nlet someScopeOrController = Giraffe.ResponseWriters.text \"\"\r\n\r\n(**\r\n# Routing\r\n\r\nRoutes are how Saturn connects all the HTTP requests to the different actions. Think of a route as the URL of the application. The site is yoursite.com but you may have a route for your about page such as yoursite.com/about.\r\n\r\nIn Saturn, `Routers` contain all the routes of your application. A router is a list of routes. A website can have a router that handles the different routes to your page like so:\r\n\r\n```bash\r\nyoursite.com\r\n├── \"/\"             -yoursite.com/\r\n├── \"/about\"        -yoursite.com/about\r\n├── \"/contact\"      -yoursite.com/contact\r\n├── \"/news\"         -yoursite.com/news\r\n└── \"/investors\"    -yoursite.com/investors\r\n```\r\n\r\nSince this is at the root, this is your router at `\"\"` path. You can then add a router inside another router to have the following:\r\n\r\n```bash\r\nyoursite.com\r\n├── books           -yoursite.com/books\r\n|   ├── list        -yoursite.com/books/list\r\n|   ├── add         -yoursite.com/books/add\r\n|   ├── update      -yoursite.com/books/update\r\n|   └── delete      -yoursite.com/books/update\r\n├── about           -yoursite.com/about\r\n├── contact         -yoursite.com/contact\r\n├── news            -yoursite.com/news\r\n└── investors       -yoursite.com/investors\r\n```\r\n\r\nNow you have a router for the `\"/books\"` path inside another router for the `\"\"` path.\r\n\r\nNow to see it in code, create a Saturn project from the template and you will have a `Router.fs` file like this:\r\n\r\n*)\r\n\r\n\r\nopen Saturn\r\nopen Giraffe.Core\r\nopen Giraffe.ResponseWriters\r\n\r\n\r\nlet browser = pipeline {\r\n    plug acceptHtml\r\n    plug putSecureBrowserHeaders\r\n    plug fetchSession\r\n    set_header \"x-pipeline-type\" \"Browser\"\r\n}\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\nlet browserRouter = router {\r\n    not_found_handler (htmlView NotFound.layout) //Use the default 404 webpage\r\n    pipe_through browser //Use the default browser pipeline\r\n\r\n    forward \"\" defaultView //Use the default view\r\n}\r\n\r\n//Other scopes may use different pipelines and error handlers\r\n\r\n// let api = pipeline {\r\n//     plug acceptJson\r\n//     set_header \"x-pipeline-type\" \"Api\"\r\n// }\r\n\r\n// let apiRouter = router {\r\n//     not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n//     pipe_through api\r\n//\r\n//     forward \"/someApi\" someScopeOrController\r\n// }\r\n\r\nlet appRouter = router {\r\n    // forward \"/api\" apiRouter\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nFirst, take a look at the `router` function.\r\n\r\n*)\r\n\r\nlet appRouter' = router {\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nThe `appRouter` value is a `router`. Inside is the `forward \"\" browserRouter` line. The `forward` function needs a path and a router. In this case, the path is an empty string and the router is `browserRouter`. That means that the `browserRouter` router will handle the routes at the current location. Since `appRouter` is the first router called, the current location is the root of the application.\r\n\r\nNow let's look at `browserRouter`:\r\n\r\n*)\r\n\r\nlet browserRouter' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    forward \"\" defaultView\r\n}\r\n\r\n(**\r\n\r\nThere are three lines. The first line, `not_found_handler (htmlView NotFound.layout)` tells `browserRouter` to display a not found page if the user enters a route that the application does not handle. The second line tells the application to use the `browser` pipeline defined above. The pipeline is a list of settings on how the website will deliver the pages. Lastly, `forward \"\" defaultView` is like `forward \"\" browserRouter` from the `appRouter`. Again, `browserRouter` does not contain any routes but it tells the `defaultView` router to handle them. Finally, we get to the part where the application is told how to handle the routes. Inside `defaultView`, we created 3 routes:\r\n\r\n*)\r\n\r\nlet defaultView' = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nHere, we see that `get` is used to define the routes. There are 3 routes here but 2 of them redirect to the first route. To illustrate, the routes are:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            └── \"/default.html\"     -redirect to yoursite.com/\r\n```\r\n\r\nLooking at the first line inside `defaultView`, `get \"/\" (htmlView Index.layout)` tells the application to display `Index.layout` at the root of the application. The `get` corresponds to the HTTP verb GET so when you type in a link, the browser tries to GET the page. The first parameter of `get` is \"/\", so basically when getting the root, the `get` function will return something. The second parameter is `(htmlView Index.layout)` so the `get` function returns an HTML page specified by Index.layout. The second and third line have `(redirectTo false \"/\")`, telling the application to go to \"yoursite.com/\" when going to \"yoursite.com/index\" or \"yoursite.com/default\"\r\n\r\n## Best Practices\r\n\r\nYou can combine all 3 routers into one router like so:\r\n\r\n*)\r\n\r\n\r\nlet appRouter'' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nThe template splits them into 3 to encourage good practices. In the first router, you can see the commented out code `forward \"/api\" apiRouter`. This is a good suggestion in the template to have a separate router to handle your API routes. We set up how to deliever the webpage with `pipe_through browser` in `browserRouter`. The settings are important for a browser to know how to handle your routes but not for a different application to access your routes as an API.\r\n\r\nThe template provides an example of how to set up the API routes in the commented out code, which I copied below:\r\n\r\n*)\r\n\r\nlet api = pipeline {\r\n    plug acceptJson\r\n    set_header \"x-pipeline-type\" \"Api\"\r\n}\r\n\r\nlet apiRouter = router {\r\n    not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n    pipe_through api\r\n\r\n    forward \"/someApi\" someScopeOrController\r\n}\r\n\r\n(**\r\n\r\nHere we have the `apiRouter` router which does not return a 404 page but a 404 text instead which is appropriate for an API. The router also uses a pipeline that is more appropriate for an API such as accepting JSON inputs instead of HTML as in the `browser` pipeline.\r\n\r\n## Format Strings\r\n\r\nYou might be wondering how to make routes that accept a numerical ID. You can make multiple routes for each ID like so\r\n\r\n```fsharp\r\nget \"/1\" (getApplication 1)\r\nget \"/2\" (getApplication 2)\r\nget \"/3\" (getApplication 3)\r\n...\r\n```\r\n\r\nBut this is impracticle because there can be a large number of items or new items are constantly being created with new IDs. Instead the solution is to use format strings. Remember that in the [Adding Pages Guide](../tutorials/adding-pages.html), we used `getf \"/%s\" index2Action` to pass a string to page.\r\n\r\n| Format Char | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nFor a numerical ID, we want to pass an int which is `%i` in the list above, so you can replace the lines above with\r\n\r\n```fsharp\r\ngetf \"/%i\" getApplication\r\n```\r\n\r\nNotice that `getf` is used instead of get. This is a separate version of get that handles `f`ormat characters.\r\n\r\n    You can use format strings with \"forward\" too by using \"forwardf\"\r\n\r\n## API Reference\r\n\r\nFull API reference for `router` CE can be found [here](../reference/Saturn/saturn-router-routerbuilder.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/reference/Saturn/index.html","title":"Saturn - API Reference","content":"Saturn \n Saturn Saturn.Endpoint"},{"uri":"https://saturnframework.org/reference/Saturn/saturn-application.html","title":"Application","content":"Application \n <p>Module containing <code>application</code> computation expression</p>\r\n\r\n \n Config <p>Helpers for getting configuration</p>\r\n\r\n Environment <p>Helpers for getting environment info</p>\r\n\r\n \n ApplicationBuilder <p>Computation expression used to configure Saturn application.\r\nUnder the hood it's using ASP.NET application configurations interfaces such as <code>IWebHostBuilder</code>, <code>IServiceCollection</code>, <code>IApplicationBuilder</code> and others.\r\nIt aims to hide cumbersome ASP.NET application configuration and enable high level, declarative application configuration using feature toggles.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\">1: </span>\r\n<span class=\"l\">2: </span>\r\n<span class=\"l\">3: </span>\r\n<span class=\"l\">4: </span>\r\n<span class=\"l\">5: </span>\r\n<span class=\"l\">6: </span>\r\n<span class=\"l\">7: </span>\r\n<span class=\"l\">8: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"id\">app</span> <span class=\"o\">=</span> <span class=\"id\">application</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">pipe_through</span> <span class=\"id\">endpointPipe</span>\r\n    <span class=\"id\">use_router</span> <span class=\"id\">topRouter</span>\r\n    <span class=\"id\">url</span> <span class=\"s\">&quot;http://0.0.0.0:8085/&quot;</span>\r\n    <span class=\"id\">memory_cache</span>\r\n    <span class=\"id\">use_static</span> <span class=\"s\">&quot;static&quot;</span>\r\n    <span class=\"id\">use_gzip</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val app : obj</div>\r\n\r\n ApplicationState <p>Type representing internal state of the <code>application</code> computation expression</p>\r\n\r\n \n parseAndValidateOauthTicket <p>generic oauth parse and validate logic, shared with the auth extensions package</p>\r\n\r\n application <p>Computation expression used to configure Saturn application</p>\r\n\r\n run <p>Runs Saturn application</p>\r\n\r\n \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-application-config.html","title":"Config","content":"Config \n <p>Helpers for getting configuration</p>\r\n\r\n \n  \n  \n getConfinguration  \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-application-environment.html","title":"Environment","content":"Environment \n <p>Helpers for getting environment info</p>\r\n\r\n \n  \n  \n getWebHostEnvironment  \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-auth.html","title":"Auth","content":"Auth \n <p>Module with some useful helpers functions that can be used for authentication, such as creating JWT tokens, or <code>HttpHandlers</code> checking if request is authenticated.</p>\r\n\r\n \n  \n  \n requireAuthentication <p>Requires authentication and uses given challenge type if not authenticated</p>\r\n\r\n requireRole <p>Requires role and uses given challenge type if not authenticated</p>\r\n\r\n requireRoleOf <p>Requires one of the roles and uses given challenge type if not authenticated</p>\r\n\r\n requireClaim <p>Requires claim of given type with given value and uses given challenge type if not authenticated</p>\r\n\r\n generateJWT <p>Helper function to generate JWT token using <code>Microsoft.IdentityModel.Tokens</code> and <code>System.IdentityModel.Tokens.Jwt</code></p>\r\n\r\n \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-cors.html","title":"CORS","content":"CORS \n <p>Module defining CORS <code>HttpHandler</code></p>\r\n\r\n \n  \n CORSConfig <p>The configuration values for CORS</p>\r\n\r\n \n cors <p>Check the incoming request against the provided <a href=\"saturn-cors-corsconfig.html\" title=\"CORSConfig\"><code>CORSConfig</code></a>.</p>\r\n\r\n defaultCORSConfig  \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-csrf.html","title":"CSRF","content":"CSRF \n <p>Module containing helpers for CSRF Antiforgery protection</p>\r\n\r\n \n View <p>Contains view helpers for csrf tokens for various view engines.</p>\r\n\r\n \n CSRFError  \n tryCsrf <p>Protect a resource by validating that requests that can change state come with a valid request antiforgery token, which is based off of a known session token.\r\nThe particular configuration options can be set via the <code>application</code> builder's <code>use_antiforgery_with_config</code> method.\r\nIf the request is not valid, a custom error handler will be invoked with the validation error</p>\r\n\r\n csrf <p>Protect a resource by validating that requests that can change state come with a valid request antiforgery token, which is based off of a known session token.\r\nThe particular configuration options can be set via the <code>application</code> builder's <code>use_antiforgery_with_config</code> method.</p>\r\n\r\n getRequestTokens  \n ValidateCSRF <p>Protect a resource by validating that requests that can change state come with a valid request antiforgery token, which is based off of a known session token.\r\nThe particular configuration options can be set via the <code>application</code> builder's <code>use_antiforgery_with_config</code> method.\r\nIf the request is not valid, an exception will be thrown with details</p>\r\n\r\n TryValidateCSRF <p>Protect a resource by validating that requests that can change state come with a valid request antiforgery token, which is based off of a known session token.\r\nThe particular configuration options can be set via the <code>application</code> builder's <code>use_antiforgery_with_config</code> method.\r\nIf the request is not valid, an Error result will be returned with details</p>\r\n\r\n"},{"uri":"https://saturnframework.org/reference/Saturn/saturn-csrf-view.html","title":"View","content":"View \n <p>Contains view helpers for csrf tokens for various view engines.</p>\r\n\r\n \n Giraffe  \n  \n  \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-csrf-view-giraffe.html","title":"Giraffe","content":"Giraffe \n  \n  \n  \n csrfTokenInput <p>Creates a csrf token form input of the kind: <input type=\"hidden\" name=\"TOKEN_NAME\" value=\"TOKEN_VALUE\" /></p>\r\n\r\n protectedForm <p>View helper for creating a form that implicitly inserts a CSRF token hidden form input.</p>\r\n\r\n \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-challengetype.html","title":"ChallengeType","content":"ChallengeType \n  \n  \n ChallengeType  \n  \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channelbuilder.html","title":"ChannelBuilder","content":"ChannelBuilder \n <p>Module with <code>channel</code> computation expression</p>\r\n\r\n \n  \n ChannelBuilder <p>Computation expression used to create channels - an <code>controller</code>-like abstraction over WebSockets allowing real-time, and push-based communication between server and the client\r\nThe messages handled by channels should be json-encoded, in a following form: <code>{Topic = \"my topic\"; Ref = \"unique-message-id\"; Payload = {...} }</code></p>\r\n<p>The result of the computation expression is the <a href=\"saturn-channels-ichannel.html\" title=\"IChannel\"><code>IChannel</code></a> instance that can be registered in the <code>application</code> computation expression using <code>add_channel</code> operation.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\"> 1: </span>\r\n<span class=\"l\"> 2: </span>\r\n<span class=\"l\"> 3: </span>\r\n<span class=\"l\"> 4: </span>\r\n<span class=\"l\"> 5: </span>\r\n<span class=\"l\"> 6: </span>\r\n<span class=\"l\"> 7: </span>\r\n<span class=\"l\"> 8: </span>\r\n<span class=\"l\"> 9: </span>\r\n<span class=\"l\">10: </span>\r\n<span class=\"l\">11: </span>\r\n<span class=\"l\">12: </span>\r\n<span class=\"l\">13: </span>\r\n<span class=\"l\">14: </span>\r\n<span class=\"l\">15: </span>\r\n<span class=\"l\">16: </span>\r\n<span class=\"l\">17: </span>\r\n<span class=\"l\">18: </span>\r\n<span class=\"l\">19: </span>\r\n<span class=\"l\">20: </span>\r\n<span class=\"l\">21: </span>\r\n<span class=\"l\">22: </span>\r\n<span class=\"l\">23: </span>\r\n<span class=\"l\">24: </span>\r\n<span class=\"l\">25: </span>\r\n<span class=\"l\">26: </span>\r\n<span class=\"l\">27: </span>\r\n<span class=\"l\">28: </span>\r\n<span class=\"l\">29: </span>\r\n<span class=\"l\">30: </span>\r\n<span class=\"l\">31: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"id\">browserRouter</span> <span class=\"o\">=</span> <span class=\"id\">router</span> <span class=\"pn\">{</span>\r\n  <span class=\"id\">get</span> <span class=\"s\">&quot;/ping&quot;</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">next</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"id\">task</span> <span class=\"pn\">{</span>\r\n    <span class=\"k\">let</span> <span class=\"id\">hub</span> <span class=\"o\">=</span> <span class=\"id\">ctx</span><span class=\"pn\">.</span><span class=\"id\">GetService</span><span class=\"o\">&amp;</span><span class=\"id\">lt</span><span class=\"pn\">;</span><span onmouseout=\"hideTip(event, 'fs2', 2)\" onmouseover=\"showTip(event, 'fs2', 2)\" class=\"id\">Saturn</span><span class=\"pn\">.</span><span onmouseout=\"hideTip(event, 'fs3', 3)\" onmouseover=\"showTip(event, 'fs3', 3)\" class=\"id\">Channels</span><span class=\"pn\">.</span><span onmouseout=\"hideTip(event, 'fs4', 4)\" onmouseover=\"showTip(event, 'fs4', 4)\" class=\"id\">ISocketHub</span><span class=\"pn\">&gt;</span><span class=\"pn\">(</span><span class=\"pn\">)</span>\r\n    <span class=\"k\">match</span> <span class=\"id\">ctx</span><span class=\"pn\">.</span><span class=\"id\">TryGetQueryStringValue</span> <span class=\"s\">&quot;message&quot;</span> <span class=\"k\">with</span>\r\n    <span class=\"pn\">|</span> <span onmouseout=\"hideTip(event, 'fs5', 5)\" onmouseover=\"showTip(event, 'fs5', 5)\" class=\"id\">None</span> <span class=\"k\">-&gt;</span>\r\n      <span class=\"k\">do!</span> <span class=\"id\">hub</span><span class=\"pn\">.</span><span class=\"id\">SendMessageToClients</span> <span class=\"s\">&quot;/channel&quot;</span> <span class=\"s\">&quot;greeting&quot;</span> <span class=\"s\">&quot;hello&quot;</span>\r\n    <span class=\"pn\">|</span> <span onmouseout=\"hideTip(event, 'fs6', 6)\" onmouseover=\"showTip(event, 'fs6', 6)\" class=\"id\">Some</span> <span class=\"id\">message</span> <span class=\"k\">-&gt;</span>\r\n      <span class=\"k\">do!</span> <span class=\"id\">hub</span><span class=\"pn\">.</span><span class=\"id\">SendMessageToClients</span> <span class=\"s\">&quot;/channel&quot;</span> <span class=\"s\">&quot;greeting&quot;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs7', 7)\" onmouseover=\"showTip(event, 'fs7', 7)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;hello, %s&quot;</span> <span class=\"id\">message</span><span class=\"pn\">)</span>\r\n    <span class=\"k\">return!</span> <span class=\"id\">Successful</span><span class=\"pn\">.</span><span class=\"id\">ok</span> <span class=\"pn\">(</span><span class=\"id\">text</span> <span class=\"s\">&quot;Pinged the clients&quot;</span><span class=\"pn\">)</span> <span class=\"id\">next</span> <span class=\"id\">ctx</span>\r\n   <span class=\"pn\">}</span><span class=\"pn\">)</span>\r\n  <span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs8', 8)\" onmouseover=\"showTip(event, 'fs8', 8)\" class=\"id\">sampleChannel</span> <span class=\"o\">=</span> <span class=\"id\">channel</span> <span class=\"pn\">{</span>\r\n  <span class=\"id\">join</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"id\">si</span> <span class=\"k\">-&gt;</span> <span class=\"id\">task</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">ctx</span><span class=\"pn\">.</span><span class=\"id\">GetLogger</span><span class=\"pn\">(</span><span class=\"pn\">)</span><span class=\"pn\">.</span><span class=\"id\">LogInformation</span><span class=\"pn\">(</span><span class=\"s\">&quot;Connected! Socket Id: &quot;</span> <span class=\"o\">+</span> <span class=\"id\">si</span><span class=\"pn\">.</span><span class=\"id\">SocketId</span><span class=\"pn\">.</span><span class=\"id\">ToString</span><span class=\"pn\">(</span><span class=\"pn\">)</span><span class=\"pn\">)</span>\r\n    <span class=\"k\">return</span> <span onmouseout=\"hideTip(event, 'fs9', 9)\" onmouseover=\"showTip(event, 'fs9', 9)\" class=\"id\">Ok</span>\r\n  <span class=\"pn\">}</span><span class=\"pn\">)</span>\r\n\r\n  <span class=\"id\">handle</span> <span class=\"s\">&quot;topic&quot;</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"id\">si</span> <span class=\"id\">msg</span> <span class=\"k\">-&gt;</span>\r\n    <span class=\"id\">task</span> <span class=\"pn\">{</span>\r\n       <span class=\"k\">let</span> <span class=\"id\">logger</span> <span class=\"o\">=</span> <span class=\"id\">ctx</span><span class=\"pn\">.</span><span class=\"id\">GetLogger</span><span class=\"pn\">(</span><span class=\"pn\">)</span>\r\n       <span class=\"id\">logger</span><span class=\"pn\">.</span><span class=\"id\">LogInformation</span><span class=\"pn\">(</span><span class=\"s\">&quot;got message {message} from client with Socket Id: {socketId}&quot;</span><span class=\"pn\">,</span> <span class=\"id\">msg</span><span class=\"pn\">,</span> <span class=\"id\">si</span><span class=\"pn\">.</span><span class=\"id\">SocketId</span><span class=\"pn\">)</span>\r\n       <span class=\"k\">return</span> <span class=\"pn\">(</span><span class=\"pn\">)</span>\r\n  <span class=\"pn\">}</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs10', 10)\" onmouseover=\"showTip(event, 'fs10', 10)\" class=\"id\">app</span> <span class=\"o\">=</span> <span class=\"id\">application</span> <span class=\"pn\">{</span>\r\n  <span class=\"id\">use_router</span> <span onmouseout=\"hideTip(event, 'fs1', 11)\" onmouseover=\"showTip(event, 'fs1', 11)\" class=\"id\">browserRouter</span>\r\n  <span class=\"id\">url</span> <span class=\"s\">&quot;http://localhost:8085/&quot;</span>\r\n  <span class=\"id\">add_channel</span> <span class=\"s\">&quot;/channel&quot;</span> <span onmouseout=\"hideTip(event, 'fs8', 12)\" onmouseover=\"showTip(event, 'fs8', 12)\" class=\"id\">sampleChannel</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val browserRouter : obj</div>\r\n<div class=\"tip\" id=\"fs2\">namespace Saturn</div>\r\n<div class=\"tip\" id=\"fs3\">module Channels<br /><br />from Saturn</div>\r\n<div class=\"tip\" id=\"fs4\">type ISocketHub =<br />&#160;&#160;interface<br />&#160;&#160;&#160;&#160;abstract member SendMessageToClient : ChannelPath -&gt; SocketId -&gt; Topic -&gt; &#39;a -&gt; Task&lt;unit&gt;<br />&#160;&#160;&#160;&#160;abstract member SendMessageToClients : ChannelPath -&gt; Topic -&gt; &#39;a -&gt; Task&lt;unit&gt;<br />&#160;&#160;end</div>\r\n<div class=\"tip\" id=\"fs5\">union case Option.None: Option&lt;&#39;T&gt;</div>\r\n<div class=\"tip\" id=\"fs6\">union case Option.Some: Value: &#39;T -&gt; Option&lt;&#39;T&gt;</div>\r\n<div class=\"tip\" id=\"fs7\">val sprintf : format:Printf.StringFormat&lt;&#39;T&gt; -&gt; &#39;T</div>\r\n<div class=\"tip\" id=\"fs8\">val sampleChannel : obj</div>\r\n<div class=\"tip\" id=\"fs9\">union case Result.Ok: ResultValue: &#39;T -&gt; Result&lt;&#39;T,&#39;TError&gt;</div>\r\n<div class=\"tip\" id=\"fs10\">val app : obj</div>\r\n\r\n ChannelBuilderState <p>Type representing internal state of the <code>channel</code> computation expression</p>\r\n\r\n \n channel <p>Computation expression used to create channels</p>\r\n\r\n \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channels.html","title":"Channels","content":"Channels \n  \n  \n ChannelPath <p>Url (relative to root application url) on which channel is hosted. Type alias for <code>string</code></p>\r\n\r\n ClientInfo <p>Type representing information about client that has executed some channel action\r\nIt's passed as an argument in channel actions (<code>join</code>, <code>handle</code>, <code>terminate</code>)</p>\r\n\r\n IChannel <p>Interface of the internal representation of the channel.\r\nShouldn't be used manually, you get its instance from the <code>channel</code> Computation Expression</p>\r\n\r\n ISocketHub <p>Interface representing server side Socket Hub, giving you ability to brodcast messages (either to particular socket or to all sockets).\r\nYou can get instance of it with <code>ctx.GetService&amp;lt;Saturn.Channels.ISocketHub&gt;()</code> from any place that has access to HttpContext instance (<code>controller</code> actions, <code>channel</code> actions, normal <code>HttpHandler</code>)</p>\r\n\r\n JoinResult <p>Type representing result of <code>join</code> action. It can be either succesful (<code>Ok</code>) or you can reject client connection (<code>Rejected</code>)</p>\r\n\r\n Message<'a> <p>Types representing channels message.\r\nIt always includes topic, reference id of the message (random GUID), and payload object.</p>\r\n\r\n SocketHub <p>A type that wraps access to connected websockets by endpoint</p>\r\n\r\n SocketId <p>Socket Id. Type alias for <code>Guid</code></p>\r\n\r\n SocketMiddleware  Topic <p>Topic of the channel. Type alias for <code>string</code></p>\r\n\r\n \n  \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-common.html","title":"Common","content":"Common \n <p>Module with some helper functions used in Saturn, mostly for internal usage</p>\r\n\r\n \n  \n InclusiveOption<'T>  \n  \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-controller.html","title":"Controller","content":"Controller \n <p>Module with <code>controller</code> computation expression</p>\r\n\r\n \n  \n Action <p>Type used for <code>plug</code> operation, allowing you to choose for which actions given plug should work</p>\r\n\r\n ControllerBuilder<'Key, 'IndexOutput, 'ShowOutput, 'AddOutput, 'EditOutput, 'CreateOutput, 'UpdateOutput, 'PatchOutput, 'DeleteOutput, 'DeleteAllOutput> <p>Computation expression used to create Saturn controllers - abstraction representing REST-ish endpoint for serving HTML views or returning data. It supports:</p>\r\n<ul>\r\n<li>a set of predefined actions that are automatically mapped to the endpoints following standard conventions</li>\r\n<li>embedding sub-controllers for modeling one-to-many relationships</li>\r\n<li>versioning</li>\r\n<li>adding plugs for a particular action which in principle provides the same mechanism as attributes in ASP.NET MVC applications</li>\r\n<li>defining a common error handler for all actions</li>\r\n<li>defining a not-found action</li>\r\n</ul>\r\n<p>The result of the computation expression is a standard Giraffe <code>HttpHandler</code>, which means that it's easily composable with other parts of the ecosytem.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\"> 1: </span>\r\n<span class=\"l\"> 2: </span>\r\n<span class=\"l\"> 3: </span>\r\n<span class=\"l\"> 4: </span>\r\n<span class=\"l\"> 5: </span>\r\n<span class=\"l\"> 6: </span>\r\n<span class=\"l\"> 7: </span>\r\n<span class=\"l\"> 8: </span>\r\n<span class=\"l\"> 9: </span>\r\n<span class=\"l\">10: </span>\r\n<span class=\"l\">11: </span>\r\n<span class=\"l\">12: </span>\r\n<span class=\"l\">13: </span>\r\n<span class=\"l\">14: </span>\r\n<span class=\"l\">15: </span>\r\n<span class=\"l\">16: </span>\r\n<span class=\"l\">17: </span>\r\n<span class=\"l\">18: </span>\r\n<span class=\"l\">19: </span>\r\n<span class=\"l\">20: </span>\r\n<span class=\"l\">21: </span>\r\n<span class=\"l\">22: </span>\r\n<span class=\"l\">23: </span>\r\n<span class=\"l\">24: </span>\r\n<span class=\"l\">25: </span>\r\n<span class=\"l\">26: </span>\r\n<span class=\"l\">27: </span>\r\n<span class=\"l\">28: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"fn\">commentController</span> <span onmouseout=\"hideTip(event, 'fs2', 2)\" onmouseover=\"showTip(event, 'fs2', 2)\" class=\"id\">userId</span> <span class=\"o\">=</span> <span class=\"id\">controller</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">index</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 3)\" onmouseover=\"showTip(event, 'fs3', 3)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Comment Index handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs2', 4)\" onmouseover=\"showTip(event, 'fs2', 4)\" class=\"id\">userId</span> <span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">add</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 5)\" onmouseover=\"showTip(event, 'fs3', 5)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Comment Add handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs2', 6)\" onmouseover=\"showTip(event, 'fs2', 6)\" class=\"id\">userId</span> <span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">show</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 7)\" onmouseover=\"showTip(event, 'fs4', 7)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 8)\" onmouseover=\"showTip(event, 'fs3', 8)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Show comment %s handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 9)\" onmouseover=\"showTip(event, 'fs4', 9)\" class=\"id\">id</span> <span onmouseout=\"hideTip(event, 'fs2', 10)\" onmouseover=\"showTip(event, 'fs2', 10)\" class=\"id\">userId</span> <span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">edit</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 11)\" onmouseover=\"showTip(event, 'fs4', 11)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 12)\" onmouseover=\"showTip(event, 'fs3', 12)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Edit comment %s handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 13)\" onmouseover=\"showTip(event, 'fs4', 13)\" class=\"id\">id</span> <span onmouseout=\"hideTip(event, 'fs2', 14)\" onmouseover=\"showTip(event, 'fs2', 14)\" class=\"id\">userId</span> <span class=\"pn\">)</span>  <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs5', 15)\" onmouseover=\"showTip(event, 'fs5', 15)\" class=\"id\">userControllerVersion1</span> <span class=\"o\">=</span> <span class=\"id\">controller</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">version</span> <span class=\"n\">1</span>\r\n    <span class=\"id\">subController</span> <span class=\"s\">&quot;/comments&quot;</span> <span onmouseout=\"hideTip(event, 'fs1', 16)\" onmouseover=\"showTip(event, 'fs1', 16)\" class=\"id\">commentController</span>\r\n\r\n    <span class=\"id\">index</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Index handler version 1&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">add</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Add handler version 1&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">show</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 17)\" onmouseover=\"showTip(event, 'fs4', 17)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 18)\" onmouseover=\"showTip(event, 'fs3', 18)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Show handler version 1 - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 19)\" onmouseover=\"showTip(event, 'fs4', 19)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">edit</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 20)\" onmouseover=\"showTip(event, 'fs4', 20)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 21)\" onmouseover=\"showTip(event, 'fs3', 21)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Edit handler version 1 - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 22)\" onmouseover=\"showTip(event, 'fs4', 22)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs6', 23)\" onmouseover=\"showTip(event, 'fs6', 23)\" class=\"id\">userController</span> <span class=\"o\">=</span> <span class=\"id\">controller</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">subController</span> <span class=\"s\">&quot;/comments&quot;</span> <span onmouseout=\"hideTip(event, 'fs1', 24)\" onmouseover=\"showTip(event, 'fs1', 24)\" class=\"id\">commentController</span>\r\n\r\n    <span class=\"id\">plug</span> <span class=\"pn\">[</span><span class=\"id\">All</span><span class=\"pn\">]</span> <span class=\"pn\">(</span><span class=\"id\">setHttpHeader</span> <span class=\"s\">&quot;user-controller-common&quot;</span> <span class=\"s\">&quot;123&quot;</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">plug</span> <span class=\"pn\">[</span><span class=\"id\">Index</span><span class=\"pn\">;</span> <span class=\"id\">Show</span><span class=\"pn\">]</span> <span class=\"pn\">(</span><span class=\"id\">setHttpHeader</span> <span class=\"s\">&quot;user-controller-specialized&quot;</span> <span class=\"s\">&quot;123&quot;</span><span class=\"pn\">)</span>\r\n\r\n    <span class=\"id\">index</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Index handler no version&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">add</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Add handler no version&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">show</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 25)\" onmouseover=\"showTip(event, 'fs4', 25)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 26)\" onmouseover=\"showTip(event, 'fs3', 26)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Show handler no version - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 27)\" onmouseover=\"showTip(event, 'fs4', 27)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">edit</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 28)\" onmouseover=\"showTip(event, 'fs4', 28)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 29)\" onmouseover=\"showTip(event, 'fs3', 29)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Edit handler no version - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 30)\" onmouseover=\"showTip(event, 'fs4', 30)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val commentController : userId:&#39;a -&gt; &#39;b</div>\r\n<div class=\"tip\" id=\"fs2\">val userId : &#39;a</div>\r\n<div class=\"tip\" id=\"fs3\">val sprintf : format:Printf.StringFormat&lt;&#39;T&gt; -&gt; &#39;T</div>\r\n<div class=\"tip\" id=\"fs4\">val id : x:&#39;T -&gt; &#39;T</div>\r\n<div class=\"tip\" id=\"fs5\">val userControllerVersion1 : obj</div>\r\n<div class=\"tip\" id=\"fs6\">val userController : obj</div>\r\n\r\n ControllerState<'Key, 'IndexOutput, 'ShowOutput, 'AddOutput, 'EditOutput, 'CreateOutput, 'UpdateOutput, 'PatchOutput, 'DeleteOutput, 'DeleteAllOutput> <p>Type representing internal state of the <code>controller</code> computation expression</p>\r\n\r\n \n except <p>Returns list of all actions except given actions.</p>\r\n\r\n response  controller <p>Computation expression used to create controllers</p>\r\n\r\n \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-controllerhelpers.html","title":"ControllerHelpers","content":"ControllerHelpers \n <p>Module containing helpers for <code>controller</code> actions</p>\r\n\r\n \n Controller <p>Module containing helpers for <code>controller</code> actions</p>\r\n\r\n Response <p>This module wraps Giraffe responses (ie setting HTTP status codes) for easy chaining in the Saturn model.\r\nAll of the functions set the status code and halt further processing.</p>\r\n\r\n \n  \n  \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-controllerhelpers-controller.html","title":"Controller","content":"Controller \n <p>Module containing helpers for <code>controller</code> actions</p>\r\n\r\n \n  \n  \n json <p>Returns to the client content serialized to JSON.</p>\r\n\r\n jsonCustom <p>Returns to the client content serialized to JSON. Accepts custom serialization settings</p>\r\n\r\n xml <p>Returns to the client content serialized to XML.</p>\r\n\r\n text <p>Returns to the client content as string.</p>\r\n\r\n html <p>Returns the string template as html to the client.</p>\r\n\r\n renderHtml <p>Returns to the client rendered html template.</p>\r\n\r\n file <p>Returns to the client static file.</p>\r\n\r\n response <p>Returns to the client response according to accepted content type (<code>Accept</code> header, and if it's not present <code>Content-Type</code> header)</p>\r\n\r\n getJson <p>Gets model from body as JSON.</p>\r\n\r\n getXml <p>Gets model from body as XML.</p>\r\n\r\n getForm <p>Gets model from urelencoded body.</p>\r\n\r\n getFormCulture <p>Gets model from urelencoded body. Accepts culture name</p>\r\n\r\n getQuery <p>Gets model from query string.</p>\r\n\r\n getQueryCulture <p>Gets model from query string. Accepts culture name</p>\r\n\r\n getModel <p>Get model based on <code>HttpMethod</code> and <code>Content-Type</code> of request.</p>\r\n\r\n getModelCustom <p>Get model based on <code>HttpMethod</code> and <code>Content-Type</code> of request. Accepts custom culture.</p>\r\n\r\n loadModel <p>Loads model populated by <code>fetchModel</code> pipeline</p>\r\n\r\n getPath <p>Gets path of the request - it's relative to current <code>scope</code></p>\r\n\r\n getUrl <p>Gets url of the request</p>\r\n\r\n getConfig <p>Gets the contents of the <code>Configuration</code> key in the HttpContext dictionary, unboxed as the given type.</p>\r\n\r\n sendDownload <p>Sends the contents of a file as the body of the response. Does not set a Content-Type.</p>\r\n\r\n sendDownloadBinary <p>Send bytes as the body of the response. Does not set a Content-Type.</p>\r\n\r\n redirect <p>Perform a temporary redirect to the provided location.</p>\r\n\r\n \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-controllerhelpers-response.html","title":"Response","content":"Response \n <p>This module wraps Giraffe responses (ie setting HTTP status codes) for easy chaining in the Saturn model.\r\nAll of the functions set the status code and halt further processing.</p>\r\n\r\n \n  \n  \n continue  switchingProto  ok  created  accepted  badRequest  unauthorized  forbidden  notFound  methodNotAllowed  notAcceptable  conflict  gone  unuspportedMediaType  unprocessableEntity  preconditionRequired  tooManyRequests  internalError  notImplemented  badGateway  serviceUnavailable  gatewayTimeout  \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-links.html","title":"Links","content":"Links \n <p>Convention-based links to other actions to perform on the current request model.</p>\r\n\r\n \n  \n  \n index <p>Returns a link to the <code>index</code> action for the current model.</p>\r\n\r\n add <p>Returns a link to the <code>add</code> action for the current model.</p>\r\n\r\n withId <p>Returns a link to the <code>withId</code> action for a particular resource of the same type as the current request.</p>\r\n\r\n edit <p>Returns a link to the <code>edit</code> action for a particular resource of the same type as the current request.</p>\r\n\r\n \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-oauth.html","title":"OAuth","content":"OAuth \n <p>Module containing types to be use with <code>use_oauth_with_settings</code></p>\r\n\r\n \n  \n OAuthSettings <p>Record type representing simple OAuth configuration to be used with <code>use_oauth_with_settings</code>.</p>\r\n\r\n \n  \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-pipeline.html","title":"Pipeline","content":"Pipeline \n <p>Module containing <code>pipeline</code> computation expression</p>\r\n\r\n \n  \n PipelineBuilder <p>Computation expression used to combine <code>HttpHandlers</code> in a declarative manner.</p>\r\n<p>The result of the computation expression is a standard Giraffe <code>HttpHandler</code> which means that it's easily composable with other parts of the Giraffe ecosystem.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\"> 1: </span>\r\n<span class=\"l\"> 2: </span>\r\n<span class=\"l\"> 3: </span>\r\n<span class=\"l\"> 4: </span>\r\n<span class=\"l\"> 5: </span>\r\n<span class=\"l\"> 6: </span>\r\n<span class=\"l\"> 7: </span>\r\n<span class=\"l\"> 8: </span>\r\n<span class=\"l\"> 9: </span>\r\n<span class=\"l\">10: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"id\">headerPipe</span> <span class=\"o\">=</span> <span class=\"id\">pipeline</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">set_header</span> <span class=\"s\">&quot;myCustomHeader&quot;</span> <span class=\"s\">&quot;abcd&quot;</span>\r\n    <span class=\"id\">set_header</span> <span class=\"s\">&quot;myCustomHeader2&quot;</span> <span class=\"s\">&quot;zxcv&quot;</span>\r\n<span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs2', 2)\" onmouseover=\"showTip(event, 'fs2', 2)\" class=\"id\">endpointPipe</span> <span class=\"o\">=</span> <span class=\"id\">pipeline</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">plug</span> <span class=\"id\">fetchSession</span>\r\n    <span class=\"id\">plug</span> <span class=\"id\">head</span>\r\n    <span class=\"id\">plug</span> <span class=\"id\">requestId</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val headerPipe : obj</div>\r\n<div class=\"tip\" id=\"fs2\">val endpointPipe : obj</div>\r\n\r\n \n pipeline <p><code>pipeline</code> computation expression is a way to create <code>HttpHandler</code> using composition of low-level helper functions.</p>\r\n\r\n \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-pipelinehelpers.html","title":"PipelineHelpers","content":"PipelineHelpers \n <p>Module containing helper functions that can be used with <code>pipeline</code> computation expression</p>\r\n\r\n \n  \n  \n acceptJson <p>Accepts <code>application/json</code></p>\r\n\r\n acceptXml <p>Accepts <code>application/xml</code></p>\r\n\r\n acceptHtml <p>Accepts <code>text/html</code></p>\r\n\r\n acceptMultipart <p>Accepts <code>multipart/form-data</code></p>\r\n\r\n putSecureBrowserHeaders <p>Put headers that improve browser security.\r\nIt sets the following headers:\r\n<em> x-frame-options - set to SAMEORIGIN to avoid clickjacking through iframes unless in the same origin\r\n</em> x-content-type-options - set to nosniff. This requires script and style tags to be sent with proper content type\r\n<em> x-xss-protection - set to \"1; mode=block\" to improve XSS protection on both Chrome and IE\r\n</em> x-download-options - set to noopen to instruct the browser not to open a download directly in the browser, to avoid HTML files rendering inline and accessing the security context of the application (like critical domain cookies)\r\n* x-permitted-cross-domain-policies - set to none to restrict Adobe Flash Player’s access to data</p>\r\n\r\n protectFromForgery <p>Enables CSRF protection using the (required) <code>Antiforgery</code> feature.\r\nThis feature can be set up via the <code>use_antiforgery</code> or <code>use_antiforgery_with_config</code> operations on the <code>application</code> builder.\r\nThis feature <em>requires</em> that one of those be used (or some other mechanism of initializing the Antiforgery/Data Protection subsystems has been performed out-of-band)</p>\r\n\r\n enableCors <p>Enables CORS pretection using provided config. Use <code>CORS.defaultCORSConfig</code> for default configuration.</p>\r\n\r\n fetchSession <p>Fetches session from session provider. If it won't be called session will be synchronusly fetched on first usage.</p>\r\n\r\n fetchModel <p>Tries to model from request and puts model into <code>Items.RequestModel</code>. If it won't be called content can be fetched using <code>Context.Controller</code> helpers.\r\nIt optionally takes custom culture name as arguments.</p>\r\n\r\n head <p>Convert <code>HEAD</code> requests to <code>GET</code> requests.</p>\r\n\r\n requestId <p>Pipeline for generating a unique request id for each request. A generated request id will in the format <code>uq8hs30oafhj5vve8ji5pmp7mtopc08f</code>.\r\nIf a request id already exists as the <code>x-request-id</code> HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request id will be generated.\r\nRequest id is put into <code>x-request-id</code> HTTP header and into <code>Items</code> directory of HttpContext with <code>RequestId</code> key.</p>\r\n\r\n requireHeader <p>Requires given value for given request header</p>\r\n\r\n \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-router.html","title":"Router","content":"Router \n <p>Module containing <code>pipeline</code> computation expression</p>\r\n\r\n \n  \n RouteType <p>Type representing route type, used in internal state of the <code>application</code> computation expression</p>\r\n\r\n RouterBuilder <p>Computation expression used to create routing, combining <code>HttpHandlers</code>, <code>pipelines</code> and <code>controllers</code> together.</p>\r\n<p>The result of the computation expression is a standard Giraffe <code>HttpHandler</code>, which means that it's easily composable with other parts of the ecosytem.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\"> 1: </span>\r\n<span class=\"l\"> 2: </span>\r\n<span class=\"l\"> 3: </span>\r\n<span class=\"l\"> 4: </span>\r\n<span class=\"l\"> 5: </span>\r\n<span class=\"l\"> 6: </span>\r\n<span class=\"l\"> 7: </span>\r\n<span class=\"l\"> 8: </span>\r\n<span class=\"l\"> 9: </span>\r\n<span class=\"l\">10: </span>\r\n<span class=\"l\">11: </span>\r\n<span class=\"l\">12: </span>\r\n<span class=\"l\">13: </span>\r\n<span class=\"l\">14: </span>\r\n<span class=\"l\">15: </span>\r\n<span class=\"l\">16: </span>\r\n<span class=\"l\">17: </span>\r\n<span class=\"l\">18: </span>\r\n<span class=\"l\">19: </span>\r\n<span class=\"l\">20: </span>\r\n<span class=\"l\">21: </span>\r\n<span class=\"l\">22: </span>\r\n<span class=\"l\">23: </span>\r\n<span class=\"l\">24: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"id\">topRouter</span> <span class=\"o\">=</span> <span class=\"id\">router</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">pipe_through</span> <span class=\"id\">headerPipe</span>\r\n    <span class=\"id\">not_found_handler</span> <span class=\"pn\">(</span><span class=\"id\">text</span> <span class=\"s\">&quot;404&quot;</span><span class=\"pn\">)</span>\r\n\r\n    <span class=\"id\">get</span> <span class=\"s\">&quot;/&quot;</span> <span class=\"id\">helloWorld</span>\r\n    <span class=\"id\">get</span> <span class=\"s\">&quot;/a&quot;</span> <span class=\"id\">helloWorld2</span>\r\n    <span class=\"id\">getf</span> <span class=\"s\">&quot;/name/%s&quot;</span> <span class=\"id\">helloWorldName</span>\r\n    <span class=\"id\">getf</span> <span class=\"s\">&quot;/name/%s/%i&quot;</span> <span class=\"id\">helloWorldNameAge</span>\r\n\r\n    <span class=\"c\">//routers can be defined inline to simulate `subRoute` combinator</span>\r\n    <span class=\"id\">forward</span> <span class=\"s\">&quot;/other&quot;</span> <span class=\"pn\">(</span><span class=\"id\">router</span> <span class=\"pn\">{</span>\r\n        <span class=\"id\">pipe_through</span> <span class=\"id\">otherHeaderPipe</span>\r\n        <span class=\"id\">not_found_handler</span> <span class=\"pn\">(</span><span class=\"id\">text</span> <span class=\"s\">&quot;Other 404&quot;</span><span class=\"pn\">)</span>\r\n\r\n        <span class=\"id\">get</span> <span class=\"s\">&quot;/&quot;</span> <span class=\"id\">otherHelloWorld</span>\r\n        <span class=\"id\">get</span> <span class=\"s\">&quot;/a&quot;</span> <span class=\"id\">otherHelloWorld2</span>\r\n    <span class=\"pn\">}</span><span class=\"pn\">)</span>\r\n\r\n    <span class=\"c\">// or can be defined separatly and used as HttpHandler</span>\r\n    <span class=\"id\">forward</span> <span class=\"s\">&quot;/api&quot;</span> <span class=\"id\">apiRouter</span>\r\n\r\n    <span class=\"c\">// same with controllers</span>\r\n    <span class=\"id\">forward</span> <span class=\"s\">&quot;/users&quot;</span> <span class=\"id\">userController</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val topRouter : obj</div>\r\n\r\n RouterState <p>Type representing internal state of the <code>router</code> computation expression</p>\r\n\r\n \n router <p>Computation expression used to create routing in Saturn application</p>\r\n\r\n \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-sitemap.html","title":"SiteMap","content":"SiteMap \n  \n  \n HandlerMap  PathEntry  \n getPaths  page  \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-utils.html","title":"Utils","content":"Utils \n  \n String  \n  \n  \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-utils-string.html","title":"String","content":"String \n  \n  \n  \n  \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-endpoint-controller.html","title":"Controller","content":"Controller \n <p>Module with <code>controller</code> computation expression</p>\r\n\r\n \n  \n Action <p>Type used for <code>plug</code> operation, allowing you to choose for which actions given plug should work</p>\r\n\r\n ControllerBuilder<'Key, 'IndexOutput, 'ShowOutput, 'AddOutput, 'EditOutput, 'CreateOutput, 'UpdateOutput, 'PatchOutput, 'DeleteOutput, 'DeleteAllOutput> <p>Computation expression used to create Saturn controllers - abstraction representing REST-ish endpoint for serving HTML views or returning data. It supports:</p>\r\n<ul>\r\n<li>a set of predefined actions that are automatically mapped to the endpoints following standard conventions</li>\r\n<li>embedding sub-controllers for modeling one-to-many relationships</li>\r\n<li>versioning</li>\r\n<li>adding plugs for a particular action which in principle provides the same mechanism as attributes in ASP.NET MVC applications</li>\r\n<li>defining a common error handler for all actions</li>\r\n<li>defining a not-found action</li>\r\n</ul>\r\n<p>The result of the computation expression is a standard Giraffe <code>HttpHandler</code>, which means that it's easily composable with other parts of the ecosytem.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\"> 1: </span>\r\n<span class=\"l\"> 2: </span>\r\n<span class=\"l\"> 3: </span>\r\n<span class=\"l\"> 4: </span>\r\n<span class=\"l\"> 5: </span>\r\n<span class=\"l\"> 6: </span>\r\n<span class=\"l\"> 7: </span>\r\n<span class=\"l\"> 8: </span>\r\n<span class=\"l\"> 9: </span>\r\n<span class=\"l\">10: </span>\r\n<span class=\"l\">11: </span>\r\n<span class=\"l\">12: </span>\r\n<span class=\"l\">13: </span>\r\n<span class=\"l\">14: </span>\r\n<span class=\"l\">15: </span>\r\n<span class=\"l\">16: </span>\r\n<span class=\"l\">17: </span>\r\n<span class=\"l\">18: </span>\r\n<span class=\"l\">19: </span>\r\n<span class=\"l\">20: </span>\r\n<span class=\"l\">21: </span>\r\n<span class=\"l\">22: </span>\r\n<span class=\"l\">23: </span>\r\n<span class=\"l\">24: </span>\r\n<span class=\"l\">25: </span>\r\n<span class=\"l\">26: </span>\r\n<span class=\"l\">27: </span>\r\n<span class=\"l\">28: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"fn\">commentController</span> <span onmouseout=\"hideTip(event, 'fs2', 2)\" onmouseover=\"showTip(event, 'fs2', 2)\" class=\"id\">userId</span> <span class=\"o\">=</span> <span class=\"id\">subcontroller</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">index</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 3)\" onmouseover=\"showTip(event, 'fs3', 3)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Comment Index handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs2', 4)\" onmouseover=\"showTip(event, 'fs2', 4)\" class=\"id\">userId</span> <span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">add</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 5)\" onmouseover=\"showTip(event, 'fs3', 5)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Comment Add handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs2', 6)\" onmouseover=\"showTip(event, 'fs2', 6)\" class=\"id\">userId</span> <span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">show</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 7)\" onmouseover=\"showTip(event, 'fs4', 7)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 8)\" onmouseover=\"showTip(event, 'fs3', 8)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Show comment %s handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 9)\" onmouseover=\"showTip(event, 'fs4', 9)\" class=\"id\">id</span> <span onmouseout=\"hideTip(event, 'fs2', 10)\" onmouseover=\"showTip(event, 'fs2', 10)\" class=\"id\">userId</span> <span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">edit</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 11)\" onmouseover=\"showTip(event, 'fs4', 11)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 12)\" onmouseover=\"showTip(event, 'fs3', 12)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Edit comment %s handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 13)\" onmouseover=\"showTip(event, 'fs4', 13)\" class=\"id\">id</span> <span onmouseout=\"hideTip(event, 'fs2', 14)\" onmouseover=\"showTip(event, 'fs2', 14)\" class=\"id\">userId</span> <span class=\"pn\">)</span>  <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs5', 15)\" onmouseover=\"showTip(event, 'fs5', 15)\" class=\"id\">userControllerVersion1</span> <span class=\"o\">=</span> <span class=\"id\">controller</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">version</span> <span class=\"n\">1</span>\r\n    <span class=\"id\">subController</span> <span class=\"s\">&quot;/comments&quot;</span> <span onmouseout=\"hideTip(event, 'fs1', 16)\" onmouseover=\"showTip(event, 'fs1', 16)\" class=\"id\">commentController</span>\r\n\r\n    <span class=\"id\">index</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Index handler version 1&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">add</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Add handler version 1&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">show</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 17)\" onmouseover=\"showTip(event, 'fs4', 17)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 18)\" onmouseover=\"showTip(event, 'fs3', 18)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Show handler version 1 - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 19)\" onmouseover=\"showTip(event, 'fs4', 19)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">edit</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 20)\" onmouseover=\"showTip(event, 'fs4', 20)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 21)\" onmouseover=\"showTip(event, 'fs3', 21)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Edit handler version 1 - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 22)\" onmouseover=\"showTip(event, 'fs4', 22)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs6', 23)\" onmouseover=\"showTip(event, 'fs6', 23)\" class=\"id\">userController</span> <span class=\"o\">=</span> <span class=\"id\">controller</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">subController</span> <span class=\"s\">&quot;/comments&quot;</span> <span onmouseout=\"hideTip(event, 'fs1', 24)\" onmouseover=\"showTip(event, 'fs1', 24)\" class=\"id\">commentController</span>\r\n\r\n    <span class=\"id\">plug</span> <span class=\"pn\">[</span><span class=\"id\">All</span><span class=\"pn\">]</span> <span class=\"pn\">(</span><span class=\"id\">setHttpHeader</span> <span class=\"s\">&quot;user-controller-common&quot;</span> <span class=\"s\">&quot;123&quot;</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">plug</span> <span class=\"pn\">[</span><span class=\"id\">Index</span><span class=\"pn\">;</span> <span class=\"id\">Show</span><span class=\"pn\">]</span> <span class=\"pn\">(</span><span class=\"id\">setHttpHeader</span> <span class=\"s\">&quot;user-controller-specialized&quot;</span> <span class=\"s\">&quot;123&quot;</span><span class=\"pn\">)</span>\r\n\r\n    <span class=\"id\">index</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Index handler no version&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">add</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Add handler no version&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">show</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 25)\" onmouseover=\"showTip(event, 'fs4', 25)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 26)\" onmouseover=\"showTip(event, 'fs3', 26)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Show handler no version - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 27)\" onmouseover=\"showTip(event, 'fs4', 27)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">edit</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 28)\" onmouseover=\"showTip(event, 'fs4', 28)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 29)\" onmouseover=\"showTip(event, 'fs3', 29)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Edit handler no version - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 30)\" onmouseover=\"showTip(event, 'fs4', 30)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val commentController : userId:&#39;a -&gt; &#39;b</div>\r\n<div class=\"tip\" id=\"fs2\">val userId : &#39;a</div>\r\n<div class=\"tip\" id=\"fs3\">val sprintf : format:Printf.StringFormat&lt;&#39;T&gt; -&gt; &#39;T</div>\r\n<div class=\"tip\" id=\"fs4\">val id : x:&#39;T -&gt; &#39;T</div>\r\n<div class=\"tip\" id=\"fs5\">val userControllerVersion1 : obj</div>\r\n<div class=\"tip\" id=\"fs6\">val userController : obj</div>\r\n\r\n ControllerState<'Key, 'IndexOutput, 'ShowOutput, 'AddOutput, 'EditOutput, 'CreateOutput, 'UpdateOutput, 'PatchOutput, 'DeleteOutput, 'DeleteAllOutput> <p>Type representing internal state of the <code>controller</code> computation expression</p>\r\n\r\n \n except <p>Returns list of all actions except given actions.</p>\r\n\r\n response  controller <p>Computation expression used to create controllers</p>\r\n\r\n subcontroller <p>Computation expression used to create HttpHandlers representing subcontrollers.</p>\r\n\r\n \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-endpoint-router.html","title":"Router","content":"Router \n <p>Module containing <code>pipeline</code> computation expression</p>\r\n\r\n \n  \n RouteType <p>Type representing route type, used in internal state of the <code>application</code> computation expression</p>\r\n\r\n RouterBuilder <p>Computation expression used to create routing, combining <code>HttpHandlers</code>, <code>pipelines</code> and <code>controllers</code> together.</p>\r\n<p>The result of the computation expression is a standard Giraffe <code>HttpHandler</code>, which means that it's easily composable with other parts of the ecosytem.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\"> 1: </span>\r\n<span class=\"l\"> 2: </span>\r\n<span class=\"l\"> 3: </span>\r\n<span class=\"l\"> 4: </span>\r\n<span class=\"l\"> 5: </span>\r\n<span class=\"l\"> 6: </span>\r\n<span class=\"l\"> 7: </span>\r\n<span class=\"l\"> 8: </span>\r\n<span class=\"l\"> 9: </span>\r\n<span class=\"l\">10: </span>\r\n<span class=\"l\">11: </span>\r\n<span class=\"l\">12: </span>\r\n<span class=\"l\">13: </span>\r\n<span class=\"l\">14: </span>\r\n<span class=\"l\">15: </span>\r\n<span class=\"l\">16: </span>\r\n<span class=\"l\">17: </span>\r\n<span class=\"l\">18: </span>\r\n<span class=\"l\">19: </span>\r\n<span class=\"l\">20: </span>\r\n<span class=\"l\">21: </span>\r\n<span class=\"l\">22: </span>\r\n<span class=\"l\">23: </span>\r\n<span class=\"l\">24: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"id\">topRouter</span> <span class=\"o\">=</span> <span class=\"id\">router</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">pipe_through</span> <span class=\"id\">headerPipe</span>\r\n    <span class=\"id\">not_found_handler</span> <span class=\"pn\">(</span><span class=\"id\">text</span> <span class=\"s\">&quot;404&quot;</span><span class=\"pn\">)</span>\r\n\r\n    <span class=\"id\">get</span> <span class=\"s\">&quot;/&quot;</span> <span class=\"id\">helloWorld</span>\r\n    <span class=\"id\">get</span> <span class=\"s\">&quot;/a&quot;</span> <span class=\"id\">helloWorld2</span>\r\n    <span class=\"id\">getf</span> <span class=\"s\">&quot;/name/%s&quot;</span> <span class=\"id\">helloWorldName</span>\r\n    <span class=\"id\">getf</span> <span class=\"s\">&quot;/name/%s/%i&quot;</span> <span class=\"id\">helloWorldNameAge</span>\r\n\r\n    <span class=\"c\">//routers can be defined inline to simulate `subRoute` combinator</span>\r\n    <span class=\"id\">forward</span> <span class=\"s\">&quot;/other&quot;</span> <span class=\"pn\">(</span><span class=\"id\">router</span> <span class=\"pn\">{</span>\r\n        <span class=\"id\">pipe_through</span> <span class=\"id\">otherHeaderPipe</span>\r\n        <span class=\"id\">not_found_handler</span> <span class=\"pn\">(</span><span class=\"id\">text</span> <span class=\"s\">&quot;Other 404&quot;</span><span class=\"pn\">)</span>\r\n\r\n        <span class=\"id\">get</span> <span class=\"s\">&quot;/&quot;</span> <span class=\"id\">otherHelloWorld</span>\r\n        <span class=\"id\">get</span> <span class=\"s\">&quot;/a&quot;</span> <span class=\"id\">otherHelloWorld2</span>\r\n    <span class=\"pn\">}</span><span class=\"pn\">)</span>\r\n\r\n    <span class=\"c\">// or can be defined separatly and used as HttpHandler</span>\r\n    <span class=\"id\">forward</span> <span class=\"s\">&quot;/api&quot;</span> <span class=\"id\">apiRouter</span>\r\n\r\n    <span class=\"c\">// same with controllers</span>\r\n    <span class=\"id\">forward</span> <span class=\"s\">&quot;/users&quot;</span> <span class=\"id\">userController</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val topRouter : obj</div>\r\n\r\n RouterState <p>Type representing internal state of the <code>router</code> computation expression</p>\r\n\r\n \n scope  router <p>Computation expression used to create routing in Saturn application</p>\r\n\r\n \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-application-applicationbuilder.html","title":"ApplicationBuilder","content":"ApplicationBuilder \n <p>Computation expression used to configure Saturn application.\r\nUnder the hood it's using ASP.NET application configurations interfaces such as <code>IWebHostBuilder</code>, <code>IServiceCollection</code>, <code>IApplicationBuilder</code> and others.\r\nIt aims to hide cumbersome ASP.NET application configuration and enable high level, declarative application configuration using feature toggles.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\">1: </span>\r\n<span class=\"l\">2: </span>\r\n<span class=\"l\">3: </span>\r\n<span class=\"l\">4: </span>\r\n<span class=\"l\">5: </span>\r\n<span class=\"l\">6: </span>\r\n<span class=\"l\">7: </span>\r\n<span class=\"l\">8: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"id\">app</span> <span class=\"o\">=</span> <span class=\"id\">application</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">pipe_through</span> <span class=\"id\">endpointPipe</span>\r\n    <span class=\"id\">use_router</span> <span class=\"id\">topRouter</span>\r\n    <span class=\"id\">url</span> <span class=\"s\">&quot;http://0.0.0.0:8085/&quot;</span>\r\n    <span class=\"id\">memory_cache</span>\r\n    <span class=\"id\">use_static</span> <span class=\"s\">&quot;static&quot;</span>\r\n    <span class=\"id\">use_gzip</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val app : obj</div>\r\n\r\n \n ActivateDeveloperExceptions <p>Turns on the developer exception page, if the environment is in development mode.</p>\r\n\r\n AddChannel <p>Registers channel for given url.</p>\r\n\r\n AddMimeTypes <p>Adds MIME types definitions as a list of (extension, mime)</p>\r\n\r\n AppConfig <p>Adds custom application configuration step.</p>\r\n\r\n CliArguments <p>Sets the cli arguments for the <code>IWebHostBuilder</code> to enable default command line configuration and functionality.</p>\r\n\r\n ConfigJSONSerializer <p>Configures built in JSON.Net (de)serializer with custom settings.</p>\r\n\r\n ConfigXMLSerializer <p>Configures built in XML (de)serializer with custom settings.</p>\r\n\r\n DisableDiagnostics <p>Disables generation of diagnostic files that can be used by Saturn tooling.</p>\r\n\r\n EndpointRouter <p>Defines top-level endpoint router used for the application</p>\r\n\r\n ErrorHandler <p>Adds error/not-found handler for current scope</p>\r\n\r\n ForceSSL <p>Redirect all HTTP request to HTTPS</p>\r\n\r\n HostConfig <p>Adds custom generic host (<code>IHostBuilder</code>) configuration step. Configuration for web host should use <code>webhost_config</code> instead.</p>\r\n\r\n ListenLocal <p>Listens on <code>::1</code> and <code>127.0.0.1</code> with the given port. Requesting a dynamic port by specifying <code>0</code> is not supported for this type of endpoint</p>\r\n\r\n Logging <p>Adds logging configuration.</p>\r\n\r\n MemoryCache <p>Enables in-memory session cache</p>\r\n\r\n NoRouter <p>Disable warning message about lack of <code>router</code> definition. Should be used for channels-only or gRPC applications.</p>\r\n\r\n NoWebhost <p>Disables any configuration of webhost. Could be used for generic <code>IHostBuilder</code> applications not using Kestrel/IIS</p>\r\n\r\n PipeThrough <p>Adds pipeline to the list of pipelines that will be used for every request</p>\r\n\r\n Router <p>Defines top-level router used for the application</p>\r\n\r\n Run  ServiceConfig <p>Adds custom service configuration step.</p>\r\n\r\n Url <p>Adds url</p>\r\n\r\n UseAntiforgery <p>Enables use of the <code>protectFromForgery</code> <code>pipeline</code> component and the <a href=\"saturn-csrf.html\" title=\"CSRF\"><code>CSRF</code></a> features in general.</p>\r\n\r\n UseAntiforgeryWithConfig <p>Enables use of the <code>protectFromForgery</code> <code>pipeline</code> component and the <a href=\"saturn-csrf.html\" title=\"CSRF\"><code>CSRF</code></a> features in general.\r\nThis overload allows for custom configuration of the subsystem, for more information see the <code>AntiforgeryOptions</code> class at <a href=\"https://github.com/aspnet/Antiforgery/blob/dev/src/Microsoft.AspNetCore.Antiforgery/AntiforgeryOptions.cs\">https://github.com/aspnet/Antiforgery/blob/dev/src/Microsoft.AspNetCore.Antiforgery/AntiforgeryOptions.cs</a></p>\r\n\r\n UseConfig  UseCookiesAuth <p>Enables default cookies authentication</p>\r\n\r\n UseCookiesAuthConfig <p>Enables cookies authentication with custom configuration</p>\r\n\r\n UseCors <p>Enables application level CORS protection</p>\r\n\r\n UseCustomJSONSerializer <p>Replaces built in JSON.Net (de)serializer with custom serializer</p>\r\n\r\n UseCustomXMLSerializer <p>Replaces built in XML (de)serializer with custom serializer</p>\r\n\r\n UseGZip <p>Enables gzip compression</p>\r\n\r\n UseIIS <p>Enables IIS integration</p>\r\n\r\n UseJWTAuth <p>Enables default JWT authentication</p>\r\n\r\n UseJWTAuthConfig <p>Enables JWT authentication with custom configuration</p>\r\n\r\n UseOAuthWithConfig <p>Enables OAuth authentication with custom configuration</p>\r\n\r\n UseOAuthWithSettings <p>Enables simple custom OAuth authentication using parmeters provided with <code>OAuth.OAuthSettings</code> record.\r\nCan be used to quickly implement default OAuth authentication for 3rd party providers.</p>\r\n\r\n UsePolicy <p>Add custom policy, taking an <code>AuthorizationHandlerContext -&gt; bool</code></p>\r\n\r\n UseStatic <p>Enables using static file hosting.</p>\r\n\r\n WebHostConfig <p>Adds custom web host configuration step.</p>\r\n\r\n Yield "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-application-applicationstate.html","title":"ApplicationState","content":"ApplicationState \n <p>Type representing internal state of the <code>application</code> computation expression</p>\r\n\r\n \n Router  EndpointRouter  ErrorHandler  Pipelines  Urls  MimeTypes  AppConfigs  HostConfigs  WebHostConfigs  ServicesConfig  CliArguments  CookiesAlreadyAdded  NoRouter  NoWebhost  Channels "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-cors-corsconfig.html","title":"CORSConfig","content":"CORSConfig \n <p>The configuration values for CORS</p>\r\n\r\n \n allowedUris <p>The list of allowed Uri(s) for requests.</p>\r\n\r\n allowedMethods <p>The list of allowed HttpMethods for the request.</p>\r\n\r\n allowCookies <p>Allow cookies? This is sent in the AccessControlAllowCredentials header.</p>\r\n\r\n exposeHeaders <p>The list of response headers exposed to client. This is sent in AccessControlExposeHeaders header.</p>\r\n\r\n maxAge <p>Max age in seconds the user agent is allowed to cache the result of the request.</p>\r\n\r\n"},{"uri":"https://saturnframework.org/reference/Saturn/saturn-csrf-csrferror.html","title":"CSRFError","content":"CSRFError \n  \n NotConfigured  Invalid "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-challengetype-challengetype.html","title":"ChallengeType","content":"ChallengeType \n  \n JWT  Cookies  Custom "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channelbuilder-channelbuilder.html","title":"ChannelBuilder","content":"ChannelBuilder \n <p>Computation expression used to create channels - an <code>controller</code>-like abstraction over WebSockets allowing real-time, and push-based communication between server and the client\r\nThe messages handled by channels should be json-encoded, in a following form: <code>{Topic = \"my topic\"; Ref = \"unique-message-id\"; Payload = {...} }</code></p>\r\n<p>The result of the computation expression is the <a href=\"saturn-channels-ichannel.html\" title=\"IChannel\"><code>IChannel</code></a> instance that can be registered in the <code>application</code> computation expression using <code>add_channel</code> operation.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\"> 1: </span>\r\n<span class=\"l\"> 2: </span>\r\n<span class=\"l\"> 3: </span>\r\n<span class=\"l\"> 4: </span>\r\n<span class=\"l\"> 5: </span>\r\n<span class=\"l\"> 6: </span>\r\n<span class=\"l\"> 7: </span>\r\n<span class=\"l\"> 8: </span>\r\n<span class=\"l\"> 9: </span>\r\n<span class=\"l\">10: </span>\r\n<span class=\"l\">11: </span>\r\n<span class=\"l\">12: </span>\r\n<span class=\"l\">13: </span>\r\n<span class=\"l\">14: </span>\r\n<span class=\"l\">15: </span>\r\n<span class=\"l\">16: </span>\r\n<span class=\"l\">17: </span>\r\n<span class=\"l\">18: </span>\r\n<span class=\"l\">19: </span>\r\n<span class=\"l\">20: </span>\r\n<span class=\"l\">21: </span>\r\n<span class=\"l\">22: </span>\r\n<span class=\"l\">23: </span>\r\n<span class=\"l\">24: </span>\r\n<span class=\"l\">25: </span>\r\n<span class=\"l\">26: </span>\r\n<span class=\"l\">27: </span>\r\n<span class=\"l\">28: </span>\r\n<span class=\"l\">29: </span>\r\n<span class=\"l\">30: </span>\r\n<span class=\"l\">31: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"id\">browserRouter</span> <span class=\"o\">=</span> <span class=\"id\">router</span> <span class=\"pn\">{</span>\r\n  <span class=\"id\">get</span> <span class=\"s\">&quot;/ping&quot;</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">next</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"id\">task</span> <span class=\"pn\">{</span>\r\n    <span class=\"k\">let</span> <span class=\"id\">hub</span> <span class=\"o\">=</span> <span class=\"id\">ctx</span><span class=\"pn\">.</span><span class=\"id\">GetService</span><span class=\"o\">&amp;</span><span class=\"id\">lt</span><span class=\"pn\">;</span><span onmouseout=\"hideTip(event, 'fs2', 2)\" onmouseover=\"showTip(event, 'fs2', 2)\" class=\"id\">Saturn</span><span class=\"pn\">.</span><span onmouseout=\"hideTip(event, 'fs3', 3)\" onmouseover=\"showTip(event, 'fs3', 3)\" class=\"id\">Channels</span><span class=\"pn\">.</span><span onmouseout=\"hideTip(event, 'fs4', 4)\" onmouseover=\"showTip(event, 'fs4', 4)\" class=\"id\">ISocketHub</span><span class=\"pn\">&gt;</span><span class=\"pn\">(</span><span class=\"pn\">)</span>\r\n    <span class=\"k\">match</span> <span class=\"id\">ctx</span><span class=\"pn\">.</span><span class=\"id\">TryGetQueryStringValue</span> <span class=\"s\">&quot;message&quot;</span> <span class=\"k\">with</span>\r\n    <span class=\"pn\">|</span> <span onmouseout=\"hideTip(event, 'fs5', 5)\" onmouseover=\"showTip(event, 'fs5', 5)\" class=\"id\">None</span> <span class=\"k\">-&gt;</span>\r\n      <span class=\"k\">do!</span> <span class=\"id\">hub</span><span class=\"pn\">.</span><span class=\"id\">SendMessageToClients</span> <span class=\"s\">&quot;/channel&quot;</span> <span class=\"s\">&quot;greeting&quot;</span> <span class=\"s\">&quot;hello&quot;</span>\r\n    <span class=\"pn\">|</span> <span onmouseout=\"hideTip(event, 'fs6', 6)\" onmouseover=\"showTip(event, 'fs6', 6)\" class=\"id\">Some</span> <span class=\"id\">message</span> <span class=\"k\">-&gt;</span>\r\n      <span class=\"k\">do!</span> <span class=\"id\">hub</span><span class=\"pn\">.</span><span class=\"id\">SendMessageToClients</span> <span class=\"s\">&quot;/channel&quot;</span> <span class=\"s\">&quot;greeting&quot;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs7', 7)\" onmouseover=\"showTip(event, 'fs7', 7)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;hello, %s&quot;</span> <span class=\"id\">message</span><span class=\"pn\">)</span>\r\n    <span class=\"k\">return!</span> <span class=\"id\">Successful</span><span class=\"pn\">.</span><span class=\"id\">ok</span> <span class=\"pn\">(</span><span class=\"id\">text</span> <span class=\"s\">&quot;Pinged the clients&quot;</span><span class=\"pn\">)</span> <span class=\"id\">next</span> <span class=\"id\">ctx</span>\r\n   <span class=\"pn\">}</span><span class=\"pn\">)</span>\r\n  <span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs8', 8)\" onmouseover=\"showTip(event, 'fs8', 8)\" class=\"id\">sampleChannel</span> <span class=\"o\">=</span> <span class=\"id\">channel</span> <span class=\"pn\">{</span>\r\n  <span class=\"id\">join</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"id\">si</span> <span class=\"k\">-&gt;</span> <span class=\"id\">task</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">ctx</span><span class=\"pn\">.</span><span class=\"id\">GetLogger</span><span class=\"pn\">(</span><span class=\"pn\">)</span><span class=\"pn\">.</span><span class=\"id\">LogInformation</span><span class=\"pn\">(</span><span class=\"s\">&quot;Connected! Socket Id: &quot;</span> <span class=\"o\">+</span> <span class=\"id\">si</span><span class=\"pn\">.</span><span class=\"id\">SocketId</span><span class=\"pn\">.</span><span class=\"id\">ToString</span><span class=\"pn\">(</span><span class=\"pn\">)</span><span class=\"pn\">)</span>\r\n    <span class=\"k\">return</span> <span onmouseout=\"hideTip(event, 'fs9', 9)\" onmouseover=\"showTip(event, 'fs9', 9)\" class=\"id\">Ok</span>\r\n  <span class=\"pn\">}</span><span class=\"pn\">)</span>\r\n\r\n  <span class=\"id\">handle</span> <span class=\"s\">&quot;topic&quot;</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"id\">si</span> <span class=\"id\">msg</span> <span class=\"k\">-&gt;</span>\r\n    <span class=\"id\">task</span> <span class=\"pn\">{</span>\r\n       <span class=\"k\">let</span> <span class=\"id\">logger</span> <span class=\"o\">=</span> <span class=\"id\">ctx</span><span class=\"pn\">.</span><span class=\"id\">GetLogger</span><span class=\"pn\">(</span><span class=\"pn\">)</span>\r\n       <span class=\"id\">logger</span><span class=\"pn\">.</span><span class=\"id\">LogInformation</span><span class=\"pn\">(</span><span class=\"s\">&quot;got message {message} from client with Socket Id: {socketId}&quot;</span><span class=\"pn\">,</span> <span class=\"id\">msg</span><span class=\"pn\">,</span> <span class=\"id\">si</span><span class=\"pn\">.</span><span class=\"id\">SocketId</span><span class=\"pn\">)</span>\r\n       <span class=\"k\">return</span> <span class=\"pn\">(</span><span class=\"pn\">)</span>\r\n  <span class=\"pn\">}</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs10', 10)\" onmouseover=\"showTip(event, 'fs10', 10)\" class=\"id\">app</span> <span class=\"o\">=</span> <span class=\"id\">application</span> <span class=\"pn\">{</span>\r\n  <span class=\"id\">use_router</span> <span onmouseout=\"hideTip(event, 'fs1', 11)\" onmouseover=\"showTip(event, 'fs1', 11)\" class=\"id\">browserRouter</span>\r\n  <span class=\"id\">url</span> <span class=\"s\">&quot;http://localhost:8085/&quot;</span>\r\n  <span class=\"id\">add_channel</span> <span class=\"s\">&quot;/channel&quot;</span> <span onmouseout=\"hideTip(event, 'fs8', 12)\" onmouseover=\"showTip(event, 'fs8', 12)\" class=\"id\">sampleChannel</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val browserRouter : obj</div>\r\n<div class=\"tip\" id=\"fs2\">namespace Saturn</div>\r\n<div class=\"tip\" id=\"fs3\">module Channels<br /><br />from Saturn</div>\r\n<div class=\"tip\" id=\"fs4\">type ISocketHub =<br />&#160;&#160;interface<br />&#160;&#160;&#160;&#160;abstract member SendMessageToClient : ChannelPath -&gt; SocketId -&gt; Topic -&gt; &#39;a -&gt; Task&lt;unit&gt;<br />&#160;&#160;&#160;&#160;abstract member SendMessageToClients : ChannelPath -&gt; Topic -&gt; &#39;a -&gt; Task&lt;unit&gt;<br />&#160;&#160;end</div>\r\n<div class=\"tip\" id=\"fs5\">union case Option.None: Option&lt;&#39;T&gt;</div>\r\n<div class=\"tip\" id=\"fs6\">union case Option.Some: Value: &#39;T -&gt; Option&lt;&#39;T&gt;</div>\r\n<div class=\"tip\" id=\"fs7\">val sprintf : format:Printf.StringFormat&lt;&#39;T&gt; -&gt; &#39;T</div>\r\n<div class=\"tip\" id=\"fs8\">val sampleChannel : obj</div>\r\n<div class=\"tip\" id=\"fs9\">union case Result.Ok: ResultValue: &#39;T -&gt; Result&lt;&#39;T,&#39;TError&gt;</div>\r\n<div class=\"tip\" id=\"fs10\">val app : obj</div>\r\n\r\n \n ErrorHandler <p>Action executed when unhandled exception happens in the\r\nAs arguments, <code>not_found_handler</code> action gets:\r\n<em>  current <code>HttpContext</code> for the request\r\n</em> <a href=\"saturn-channels-clientinfo.html\" title=\"ClientInfo\"><code>ClientInfo</code></a> instance representing additional information about client sending request\r\n* <code>Message&lt;'a&gt;</code> instance representing message sent from client to the channel</p>\r\n\r\n Handle <p>Action executed when client sends a message to the channel to the given topic.</p>\r\n<p>As arguments, <code>handle</code> action gets:\r\n<em>  current <code>HttpContext</code> for the request\r\n</em> <a href=\"saturn-channels-clientinfo.html\" title=\"ClientInfo\"><code>ClientInfo</code></a> instance representing additional information about client sending request\r\n* <code>Message&lt;'a&gt;</code> instance representing message sent from client to the channel</p>\r\n\r\n Join <p>Action executed when client tries to join the channel.\r\nYou can either return <code>Ok</code> if channel allows join, or reject it with <code>Rejected</code>\r\nTypical cases for rejection may include authorization/authentication,\r\nnot being able to handle more connections or other business logic reasons.</p>\r\n<p>As arguments, <code>join</code> action gets:\r\n<em>  current <code>HttpContext</code> for the request\r\n</em> <a href=\"saturn-channels-clientinfo.html\" title=\"ClientInfo\"><code>ClientInfo</code></a> instance representing additional information about client sending request</p>\r\n\r\n NotFoundHandler <p>Action executed when clients sends a message to the topic for which <code>handle</code> was not registered</p>\r\n<p>As arguments, <code>not_found_handler</code> action gets:\r\n<em>  current <code>HttpContext</code> for the request\r\n</em> <a href=\"saturn-channels-clientinfo.html\" title=\"ClientInfo\"><code>ClientInfo</code></a> instance representing additional information about client sending request\r\n* <code>Message&lt;'a&gt;</code> instance representing message sent from client to the channel</p>\r\n\r\n Run  Terminate <p>Action executed when client disconnects from the channel</p>\r\n<p>As arguments, <code>join</code> action gets:\r\n<em>  current <code>HttpContext</code> for the request\r\n</em> <a href=\"saturn-channels-clientinfo.html\" title=\"ClientInfo\"><code>ClientInfo</code></a> instance representing additional information about client sending request</p>\r\n\r\n Yield "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channelbuilder-channelbuilderstate.html","title":"ChannelBuilderState","content":"ChannelBuilderState \n <p>Type representing internal state of the <code>channel</code> computation expression</p>\r\n\r\n \n Join  Handlers  Terminate  NotFoundHandler  ErrorHandler "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channels-channelpath.html","title":"ChannelPath","content":"ChannelPath \n <p>Url (relative to root application url) on which channel is hosted. Type alias for <code>string</code></p>\r\n\r\n \n Chars  Length "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channels-clientinfo.html","title":"ClientInfo","content":"ClientInfo \n <p>Type representing information about client that has executed some channel action\r\nIt's passed as an argument in channel actions (<code>join</code>, <code>handle</code>, <code>terminate</code>)</p>\r\n\r\n \n New  SocketId "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channels-ichannel.html","title":"IChannel","content":"IChannel \n <p>Interface of the internal representation of the channel.\r\nShouldn't be used manually, you get its instance from the <code>channel</code> Computation Expression</p>\r\n\r\n \n HandleMessage  Join  Terminate "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channels-isockethub.html","title":"ISocketHub","content":"ISocketHub \n <p>Interface representing server side Socket Hub, giving you ability to brodcast messages (either to particular socket or to all sockets).\r\nYou can get instance of it with <code>ctx.GetService&amp;lt;Saturn.Channels.ISocketHub&gt;()</code> from any place that has access to HttpContext instance (<code>controller</code> actions, <code>channel</code> actions, normal <code>HttpHandler</code>)</p>\r\n\r\n \n SendMessageToClient  SendMessageToClients "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channels-joinresult.html","title":"JoinResult","content":"JoinResult \n <p>Type representing result of <code>join</code> action. It can be either succesful (<code>Ok</code>) or you can reject client connection (<code>Rejected</code>)</p>\r\n\r\n \n Ok  Rejected "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channels-message-1.html","title":"Message<'a>","content":"Message<'a> \n <p>Types representing channels message.\r\nIt always includes topic, reference id of the message (random GUID), and payload object.</p>\r\n\r\n \n Topic  Ref  Payload "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channels-sockethub.html","title":"SocketHub","content":"SocketHub \n <p>A type that wraps access to connected websockets by endpoint</p>\r\n\r\n \n ( .ctor )  ConnectSocketToPath  DisconnectSocketForPath  NewPath "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channels-socketid.html","title":"SocketId","content":"SocketId \n <p>Socket Id. Type alias for <code>Guid</code></p>\r\n\r\n \n "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channels-socketmiddleware.html","title":"SocketMiddleware","content":"SocketMiddleware \n  \n ( .ctor )  Invoke "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-channels-topic.html","title":"Topic","content":"Topic \n <p>Topic of the channel. Type alias for <code>string</code></p>\r\n\r\n \n Chars  Length "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-common-inclusiveoption-1.html","title":"InclusiveOption<'T>","content":"InclusiveOption<'T> \n  \n None  Some  All "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-controller-action.html","title":"Action","content":"Action \n <p>Type used for <code>plug</code> operation, allowing you to choose for which actions given plug should work</p>\r\n\r\n \n Index  Show  Add  Edit  Create  Update  Patch  Delete  DeleteAll  All "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-controller-controllerbuilder-10.html","title":"ControllerBuilder<'Key, 'IndexOutput, 'ShowOutput, 'AddOutput, 'EditOutput, 'CreateOutput, 'UpdateOutput, 'PatchOutput, 'DeleteOutput, 'DeleteAllOutput>","content":"ControllerBuilder<'Key, 'IndexOutput, 'ShowOutput, 'AddOutput, 'EditOutput, 'CreateOutput, 'UpdateOutput, 'PatchOutput, 'DeleteOutput, 'DeleteAllOutput> \n <p>Computation expression used to create Saturn controllers - abstraction representing REST-ish endpoint for serving HTML views or returning data. It supports:</p>\r\n<ul>\r\n<li>a set of predefined actions that are automatically mapped to the endpoints following standard conventions</li>\r\n<li>embedding sub-controllers for modeling one-to-many relationships</li>\r\n<li>versioning</li>\r\n<li>adding plugs for a particular action which in principle provides the same mechanism as attributes in ASP.NET MVC applications</li>\r\n<li>defining a common error handler for all actions</li>\r\n<li>defining a not-found action</li>\r\n</ul>\r\n<p>The result of the computation expression is a standard Giraffe <code>HttpHandler</code>, which means that it's easily composable with other parts of the ecosytem.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\"> 1: </span>\r\n<span class=\"l\"> 2: </span>\r\n<span class=\"l\"> 3: </span>\r\n<span class=\"l\"> 4: </span>\r\n<span class=\"l\"> 5: </span>\r\n<span class=\"l\"> 6: </span>\r\n<span class=\"l\"> 7: </span>\r\n<span class=\"l\"> 8: </span>\r\n<span class=\"l\"> 9: </span>\r\n<span class=\"l\">10: </span>\r\n<span class=\"l\">11: </span>\r\n<span class=\"l\">12: </span>\r\n<span class=\"l\">13: </span>\r\n<span class=\"l\">14: </span>\r\n<span class=\"l\">15: </span>\r\n<span class=\"l\">16: </span>\r\n<span class=\"l\">17: </span>\r\n<span class=\"l\">18: </span>\r\n<span class=\"l\">19: </span>\r\n<span class=\"l\">20: </span>\r\n<span class=\"l\">21: </span>\r\n<span class=\"l\">22: </span>\r\n<span class=\"l\">23: </span>\r\n<span class=\"l\">24: </span>\r\n<span class=\"l\">25: </span>\r\n<span class=\"l\">26: </span>\r\n<span class=\"l\">27: </span>\r\n<span class=\"l\">28: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"fn\">commentController</span> <span onmouseout=\"hideTip(event, 'fs2', 2)\" onmouseover=\"showTip(event, 'fs2', 2)\" class=\"id\">userId</span> <span class=\"o\">=</span> <span class=\"id\">controller</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">index</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 3)\" onmouseover=\"showTip(event, 'fs3', 3)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Comment Index handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs2', 4)\" onmouseover=\"showTip(event, 'fs2', 4)\" class=\"id\">userId</span> <span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">add</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 5)\" onmouseover=\"showTip(event, 'fs3', 5)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Comment Add handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs2', 6)\" onmouseover=\"showTip(event, 'fs2', 6)\" class=\"id\">userId</span> <span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">show</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 7)\" onmouseover=\"showTip(event, 'fs4', 7)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 8)\" onmouseover=\"showTip(event, 'fs3', 8)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Show comment %s handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 9)\" onmouseover=\"showTip(event, 'fs4', 9)\" class=\"id\">id</span> <span onmouseout=\"hideTip(event, 'fs2', 10)\" onmouseover=\"showTip(event, 'fs2', 10)\" class=\"id\">userId</span> <span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">edit</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 11)\" onmouseover=\"showTip(event, 'fs4', 11)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 12)\" onmouseover=\"showTip(event, 'fs3', 12)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Edit comment %s handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 13)\" onmouseover=\"showTip(event, 'fs4', 13)\" class=\"id\">id</span> <span onmouseout=\"hideTip(event, 'fs2', 14)\" onmouseover=\"showTip(event, 'fs2', 14)\" class=\"id\">userId</span> <span class=\"pn\">)</span>  <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs5', 15)\" onmouseover=\"showTip(event, 'fs5', 15)\" class=\"id\">userControllerVersion1</span> <span class=\"o\">=</span> <span class=\"id\">controller</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">version</span> <span class=\"n\">1</span>\r\n    <span class=\"id\">subController</span> <span class=\"s\">&quot;/comments&quot;</span> <span onmouseout=\"hideTip(event, 'fs1', 16)\" onmouseover=\"showTip(event, 'fs1', 16)\" class=\"id\">commentController</span>\r\n\r\n    <span class=\"id\">index</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Index handler version 1&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">add</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Add handler version 1&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">show</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 17)\" onmouseover=\"showTip(event, 'fs4', 17)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 18)\" onmouseover=\"showTip(event, 'fs3', 18)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Show handler version 1 - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 19)\" onmouseover=\"showTip(event, 'fs4', 19)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">edit</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 20)\" onmouseover=\"showTip(event, 'fs4', 20)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 21)\" onmouseover=\"showTip(event, 'fs3', 21)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Edit handler version 1 - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 22)\" onmouseover=\"showTip(event, 'fs4', 22)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs6', 23)\" onmouseover=\"showTip(event, 'fs6', 23)\" class=\"id\">userController</span> <span class=\"o\">=</span> <span class=\"id\">controller</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">subController</span> <span class=\"s\">&quot;/comments&quot;</span> <span onmouseout=\"hideTip(event, 'fs1', 24)\" onmouseover=\"showTip(event, 'fs1', 24)\" class=\"id\">commentController</span>\r\n\r\n    <span class=\"id\">plug</span> <span class=\"pn\">[</span><span class=\"id\">All</span><span class=\"pn\">]</span> <span class=\"pn\">(</span><span class=\"id\">setHttpHeader</span> <span class=\"s\">&quot;user-controller-common&quot;</span> <span class=\"s\">&quot;123&quot;</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">plug</span> <span class=\"pn\">[</span><span class=\"id\">Index</span><span class=\"pn\">;</span> <span class=\"id\">Show</span><span class=\"pn\">]</span> <span class=\"pn\">(</span><span class=\"id\">setHttpHeader</span> <span class=\"s\">&quot;user-controller-specialized&quot;</span> <span class=\"s\">&quot;123&quot;</span><span class=\"pn\">)</span>\r\n\r\n    <span class=\"id\">index</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Index handler no version&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">add</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Add handler no version&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">show</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 25)\" onmouseover=\"showTip(event, 'fs4', 25)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 26)\" onmouseover=\"showTip(event, 'fs3', 26)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Show handler no version - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 27)\" onmouseover=\"showTip(event, 'fs4', 27)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">edit</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 28)\" onmouseover=\"showTip(event, 'fs4', 28)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 29)\" onmouseover=\"showTip(event, 'fs3', 29)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Edit handler no version - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 30)\" onmouseover=\"showTip(event, 'fs4', 30)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val commentController : userId:&#39;a -&gt; &#39;b</div>\r\n<div class=\"tip\" id=\"fs2\">val userId : &#39;a</div>\r\n<div class=\"tip\" id=\"fs3\">val sprintf : format:Printf.StringFormat&lt;&#39;T&gt; -&gt; &#39;T</div>\r\n<div class=\"tip\" id=\"fs4\">val id : x:&#39;T -&gt; &#39;T</div>\r\n<div class=\"tip\" id=\"fs5\">val userControllerVersion1 : obj</div>\r\n<div class=\"tip\" id=\"fs6\">val userController : obj</div>\r\n\r\n \n Add  Add <p>Operation that should render form for adding new item</p>\r\n\r\n CaseInsensitive <p>Toggle case insensitve routing</p>\r\n\r\n Create  Create <p>Operation that creates new item</p>\r\n\r\n Delete  Delete <p>Operation that deletes existing item</p>\r\n\r\n DeleteAll  DeleteAll <p>Operation that deletes all items</p>\r\n\r\n Edit  Edit <p>Operation that should render form for editing existing item</p>\r\n\r\n ErrorHandler  ErrorHandler <p>Define error for the controller</p>\r\n\r\n Index  Index <p>Operation that should render (or return in case of API controllers) list of data</p>\r\n\r\n NotFoundHandler <p>Define not-found handler for the controller</p>\r\n\r\n Patch  Patch <p>Operation that patches existing item</p>\r\n\r\n Plug <p>Add a plug that will be run on each of the provided actions.</p>\r\n\r\n Run  Show  Show <p>Operation that should render (or return in case of API controllers) single entry of data</p>\r\n\r\n SubController <p>Inject a controller into the routing table rooted at a given route. All of that controller's actions will be anchored off of the route as a prefix.</p>\r\n\r\n Update  Update <p>Operation that updates existing item</p>\r\n\r\n Version <p>Define version of controller. Adds checking of <code>x-controller-version</code> header</p>\r\n\r\n Yield "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-controller-controllerstate-10.html","title":"ControllerState<'Key, 'IndexOutput, 'ShowOutput, 'AddOutput, 'EditOutput, 'CreateOutput, 'UpdateOutput, 'PatchOutput, 'DeleteOutput, 'DeleteAllOutput>","content":"ControllerState<'Key, 'IndexOutput, 'ShowOutput, 'AddOutput, 'EditOutput, 'CreateOutput, 'UpdateOutput, 'PatchOutput, 'DeleteOutput, 'DeleteAllOutput> \n <p>Type representing internal state of the <code>controller</code> computation expression</p>\r\n\r\n \n Index  Show  Add  Edit  Create  Update  Patch  Delete  DeleteAll  NotFoundHandler  ErrorHandler  SubControllers  Plugs  Version  CaseInsensitive "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-oauth-oauthsettings.html","title":"OAuthSettings","content":"OAuthSettings \n <p>Record type representing simple OAuth configuration to be used with <code>use_oauth_with_settings</code>.</p>\r\n\r\n \n Schema <p>Name of the schema to be registered</p>\r\n\r\n CallbackPath <p>OAuth CallbackPath endpoint</p>\r\n\r\n AuthorizationEndpoint <p>OAuth Authorization endpoint\r\nFor example: <a href=\"https://github.com/login/oauth/authorize\">https://github.com/login/oauth/authorize</a></p>\r\n\r\n TokenEndpoint <p>OAuth Token endpoint\r\nFor example: <a href=\"https://github.com/login/oauth/access_token\">https://github.com/login/oauth/access_token</a></p>\r\n\r\n UserInformationEndpoint <p>OAuth User Information endpoint\r\nFor example: <a href=\"https://api.github.com/user\">https://api.github.com/user</a></p>\r\n\r\n Claims <p>Sequance of tuples where first element is a name of the of the key in JSON object and second element is a name of the claim.\r\nFor example: <code>[\"login\", \"githubUsername\"; \"name\", \"fullName\"]</code> where <code>login</code> and <code>name</code> are names of fields in GitHub JSON response (<a href=\"https://developer.github.com/v3/users/#get-the-authenticated-user).\">https://developer.github.com/v3/users/#get-the-authenticated-user).</a></p>\r\n\r\n"},{"uri":"https://saturnframework.org/reference/Saturn/saturn-pipeline-pipelinebuilder.html","title":"PipelineBuilder","content":"PipelineBuilder \n <p>Computation expression used to combine <code>HttpHandlers</code> in a declarative manner.</p>\r\n<p>The result of the computation expression is a standard Giraffe <code>HttpHandler</code> which means that it's easily composable with other parts of the Giraffe ecosystem.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\"> 1: </span>\r\n<span class=\"l\"> 2: </span>\r\n<span class=\"l\"> 3: </span>\r\n<span class=\"l\"> 4: </span>\r\n<span class=\"l\"> 5: </span>\r\n<span class=\"l\"> 6: </span>\r\n<span class=\"l\"> 7: </span>\r\n<span class=\"l\"> 8: </span>\r\n<span class=\"l\"> 9: </span>\r\n<span class=\"l\">10: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"id\">headerPipe</span> <span class=\"o\">=</span> <span class=\"id\">pipeline</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">set_header</span> <span class=\"s\">&quot;myCustomHeader&quot;</span> <span class=\"s\">&quot;abcd&quot;</span>\r\n    <span class=\"id\">set_header</span> <span class=\"s\">&quot;myCustomHeader2&quot;</span> <span class=\"s\">&quot;zxcv&quot;</span>\r\n<span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs2', 2)\" onmouseover=\"showTip(event, 'fs2', 2)\" class=\"id\">endpointPipe</span> <span class=\"o\">=</span> <span class=\"id\">pipeline</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">plug</span> <span class=\"id\">fetchSession</span>\r\n    <span class=\"id\">plug</span> <span class=\"id\">head</span>\r\n    <span class=\"id\">plug</span> <span class=\"id\">requestId</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val headerPipe : obj</div>\r\n<div class=\"tip\" id=\"fs2\">val endpointPipe : obj</div>\r\n\r\n \n Challenge <p><code>challenge</code> challenges an authentication with a specified authentication scheme</p>\r\n\r\n ClearResponse <p><code>clear_response</code> tries to clear the current response. This can be useful inside an error handler to reset the response before writing an error message to the body of the HTTP response object.</p>\r\n\r\n Html <p><code>html</code> sets or modifies the body of the <code>HttpResponse</code> with the contents of a single string variable. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more.</p>\r\n\r\n HtmlFile <p><code>html_file</code> sets or modifies the body of the <code>HttpResponse</code> with the contents of a physical html file. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. This http handler takes a rooted path of a html file or a path which is relative to the ContentRootPath as the input parameter and sets the HTTP header <code>Content-Type</code> to <code>text/html</code>.</p>\r\n\r\n Json <p><code>json</code> sets or modifies the body of the <code>HttpResponse</code> by sending a JSON serialized object to the client. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. It also sets the <code>Content-Type</code> HTTP header to <code>application/json</code>.</p>\r\n\r\n MustAccept <p><code>must_accept</code> filters a request by the <code>Accept</code> HTTP header. You can use it to check if a client accepts a certain mime type before returning a response.</p>\r\n\r\n Negotiate <p><code>negotiate</code> sets or modifies the body of the <code>HttpResponse</code> by inspecting the <code>Accept</code> header of the HTTP request and deciding if the response should be sent in JSON or XML or plain text. If the client is indifferent then the default response will be sent in JSON. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more.</p>\r\n\r\n NegotiateWith <p><code>negotiateWith</code> sets or modifies the body of the <code>HttpResponse</code> by inspecting the <code>Accept</code> header of the HTTP request and deciding in what mimeType the response should be sent. A dictionary of type <code>IDictionary&lt;string, obj -&gt; HttpHandler&gt;</code> is used to determine which <code>obj -&gt; HttpHandler</code> function should be used to convert an object into a <code>HttpHandler</code> for a given mime type. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more.</p>\r\n\r\n Plug <p><code>plug</code> enables adding any additional <code>HttpHandler</code> to the pipeline</p>\r\n\r\n RedirectTo <p><code>redirect_to</code> uses a 302 or 301 (when permanent) HTTP response code to redirect the client to the specified location. It takes in two parameters, a boolean flag denoting whether the redirect should be permanent or not and the location to redirect to.</p>\r\n\r\n RenderHtml <p><code>render_html</code> is a more functional way of generating HTML by composing HTML elements in F# to generate a rich Model-View output.</p>\r\n\r\n RequiresAuthPolicy <p><code>requires_auth_policy</code> validates if a user satisfies policy requirement, if not then the handler will execute the <code>authFailedHandler</code> function.</p>\r\n\r\n RequiresAuthentication <p><code>requires_authentication</code> validates if a user is authenticated/logged in. If the user is not authenticated then the handler will execute the <code>authFailedHandler</code> function.</p>\r\n\r\n RequiresPolicy <p><code>requires_policy</code> validates if a user satisfies a defined policy requirement, if not then the handler will execute the <code>authFailedHandler</code> function.</p>\r\n\r\n RequiresRole <p><code>requires_role</code> validates if an authenticated user is in a specified role. If the user fails to be in the required role then the handler will execute the <code>authFailedHandler</code> function.</p>\r\n\r\n RequiresRoleOf <p><code>requires_role_of</code> validates if an authenticated user is in one of the supplied roles. If the user fails to be in one of the required roles then the handler will execute the <code>authFailedHandler</code> function.</p>\r\n\r\n RoutePorts <p>If your web server is listening to multiple ports then you can use the <code>routePorts</code> HttpHandler to easily filter incoming requests based on their port by providing a list of port number and HttpHandler (<code>(int * HttpHandler) list</code>).</p>\r\n\r\n SetBody <p><code>set_body</code> sets or modifies the body of the <code>HttpResponse</code>. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more.</p>\r\n\r\n SetBodyFromString <p><code>set_body_from_string</code> sets or modifies the body of the <code>HttpResponse</code>. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more.</p>\r\n\r\n SetHeader <p><code>set_header</code> sets or modifies a HTTP header of the <code>HttpResponse</code>.</p>\r\n\r\n SetStatusCode <p><code>set_status_code</code> changes the status code of the <code>HttpResponse</code>.</p>\r\n\r\n SignOff <p><code>sign_off</code> signs off the currently logged in user.</p>\r\n\r\n Text <p><code>text</code> sets or modifies the body of the <code>HttpResponse</code> by sending a plain text value to the client. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. It also sets the <code>Content-Type</code> HTTP header to <code>text/plain</code>.</p>\r\n\r\n Warbler <p>If your route is not returning a static response, then you should wrap your function with a warbler. Functions in F# are eagerly evaluated and the warbler will help to evaluate the function every time the route is hit.</p>\r\n\r\n Xml <p><code>xml</code> sets or modifies the body of the <code>HttpResponse</code> by sending an XML serialized object to the client. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. It also sets the <code>Content-Type</code> HTTP header to <code>application/xml</code>.</p>\r\n\r\n Yield "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-router-routetype.html","title":"RouteType","content":"RouteType \n <p>Type representing route type, used in internal state of the <code>application</code> computation expression</p>\r\n\r\n \n Get  Post  Put  Delete  Patch  Forward "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-router-routerbuilder.html","title":"RouterBuilder","content":"RouterBuilder \n <p>Computation expression used to create routing, combining <code>HttpHandlers</code>, <code>pipelines</code> and <code>controllers</code> together.</p>\r\n<p>The result of the computation expression is a standard Giraffe <code>HttpHandler</code>, which means that it's easily composable with other parts of the ecosytem.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\"> 1: </span>\r\n<span class=\"l\"> 2: </span>\r\n<span class=\"l\"> 3: </span>\r\n<span class=\"l\"> 4: </span>\r\n<span class=\"l\"> 5: </span>\r\n<span class=\"l\"> 6: </span>\r\n<span class=\"l\"> 7: </span>\r\n<span class=\"l\"> 8: </span>\r\n<span class=\"l\"> 9: </span>\r\n<span class=\"l\">10: </span>\r\n<span class=\"l\">11: </span>\r\n<span class=\"l\">12: </span>\r\n<span class=\"l\">13: </span>\r\n<span class=\"l\">14: </span>\r\n<span class=\"l\">15: </span>\r\n<span class=\"l\">16: </span>\r\n<span class=\"l\">17: </span>\r\n<span class=\"l\">18: </span>\r\n<span class=\"l\">19: </span>\r\n<span class=\"l\">20: </span>\r\n<span class=\"l\">21: </span>\r\n<span class=\"l\">22: </span>\r\n<span class=\"l\">23: </span>\r\n<span class=\"l\">24: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"id\">topRouter</span> <span class=\"o\">=</span> <span class=\"id\">router</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">pipe_through</span> <span class=\"id\">headerPipe</span>\r\n    <span class=\"id\">not_found_handler</span> <span class=\"pn\">(</span><span class=\"id\">text</span> <span class=\"s\">&quot;404&quot;</span><span class=\"pn\">)</span>\r\n\r\n    <span class=\"id\">get</span> <span class=\"s\">&quot;/&quot;</span> <span class=\"id\">helloWorld</span>\r\n    <span class=\"id\">get</span> <span class=\"s\">&quot;/a&quot;</span> <span class=\"id\">helloWorld2</span>\r\n    <span class=\"id\">getf</span> <span class=\"s\">&quot;/name/%s&quot;</span> <span class=\"id\">helloWorldName</span>\r\n    <span class=\"id\">getf</span> <span class=\"s\">&quot;/name/%s/%i&quot;</span> <span class=\"id\">helloWorldNameAge</span>\r\n\r\n    <span class=\"c\">//routers can be defined inline to simulate `subRoute` combinator</span>\r\n    <span class=\"id\">forward</span> <span class=\"s\">&quot;/other&quot;</span> <span class=\"pn\">(</span><span class=\"id\">router</span> <span class=\"pn\">{</span>\r\n        <span class=\"id\">pipe_through</span> <span class=\"id\">otherHeaderPipe</span>\r\n        <span class=\"id\">not_found_handler</span> <span class=\"pn\">(</span><span class=\"id\">text</span> <span class=\"s\">&quot;Other 404&quot;</span><span class=\"pn\">)</span>\r\n\r\n        <span class=\"id\">get</span> <span class=\"s\">&quot;/&quot;</span> <span class=\"id\">otherHelloWorld</span>\r\n        <span class=\"id\">get</span> <span class=\"s\">&quot;/a&quot;</span> <span class=\"id\">otherHelloWorld2</span>\r\n    <span class=\"pn\">}</span><span class=\"pn\">)</span>\r\n\r\n    <span class=\"c\">// or can be defined separatly and used as HttpHandler</span>\r\n    <span class=\"id\">forward</span> <span class=\"s\">&quot;/api&quot;</span> <span class=\"id\">apiRouter</span>\r\n\r\n    <span class=\"c\">// same with controllers</span>\r\n    <span class=\"id\">forward</span> <span class=\"s\">&quot;/users&quot;</span> <span class=\"id\">userController</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val topRouter : obj</div>\r\n\r\n \n CaseInsensitive <p>Toggle case insensitve routing</p>\r\n\r\n Delete <p>Adds handler for <code>DELETE</code> request.</p>\r\n\r\n DeleteF <p>Adds handler for <code>DELETE</code> request.</p>\r\n\r\n Forward <p>Forwards calls to different <code>scope</code>. Modifies the <code>HttpRequest.Path</code> to allow subrouting.</p>\r\n\r\n Forwardf <p>Forwards calls to different <code>scope</code>. Modifies the <code>HttpRequest.Path</code> to allow subrouting.</p>\r\n\r\n Get <p>Adds handler for <code>GET</code> request.</p>\r\n\r\n GetF <p>Adds handler for <code>GET</code> request.</p>\r\n\r\n NotFoundHandler <p>Adds not-found handler for current scope</p>\r\n\r\n Patch <p>Adds handler for <code>PATCH</code> request.</p>\r\n\r\n PatchF <p>Adds handler for <code>PATCH</code> request.</p>\r\n\r\n PipeThrough <p>Adds pipeline to the list of pipelines that will be used for every request</p>\r\n\r\n Post <p>Adds handler for <code>POST</code> request.</p>\r\n\r\n PostF <p>Adds handler for <code>POST</code> request.</p>\r\n\r\n Put <p>Adds handler for <code>PUT</code> request.</p>\r\n\r\n PutF <p>Adds handler for <code>PUT</code> request.</p>\r\n\r\n Run  Yield "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-router-routerstate.html","title":"RouterState","content":"RouterState \n <p>Type representing internal state of the <code>router</code> computation expression</p>\r\n\r\n \n Routes  RoutesF  NotFoundHandler  Pipelines  CaseInsensitive "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-sitemap-handlermap.html","title":"HandlerMap","content":"HandlerMap \n  \n ( .ctor )  AddPath  CollectPaths  Forward  GetKey  NotFound  SetKey  Version  Version "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-sitemap-pathentry.html","title":"PathEntry","content":"PathEntry \n  \n Route  Verb  Headers "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-endpoint-controller-action.html","title":"Action","content":"Action \n <p>Type used for <code>plug</code> operation, allowing you to choose for which actions given plug should work</p>\r\n\r\n \n Index  Show  Add  Edit  Create  Update  Patch  Delete  DeleteAll  All "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-endpoint-controller-controllerbuilder-10.html","title":"ControllerBuilder<'Key, 'IndexOutput, 'ShowOutput, 'AddOutput, 'EditOutput, 'CreateOutput, 'UpdateOutput, 'PatchOutput, 'DeleteOutput, 'DeleteAllOutput>","content":"ControllerBuilder<'Key, 'IndexOutput, 'ShowOutput, 'AddOutput, 'EditOutput, 'CreateOutput, 'UpdateOutput, 'PatchOutput, 'DeleteOutput, 'DeleteAllOutput> \n <p>Computation expression used to create Saturn controllers - abstraction representing REST-ish endpoint for serving HTML views or returning data. It supports:</p>\r\n<ul>\r\n<li>a set of predefined actions that are automatically mapped to the endpoints following standard conventions</li>\r\n<li>embedding sub-controllers for modeling one-to-many relationships</li>\r\n<li>versioning</li>\r\n<li>adding plugs for a particular action which in principle provides the same mechanism as attributes in ASP.NET MVC applications</li>\r\n<li>defining a common error handler for all actions</li>\r\n<li>defining a not-found action</li>\r\n</ul>\r\n<p>The result of the computation expression is a standard Giraffe <code>HttpHandler</code>, which means that it's easily composable with other parts of the ecosytem.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\"> 1: </span>\r\n<span class=\"l\"> 2: </span>\r\n<span class=\"l\"> 3: </span>\r\n<span class=\"l\"> 4: </span>\r\n<span class=\"l\"> 5: </span>\r\n<span class=\"l\"> 6: </span>\r\n<span class=\"l\"> 7: </span>\r\n<span class=\"l\"> 8: </span>\r\n<span class=\"l\"> 9: </span>\r\n<span class=\"l\">10: </span>\r\n<span class=\"l\">11: </span>\r\n<span class=\"l\">12: </span>\r\n<span class=\"l\">13: </span>\r\n<span class=\"l\">14: </span>\r\n<span class=\"l\">15: </span>\r\n<span class=\"l\">16: </span>\r\n<span class=\"l\">17: </span>\r\n<span class=\"l\">18: </span>\r\n<span class=\"l\">19: </span>\r\n<span class=\"l\">20: </span>\r\n<span class=\"l\">21: </span>\r\n<span class=\"l\">22: </span>\r\n<span class=\"l\">23: </span>\r\n<span class=\"l\">24: </span>\r\n<span class=\"l\">25: </span>\r\n<span class=\"l\">26: </span>\r\n<span class=\"l\">27: </span>\r\n<span class=\"l\">28: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"fn\">commentController</span> <span onmouseout=\"hideTip(event, 'fs2', 2)\" onmouseover=\"showTip(event, 'fs2', 2)\" class=\"id\">userId</span> <span class=\"o\">=</span> <span class=\"id\">subcontroller</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">index</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 3)\" onmouseover=\"showTip(event, 'fs3', 3)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Comment Index handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs2', 4)\" onmouseover=\"showTip(event, 'fs2', 4)\" class=\"id\">userId</span> <span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">add</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 5)\" onmouseover=\"showTip(event, 'fs3', 5)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Comment Add handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs2', 6)\" onmouseover=\"showTip(event, 'fs2', 6)\" class=\"id\">userId</span> <span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">show</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 7)\" onmouseover=\"showTip(event, 'fs4', 7)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 8)\" onmouseover=\"showTip(event, 'fs3', 8)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Show comment %s handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 9)\" onmouseover=\"showTip(event, 'fs4', 9)\" class=\"id\">id</span> <span onmouseout=\"hideTip(event, 'fs2', 10)\" onmouseover=\"showTip(event, 'fs2', 10)\" class=\"id\">userId</span> <span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">edit</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 11)\" onmouseover=\"showTip(event, 'fs4', 11)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 12)\" onmouseover=\"showTip(event, 'fs3', 12)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Edit comment %s handler for user %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 13)\" onmouseover=\"showTip(event, 'fs4', 13)\" class=\"id\">id</span> <span onmouseout=\"hideTip(event, 'fs2', 14)\" onmouseover=\"showTip(event, 'fs2', 14)\" class=\"id\">userId</span> <span class=\"pn\">)</span>  <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs5', 15)\" onmouseover=\"showTip(event, 'fs5', 15)\" class=\"id\">userControllerVersion1</span> <span class=\"o\">=</span> <span class=\"id\">controller</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">version</span> <span class=\"n\">1</span>\r\n    <span class=\"id\">subController</span> <span class=\"s\">&quot;/comments&quot;</span> <span onmouseout=\"hideTip(event, 'fs1', 16)\" onmouseover=\"showTip(event, 'fs1', 16)\" class=\"id\">commentController</span>\r\n\r\n    <span class=\"id\">index</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Index handler version 1&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">add</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Add handler version 1&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">show</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 17)\" onmouseover=\"showTip(event, 'fs4', 17)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 18)\" onmouseover=\"showTip(event, 'fs3', 18)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Show handler version 1 - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 19)\" onmouseover=\"showTip(event, 'fs4', 19)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">edit</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 20)\" onmouseover=\"showTip(event, 'fs4', 20)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 21)\" onmouseover=\"showTip(event, 'fs3', 21)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Edit handler version 1 - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 22)\" onmouseover=\"showTip(event, 'fs4', 22)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n\r\n<span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs6', 23)\" onmouseover=\"showTip(event, 'fs6', 23)\" class=\"id\">userController</span> <span class=\"o\">=</span> <span class=\"id\">controller</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">subController</span> <span class=\"s\">&quot;/comments&quot;</span> <span onmouseout=\"hideTip(event, 'fs1', 24)\" onmouseover=\"showTip(event, 'fs1', 24)\" class=\"id\">commentController</span>\r\n\r\n    <span class=\"id\">plug</span> <span class=\"pn\">[</span><span class=\"id\">All</span><span class=\"pn\">]</span> <span class=\"pn\">(</span><span class=\"id\">setHttpHeader</span> <span class=\"s\">&quot;user-controller-common&quot;</span> <span class=\"s\">&quot;123&quot;</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">plug</span> <span class=\"pn\">[</span><span class=\"id\">Index</span><span class=\"pn\">;</span> <span class=\"id\">Show</span><span class=\"pn\">]</span> <span class=\"pn\">(</span><span class=\"id\">setHttpHeader</span> <span class=\"s\">&quot;user-controller-specialized&quot;</span> <span class=\"s\">&quot;123&quot;</span><span class=\"pn\">)</span>\r\n\r\n    <span class=\"id\">index</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Index handler no version&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">add</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"id\">ctx</span> <span class=\"k\">-&gt;</span> <span class=\"s\">&quot;Add handler no version&quot;</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">show</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 25)\" onmouseover=\"showTip(event, 'fs4', 25)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 26)\" onmouseover=\"showTip(event, 'fs3', 26)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Show handler no version - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 27)\" onmouseover=\"showTip(event, 'fs4', 27)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n    <span class=\"id\">edit</span> <span class=\"pn\">(</span><span class=\"k\">fun</span> <span class=\"pn\">(</span><span class=\"id\">ctx</span><span class=\"pn\">,</span> <span onmouseout=\"hideTip(event, 'fs4', 28)\" onmouseover=\"showTip(event, 'fs4', 28)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"k\">-&gt;</span> <span class=\"pn\">(</span><span onmouseout=\"hideTip(event, 'fs3', 29)\" onmouseover=\"showTip(event, 'fs3', 29)\" class=\"id\">sprintf</span> <span class=\"s\">&quot;Edit handler no version - %i&quot;</span> <span onmouseout=\"hideTip(event, 'fs4', 30)\" onmouseover=\"showTip(event, 'fs4', 30)\" class=\"id\">id</span><span class=\"pn\">)</span> <span class=\"o\">|&gt;</span> <span class=\"id\">Controller</span><span class=\"pn\">.</span><span class=\"id\">text</span> <span class=\"id\">ctx</span><span class=\"pn\">)</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val commentController : userId:&#39;a -&gt; &#39;b</div>\r\n<div class=\"tip\" id=\"fs2\">val userId : &#39;a</div>\r\n<div class=\"tip\" id=\"fs3\">val sprintf : format:Printf.StringFormat&lt;&#39;T&gt; -&gt; &#39;T</div>\r\n<div class=\"tip\" id=\"fs4\">val id : x:&#39;T -&gt; &#39;T</div>\r\n<div class=\"tip\" id=\"fs5\">val userControllerVersion1 : obj</div>\r\n<div class=\"tip\" id=\"fs6\">val userController : obj</div>\r\n\r\n \n Add  Add <p>Operation that should render form for adding new item</p>\r\n\r\n Create  Create <p>Operation that creates new item</p>\r\n\r\n Delete  Delete <p>Operation that deletes existing item</p>\r\n\r\n DeleteAll  DeleteAll <p>Operation that deletes all items</p>\r\n\r\n Edit  Edit <p>Operation that should render form for editing existing item</p>\r\n\r\n ErrorHandler  ErrorHandler <p>Define error for the controller</p>\r\n\r\n Index  Index <p>Operation that should render (or return in case of API controllers) list of data</p>\r\n\r\n NotFoundHandler <p>Define not-found handler for the controller</p>\r\n\r\n Patch  Patch <p>Operation that patches existing item</p>\r\n\r\n Plug <p>Add a plug that will be run on each of the provided actions.</p>\r\n\r\n Run  Show  Show <p>Operation that should render (or return in case of API controllers) single entry of data</p>\r\n\r\n SubController <p>Inject a controller into the routing table rooted at a given route. All of that controller's actions will be anchored off of the route as a prefix.</p>\r\n\r\n Update  Update <p>Operation that updates existing item</p>\r\n\r\n Version <p>Define version of controller. Adds checking of <code>x-controller-version</code> header</p>\r\n\r\n Yield "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-endpoint-controller-controllerstate-10.html","title":"ControllerState<'Key, 'IndexOutput, 'ShowOutput, 'AddOutput, 'EditOutput, 'CreateOutput, 'UpdateOutput, 'PatchOutput, 'DeleteOutput, 'DeleteAllOutput>","content":"ControllerState<'Key, 'IndexOutput, 'ShowOutput, 'AddOutput, 'EditOutput, 'CreateOutput, 'UpdateOutput, 'PatchOutput, 'DeleteOutput, 'DeleteAllOutput> \n <p>Type representing internal state of the <code>controller</code> computation expression</p>\r\n\r\n \n Index  Show  Add  Edit  Create  Update  Patch  Delete  DeleteAll  NotFoundHandler  ErrorHandler  SubControllers  Plugs  Version "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-endpoint-router-routetype.html","title":"RouteType","content":"RouteType \n <p>Type representing route type, used in internal state of the <code>application</code> computation expression</p>\r\n\r\n \n Get  Post  Put  Delete  Patch "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-endpoint-router-routerbuilder.html","title":"RouterBuilder","content":"RouterBuilder \n <p>Computation expression used to create routing, combining <code>HttpHandlers</code>, <code>pipelines</code> and <code>controllers</code> together.</p>\r\n<p>The result of the computation expression is a standard Giraffe <code>HttpHandler</code>, which means that it's easily composable with other parts of the ecosytem.</p>\r\n<p><strong>Example:</strong></p>\r\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\"><span class=\"l\"> 1: </span>\r\n<span class=\"l\"> 2: </span>\r\n<span class=\"l\"> 3: </span>\r\n<span class=\"l\"> 4: </span>\r\n<span class=\"l\"> 5: </span>\r\n<span class=\"l\"> 6: </span>\r\n<span class=\"l\"> 7: </span>\r\n<span class=\"l\"> 8: </span>\r\n<span class=\"l\"> 9: </span>\r\n<span class=\"l\">10: </span>\r\n<span class=\"l\">11: </span>\r\n<span class=\"l\">12: </span>\r\n<span class=\"l\">13: </span>\r\n<span class=\"l\">14: </span>\r\n<span class=\"l\">15: </span>\r\n<span class=\"l\">16: </span>\r\n<span class=\"l\">17: </span>\r\n<span class=\"l\">18: </span>\r\n<span class=\"l\">19: </span>\r\n<span class=\"l\">20: </span>\r\n<span class=\"l\">21: </span>\r\n<span class=\"l\">22: </span>\r\n<span class=\"l\">23: </span>\r\n<span class=\"l\">24: </span>\r\n</pre></td>\r\n<td class=\"snippet\"><pre class=\"fssnip highlighted\"><code lang=\"fsharp\"><span class=\"k\">let</span> <span onmouseout=\"hideTip(event, 'fs1', 1)\" onmouseover=\"showTip(event, 'fs1', 1)\" class=\"id\">topRouter</span> <span class=\"o\">=</span> <span class=\"id\">router</span> <span class=\"pn\">{</span>\r\n    <span class=\"id\">pipe_through</span> <span class=\"id\">headerPipe</span>\r\n    <span class=\"id\">not_found_handler</span> <span class=\"pn\">(</span><span class=\"id\">text</span> <span class=\"s\">&quot;404&quot;</span><span class=\"pn\">)</span>\r\n\r\n    <span class=\"id\">get</span> <span class=\"s\">&quot;/&quot;</span> <span class=\"id\">helloWorld</span>\r\n    <span class=\"id\">get</span> <span class=\"s\">&quot;/a&quot;</span> <span class=\"id\">helloWorld2</span>\r\n    <span class=\"id\">getf</span> <span class=\"s\">&quot;/name/%s&quot;</span> <span class=\"id\">helloWorldName</span>\r\n    <span class=\"id\">getf</span> <span class=\"s\">&quot;/name/%s/%i&quot;</span> <span class=\"id\">helloWorldNameAge</span>\r\n\r\n    <span class=\"c\">//routers can be defined inline to simulate `subRoute` combinator</span>\r\n    <span class=\"id\">forward</span> <span class=\"s\">&quot;/other&quot;</span> <span class=\"pn\">(</span><span class=\"id\">router</span> <span class=\"pn\">{</span>\r\n        <span class=\"id\">pipe_through</span> <span class=\"id\">otherHeaderPipe</span>\r\n        <span class=\"id\">not_found_handler</span> <span class=\"pn\">(</span><span class=\"id\">text</span> <span class=\"s\">&quot;Other 404&quot;</span><span class=\"pn\">)</span>\r\n\r\n        <span class=\"id\">get</span> <span class=\"s\">&quot;/&quot;</span> <span class=\"id\">otherHelloWorld</span>\r\n        <span class=\"id\">get</span> <span class=\"s\">&quot;/a&quot;</span> <span class=\"id\">otherHelloWorld2</span>\r\n    <span class=\"pn\">}</span><span class=\"pn\">)</span>\r\n\r\n    <span class=\"c\">// or can be defined separatly and used as HttpHandler</span>\r\n    <span class=\"id\">forward</span> <span class=\"s\">&quot;/api&quot;</span> <span class=\"id\">apiRouter</span>\r\n\r\n    <span class=\"c\">// same with controllers</span>\r\n    <span class=\"id\">forward</span> <span class=\"s\">&quot;/users&quot;</span> <span class=\"id\">userController</span>\r\n<span class=\"pn\">}</span>\r\n</code></pre></td>\r\n</tr>\r\n</table>\r\n<div class=\"tip\" id=\"fs1\">val topRouter : obj</div>\r\n\r\n \n Delete <p>Adds handler for <code>DELETE</code> request.</p>\r\n\r\n DeleteF <p>Adds handler for <code>DELETE</code> request.</p>\r\n\r\n Forward <p>Forwards calls to different list of <code>Endpoint</code>.</p>\r\n\r\n Forward <p>Forwards calls to different <code>Endpoint</code>.</p>\r\n\r\n Get <p>Adds handler for <code>GET</code> request.</p>\r\n\r\n GetF <p>Adds handler for <code>GET</code> request.</p>\r\n\r\n Patch <p>Adds handler for <code>PATCH</code> request.</p>\r\n\r\n PatchF <p>Adds handler for <code>PATCH</code> request.</p>\r\n\r\n PipeThrough <p>Adds pipeline to the list of pipelines that will be used for every request</p>\r\n\r\n Post <p>Adds handler for <code>POST</code> request.</p>\r\n\r\n PostF <p>Adds handler for <code>POST</code> request.</p>\r\n\r\n Put <p>Adds handler for <code>PUT</code> request.</p>\r\n\r\n PutF <p>Adds handler for <code>PUT</code> request.</p>\r\n\r\n Run  Yield "},{"uri":"https://saturnframework.org/reference/Saturn/saturn-endpoint-router-routerstate.html","title":"RouterState","content":"RouterState \n <p>Type representing internal state of the <code>router</code> computation expression</p>\r\n\r\n \n Routes  RoutesF  Forawrds  Pipelines "},{"uri":"https://saturnframework.org/explanations/directory-structure.html","title":"Directory Structure","content":"\r\n# Directory Structure\r\n\r\nAfter creating a new Saturn project, let's take a deeper look into what files are created.\r\n\r\n```bash\r\n├── .fake\r\n├── .paket\r\n├── .vs\r\n├── .packages\r\n├── paket-files\r\n├── src\r\n|   ├── Migrations\r\n|   └── SaturnSample\r\n├── .gitignore\r\n├── build.fsx\r\n├── global.json\r\n├── paket.dependencies\r\n├── paket.lock\r\n└── SaturnSample.sln\r\n```\r\n\r\nAt this level most of it is basic configuration files to help with running Saturn. From looking at the `.paket`, `paket-files`, `paket.dependencies`, `paket.lock` folders and files, you can see that by default Saturn uses [paket](https://fsprojects.github.io/Paket/) to handle package management. You won't be working with these files directly but rather through the command line tools instead.\r\n\r\nSaturn also uses [FAKE](https://fake.build/) to build the project. You can see how it is set up by looking at the `.fake` folder and `build.fsx` file.\r\n\r\nSaturn also provides a `.gitignore` file that prevents some folders from being tracked by git when they don't need to.\r\n\r\nLastly, there is the `SaturnSample.sln` solution file so you can open the project in an IDE like Visual Sudio and a `global.json` file to configure the solution file.\r\n\r\n### Project structure\r\n\r\nMost of the work you will do in this project however, will be in `src/SaturnSample`, which looks like the following when expanded:\r\n\r\n```bash\r\n  ├── bin\r\n  ├── Books\r\n  |   ├── BooksController.fs\r\n  |   ├── BooksModel.fs\r\n  |   ├── BooksRepository.fs\r\n  |   └── BooksView.fs\r\n  ├── obj\r\n  ├── static\r\n  |   ├── app.css\r\n  |   └── app.js\r\n  ├── Templates\r\n  |   ├── App.fs\r\n  |   ├── Index.fs\r\n  |   ├── InternalError.fs\r\n  |   └── NotFound.fs\r\n  ├── Config.fs\r\n  ├── Database.fs\r\n  ├── database.sqlite\r\n  ├── paket.references\r\n  ├── Program.fs\r\n  ├── Router.fs\r\n  └── SaturnSample.fsproj\r\n```\r\n\r\n`bin` and `obj` folders store the compiled version of the program after you build the project.\r\n\r\nThe convention for Saturn is that the model and everything associated with it are inside one folder. Everything is also named with the plural form of the model so \"Books\" instead of \"Book\".\r\n\r\nYour static files like css, js, and images should be inside the `static` folder.\r\n\r\n`Config.fs` contains a `Config` record that stores settings that you can use inside your application. By default, the record only contains the `connectionString` field.\r\n\r\n`Database.fs` contains functions to execute SQL queries within the program through [Dapper](https://stackexchange.github.io/Dapper/).\r\n\r\nIf you did not run `dotnet saturn migration` as in the [how to start guide](../tutorials/how-to-start.html), you might not see `database.sqlite`, but that is the database file that your Saturn project is using to store data.\r\n\r\n`paket.references` shows the packages that your project is using.\r\n\r\n`Program.fs` handles intializing the program and loading up various settings.\r\n\r\n`Router.fs` is where you will set the route of the site and what page to load.\r\n\r\nLastly, `SaturnSample.fsproj` is the project file itself."},{"uri":"https://saturnframework.org/explanations/endpoint-routing.html","title":"Endpoint Routing","content":"\r\n# Endpoint Routing\r\n\r\nSaturn from version `0.15` supports [ASP.NET Endpoint Routing](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1) additionally to custom routing implementation provided by Giraffe. The main difference between old routing and new one is that Endpoint Routing assumes total separation of routing from behavior - it works by statically defining list of all possible routes on startup of application. This impacts design of some of our Saturn abstractions, and means new routing is not 100% compatible with old one. On the bright side, theoretically, Endpoint Routing should provide noticeable performance boost, and in the future it will allow for better ecosystem integration.\r\n\r\n> Currently endpoint routing API is treated as an experimental API - it's subject to changes.\r\n\r\nTo use Endpoint Routing you need to open `Saturn.Endpoint` namespace - this will override known `router` and `controller` Computation Expressions with their Endpoint Routing versions. In `application` CE instead of using `use_router` operation you should use `use_endpoint_router` operation. For many simple applications this may be enough to get things working - we've been trying to keep API as compatible as possible.\r\n\r\nHowever there are differences:\r\n\r\n* With Endpoint Routing `router` and `controller` computation expressions are not transformed to `HttpHandler` but rather to `Endpoint list`. This has a huge impact on composability of those abstractions - you can't do things like `myHttpHandler >=> router { ... }` any more. Such code should be replaced with `plug/pipe_through` functionality in both `router` and `controller`. `Endpoint list` can basically be used in 2 places - in `forward` operation in `router` and `use_endpoint_router` in `application`.\r\n* Lack of `subroutef` in Giraffe-EndpointRouting - beacuse EndpointRouting needs to have all possible route templates at the application startup it's really hard to emulate some of previous Giraffe's routing composibility capabilities. From Saturn point of view this created 2 major changes:\r\n  - there's no `forwardf` in `router` CE anymore - it should be replaced with set of `getf/postf/putf ... ` operations in child router.\r\n  - `subController` in `controller` CE doesn't work well in Endpoint Routing - you can use as subcontrollers only old, HttpHandler based controllers (even if you parent controller is Endpoint Routing controller). In `Saturn.Endpoint` we provide additonal `subcontroller` CE - it's an alias to old `controller` CE\r\n* Lack of `case_insensitive` in `router` and `controller` - with Endpoint Routing all routes are case insensitive by default and there's no easy way to change it\r\n* Lack of `not_found_handler` in `router` and `controller` - as Endpoint Routing creates global table of routing having scoped not-found handlers is really tricky. Use built-in ways of handle 404 in ASP.NET (such as `UseDeveloperExceptionPage`)\r\n* Unlike Giraffe routing, Endpoint Routing doesn't ensure order of routing checks - this shouldn't be a problem in most cases, but I can imagine some edge cases in which this would matter.\r\n\r\nIn general, to reiterate - Endpoint Routing API in Giraffe/Saturn is still experimental. However, it probably is a future of Giraffe/Saturn so if possible please check if your applications can move to the Endpoint Routing API, and try it out. It's important for everyone involved to get feedback on this new routing engine."},{"uri":"https://saturnframework.org/explanations/overview.html","title":"Saturn Overview","content":"\r\n# Saturn Overview\r\n\r\nSaturn is a web development framework written in F# which implements the server-side MVC pattern. Many of its components and concepts will seem familiar to those of us with experience in other web frameworks like Ruby on Rails or Python’s Django. It's heavily inspired by Elixir's [Phoenix](http://phoenixframework.org/).\r\n\r\nBuilt on top of the battle-tested ASP.NET Core foundation and the highly flexible, extendable model of Giraffe, Saturn provides high level abstractions, helpers and tools to enable high developer productivity, at the same time keeping high application performance provided by Kestrel and Giraffe.\r\n\r\nSaturn is made up of a number of distinct parts, each with its own purpose and role to play in building a web application.\r\n\r\n - Application\r\n    - the start and end of the request life cycle\r\n    - handles all aspects of requests up until the point where the router takes over\r\n    - provides a core set of plugs to apply to all requests\r\n    - dispatches requests into a router\r\n    - enables application and hosting configuration\r\n - [Router](routing.html)\r\n    - parses incoming requests and dispatches them to the correct controller/action, passing parameters as needed\r\n    - provides helpers to generate route paths or urls to resources\r\n    - defines named pipelines through which we may pass our requests\r\n    - allows easy application of groups of plugs to a set of routes\r\n - [Controllers](controller.html)\r\n    - provide functions, called *actions*, to handle requests\r\n    - actions:\r\n        - prepare data and pass it into views\r\n        - invoke rendering via views\r\n        - perform redirects\r\n        - return data as JSON or XML\r\n        - and much more\r\n - [Views](view.html)\r\n    - render templates\r\n    - act as a presentation layer\r\n    - define helper functions, available in templates, to decorate data for presentation\r\n - Channels\r\n    - manage sockets for easy realtime communication\r\n    - are analogous to controllers except that they allow bi-directional communication with persistent connections\r\n - [Scaffolding scripts](scaffolding.html)\r\n    - `dotnet new` template providing good starting point for new applications - [https://github.com/SaturnFramework/Saturn.Template](https://github.com/SaturnFramework/Saturn.Template)\r\n    - `dotnet saturn` CLI tool that controls migrations and let you easily scaffold new parts of application - [https://github.com/SaturnFramework/Saturn.Dotnet](https://github.com/SaturnFramework/Saturn.Dotnet)\r\n\r\n\r\n### Saturn rings\r\n\r\nSaturn itself is the top layer of a multi-layer system designed to create a flexible, productive environment for creating web applications.\r\n\r\n#### Kestrel and ASP.NET Core\r\n\r\nASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-based, Internet-connected applications. Kestrel is a cross-platform web server for ASP.NET Core based on `libuv`, a cross-platform asynchronous I/O library. ASP.NET Core documentation can be found [here](https://docs.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-3.1)\r\n\r\n#### [Giraffe](https://github.com/giraffe-fsharp/Giraffe)\r\n\r\nGiraffe is an F# micro web framework for building rich web applications. It has been heavily inspired and is similar to [Suave](https://suave.io), but has been specifically designed with ASP.NET Core in mind and can be plugged into the ASP.NET Core pipeline via middleware. Giraffe applications are composed of so-called HttpHandler functions which can be thought of as a mixture of Suave's WebParts and ASP.NET Core's middleware. As Saturn shares many basic helper functions with Giraffe it's highly recommended to also check out [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n\r\n### Saturn moons\r\n\r\nSaturn is not only a library building on top of Giraffe, but also a set of opinionated tooling for scaffolding a whole project and then generating some boilerplate code. At the moment our template is using (by default):\r\n\r\n#### [Dapper](https://github.com/StackExchange/Dapper)\r\n\r\nA simple, focused on performance object mapper for .Net that you can add in to your project and will extend your `IDbConnection` interface.\r\n\r\n#### [Simple.Migrations](https://github.com/canton7/Simple.Migrations)\r\n\r\nSimple.Migrations is a simple bare-bones migration framework for .NET Core (.NET Standard 1.2 and .NET 4.5). It doesn't provide SQL generation, nor an out-of-the-box command-line tool, nor any other fancy feature. It does however provide a set of simple, extendable, and composable tools for integrating migrations into your application.\r\n\r\n\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/scaffolding.html","title":"Scaffolding","content":"\r\n# Scaffolding\r\n\r\nSaturn provides a command line scaffolding tool to generate a model, database migration, controller, and associated views.\r\n\r\nTo use the generator, run the `dotnet saturn` command from the root of your application application.  If you have used the template to generate your project, this is the directory with `build.fsx` or `paket.dependencies` file.\r\n\r\nThere are three flavors of generators that provide flexibility about what types of code is generated to support your model.\r\n\r\n| Command      |  Generates                                                                     |\r\n|--------------|--------------------------------------------------------------------------------|\r\n| gen          | Creates a model, database layer, HTML views, and a controller.                 |\r\n| gen.json     | Creates a model, database layer, and an API controller to access the model.    |\r\n| gen.model    | Creates only the model and database layer (no controller or views)             |\r\n\r\nEach of these commands will generate a migration for your model as well as a folder containing generated files.\r\n\r\nFor example:\r\n\r\n`dotnet saturn gen Book Books id:string title:string`\r\n\r\nGenerates the following structure:\r\n\r\n```bash\r\nsrc\r\n├── Migrations\r\n│   └── 201903192143.Book.fs\r\n│\r\n└── SaturnSample\r\n    └── Books\r\n        ├── BooksController.fs\r\n        ├── BooksModel.fs\r\n        ├── BooksRepository.fs\r\n        └── BooksViews.fs\r\n```\r\n\r\nEach of the generators takes arguments in the same format:\r\n\r\n`dotnet saturn gen <SingularModelName> <PluralModelName> <List of model fields with types>`\r\n\r\nThe list of model fields are names and types separated by a colon.\r\n\r\n`<fieldname>:<type>`\r\n\r\nCurrently supported types are:\r\n\r\n* string\r\n* int\r\n* float\r\n* double\r\n* decimal\r\n* guid\r\n* datetime\r\n* bool\r\n\r\n## Migrations\r\n\r\nUsing the generator to create a model will also create a migration file that will create a supporting table in the database. Execute the migration script using:\r\n\r\n`dotnet saturn migration`"},{"uri":"https://saturnframework.org/explanations/view.html","title":"View Engine","content":"\r\n# View Engine\r\n\r\n> This post has been originally part of the [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine)\r\n\r\nSaturn is built on top of Giraffe and can use any helpers it provides. This is a case for suggested view engine that you can use in Saturn - Giraffe has its own functional view engine which can be used to build rich UIs for web applications. The single biggest and best contrast to other view engines (e.g. Razor, Liquid, etc.) is that the Giraffe View Engine is entirely functional written in normal (and compiled) F# code.\r\n\r\nThis means that the Giraffe View Engine is by definition one of the most feature rich view engines available, requires no disk IO to load a view and views are automatically compiled at build time.\r\n\r\nThe Giraffe View Engine uses traditional functions and F# record types to generate rich HTML/XML views.\r\n\r\n### HTML Elements and Attributes\r\n\r\nHTML elements and attributes are defined as F# objects:\r\n\r\n```fsharp\r\nlet indexView =\r\n    html [] [\r\n        head [] [\r\n            title [] [ str \"Giraffe Sample\" ]\r\n        ]\r\n        body [] [\r\n            h1 [] [ str \"I |> F#\" ]\r\n            p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                str \"Hello World\"\r\n            ]\r\n        ]\r\n    ]\r\n```\r\n\r\nA HTML element can either be a `ParentNode`, a `VoidElement` or a `Text` element.\r\n\r\nFor example the `<html>` or `<div>` tags are typical `ParentNode` elements. They can hold an `XmlAttribute list` and a second `XmlElement list` for their child elements:\r\n\r\n```fsharp\r\nlet someHtml = div [] []\r\n```\r\n\r\nAll `ParentNode` elements accept these two parameters:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [ _id \"someId\"; _class \"css-class\" ] [\r\n        a [ _href \"https://example.org\" ] [ str \"Some text...\" ]\r\n    ]\r\n```\r\n\r\nMost HTML tags are `ParentNode` elements, however there is a few HTML tags which cannot hold any child elements, such as `<br>`, `<hr>` or `<meta>` tags. These are represented as `VoidElement` objects and only accept the `XmlAttribute list` as single parameter:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        br []\r\n        hr [ _class \"css-class-for-hr\" ]\r\n        p [] [ str \"bla blah\" ]\r\n    ]\r\n```\r\n\r\nAttributes are further classified into two different cases. First and most commonly there are `KeyValue` attributes:\r\n\r\n```fsharp\r\na [\r\n    _href \"http://url.com\"\r\n    _target \"_blank\"\r\n    _class \"class1\" ] [ str \"Click here\" ]\r\n```\r\n\r\nAs the name suggests, they have a key, such as `class` and a value such as the name of a CSS class.\r\n\r\nThe second category of attributes are `Boolean` flags. There are not many but some HTML attributes which do not require any value (e.g. `async` or `defer` in script tags). The presence of such an attribute means that the feature is turned on, otherwise it is turned off:\r\n\r\n```fsharp\r\nscript [ _src \"some.js\"; _async ] []\r\n```\r\n\r\nThere's also a wealth of [accessibility attributes](https://www.w3.org/TR/html-aria/) available under the `Giraffe.GiraffeViewEngine.Accessibility` module (needs to be explicitly opened).\r\n\r\n### Text Content\r\n\r\nNaturally the most frequent content in any HTML document is pure text:\r\n\r\n```html\r\n<div>\r\n    <h1>This is text content</h1>\r\n    <p>This is even more text content!</p>\r\n</div>\r\n```\r\n\r\nThe Giraffe View Engine lets one create pure text content as a `Text` element. A `Text` element can either be generated via the `rawText` or `encodedText` (or the short alias `str`) functions:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        p [] [ rawText \"<div>Hello World</div>\" ]\r\n        p [] [ encodedText \"<div>Hello World</div>\" ]\r\n    ]\r\n```\r\n\r\nThe `rawText` function will create an object of type `XmlNode` where the content will be rendered in its original form and the `encodedText`/`str` function will output a string where the content has been HTML encoded.\r\n\r\nIn this example the first `p` element will literally output the string as it is (`<div>Hello World</div>`) while the second `p` element will output the value as HTML encoded string `&lt;div&gt;Hello World&lt;/div&gt;`.\r\n\r\nPlease be aware that the the usage of `rawText` is mainly designed for edge cases where someone would purposefully want to inject HTML (or JavaScript) code into a rendered view. If not used carefully this could potentially lead to serious security vulnerabilities and therefore should be used only when explicitly required.\r\n\r\nMost cases and particularly any user provided content should always be output via the `encodedText`/`str` function.\r\n\r\n### Javascript event handlers\r\n\r\nIt is possible to add JavaScript event handlers to HTML elements using the Giraffe View Engine.  These event handlers (all prefixed with names starting with `_on`, for example `_onclick`, `_onmouseover`) can either execute inline JavaScript code or can invoke functions that are part of the `window` scope.\r\n\r\nThis example illustrates how inline JavaScript could be used to log to the console when a button is clicked:\r\n\r\n```fsharp\r\nlet inlineJSButton =\r\n    button [_id \"inline-js\"\r\n            _onclick \"console.log(\\\"Hello from the 'inline-js' button!\\\");\"] [str \"Say Hello\" ]\r\n```\r\n\r\nThere are some caveats with this approach, namely that\r\n* it is not very scalable to write JavaScript inline in this manner, and more pressing\r\n* the Giraffe View Engine HTML-encodes the text provided to the `_onX` attributes.\r\n\r\nTo get around this, you can write dedicated scripts in your HTML and reference the functions from your event handlers:\r\n\r\n```fsharp\r\nlet page =\r\n    div [] [\r\n        script [_type \"application/javascript\"] [\r\n            rawText \"\"\"\r\n            window.greet = function () {\r\n                console.log(\"ping from the greet method\");\r\n            }\r\n            \"\"\"\r\n        ]\r\n        button [_id \"script-tag-js\"\r\n                _onclick \"greet();\"] [str \"Say Hello\"]\r\n    ]\r\n```\r\n\r\nHere it's important to note that we've included the text of our script using the `rawText` tag.  This ensures that our text is not encoded by Giraffe so that it remains as we have written it.\r\n\r\nHowever, writing large quantities of JavaScript in this manner can be difficult, because you don't have access to the large ecosystem of javascript editor tooling.  In this case you should write your functions in another script and use a `script` tag element to reference your script, then add the desired function to your HTML element's event handler.\r\n\r\nSay you had a JavaScript file named `greet.js` and had configured Giraffe to serve that script from the WebRoot. Let us also say that the content of that script was:\r\n\r\n```javascript\r\nfunction greet() {\r\n    console.log(\"Hello from the greet function of greet.js!\");\r\n}\r\n```\r\n\r\nThen, you could reference that javascript via a script element, and use `greet` in your event handler like so:\r\n\r\n```fsharp\r\nlet page =\r\n    html [] [\r\n        head [] [\r\n            script [_type \"application/javascript\"\r\n                    _src \"/greet.js\"] [] // include our `greet.js` function dynamically\r\n        ]\r\n        body [] [\r\n            button [_id \"greet-btn\"\r\n                    _onclick \"greet()\"] [] // use the `greet()` function from `greet.js` to say hello\r\n        ]\r\n    ]\r\n```\r\n\r\nIn this way, you can write `greet.js` with all of your expected tooling, and still hook up the event handlers all in one place in Giraffe.\r\n\r\n### Naming Convention\r\n\r\nThe Giraffe View Engine has a naming convention which lets you easily determine the correct function name without having to know anything about the view engine's implementation.\r\n\r\nAll HTML tags are defined as `XmlNode` elements under the exact same name as they are named in HTML. For example the `<html>` tag would be `html [] []`, an `<a>` tag would be `a [] []` and a `<span>` or `<canvas>` would be the `span [] []` or `canvas [] []` function.\r\n\r\nHTML attributes follow the same naming convention except that attributes have an underscore prepended. For example the `class` attribute would be `_class` and the `src` attribute would be `_src` in Giraffe.\r\n\r\nThe underscore does not only help to distinguish an attribute from an element, but also avoid a naming conflict between tags and attributes of the same name (e.g. `<form>` vs. `<input form=\"form1\">`).\r\n\r\nIf a HTML attribute has a hyphen in the name (e.g. `accept-charset`) then the equivalent Giraffe attribute would be written in camel case notion (e.g. `acceptCharset`).\r\n\r\n*Should you find a HTML tag or attribute missing in the Giraffe View Engine then you can either [create it yourself](#custom-elements-and-attributes) or send a [pull request on GitHub](https://github.com/giraffe-fsharp/Giraffe/pulls).*\r\n\r\n### View Engine Best Practices\r\n\r\nDue to the huge amount of available HTML tags and their fairly generic (and short) names (e.g. `<form>`, `<option>`, `<select>`, etc.) there is a significant danger of accidentally overriding a function of the same name in an application's codebase. For that reason the Giraffe View Engine becomes only available after opening the `GiraffeViewEngine` module.\r\n\r\nAs a measure of good practice it is recommended to create all views in a separate module:\r\n\r\n```fsharp\r\nmodule MyWebApplication\r\n\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let index =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str \"Giraffe Sample\" ]\r\n            ]\r\n            body [] [\r\n                h1 [] [ str \"I |> F#\" ]\r\n                p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                    str \"Hello World\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let other = //...\r\n```\r\n\r\nThis ensures that the opening of the `GiraffeViewEngine` is only contained in a small context of an application's codebase and therefore less of a threat to accidental overrides. In the above example views can always be accessed through the `Views` sub module (e.g. `Views.index`).\r\n\r\n### Custom Elements and Attributes\r\n\r\nAdding new elements or attributes is normally as simple as a single line of code:\r\n\r\n```fsharp\r\nopen Giraffe.GiraffeViewEngine\r\n\r\n// If there was a new <foo></foo> HTML element:\r\nlet foo = tag \"foo\"\r\n\r\n// If <foo> is an element which cannot hold any content then create it as voidTag:\r\nlet foo = voidTag \"foo\"\r\n\r\n// If <foo> has a new attribute called bar then create a new bar attribute:\r\nlet _bar = attr \"bar\"\r\n\r\n// if the bar attribute is a boolean flag:\r\nlet _bar = flag \"bar\"\r\n```\r\n\r\nAlternatively you can also create new elements and attributes from inside another element:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n```\r\n\r\n### Rendering Views\r\n\r\nRendering views in Giraffe is done through one of the following functions:\r\n\r\n- `renderHtmlDocument`\r\n- `renderHtmlNodes`\r\n- `renderHtmlNode`\r\n- `renderXmlNodes`\r\n- `renderXmlNode`\r\n\r\nThe Giraffe View Engine cannot only be used to render HTML views, but also for any other XML based content such as `<svg>` images or other arbitrary XML based data.\r\n\r\nThe `renderHtmlDocument` function takes a single `XmlNode` as input parameter and renders a HTML page with a `DOCTYPE` declaration. This function should be used for rendering a complete HTML document. The `WriteHtmlViewAsync` extension method and the `htmlView` http handler both use the `renderHtmlDocument` function under the covers.\r\n\r\nThe `renderHtmlNodes` function takes an `XmlNode list` as input parameter and will output a single HTML string containing all the rendered HTML code. The `renderHtmlNode` function renders a single `XmlNode` element into a valid HTML string. Both, the `renderHtmlNodes` and `renderHtmlNode` function are useful for use cases where a HTML snippet needs to be created without a `DOCTYPE` declaration (e.g. templated emails, etc.).\r\n\r\nThe `renderXmlNodes` and `renderXmlNode` function are identical to `renderHtmlNodes` and `renderHtmlNode`, except that they will render void elements differently:\r\n\r\n```fsharp\r\nlet someTag = voidTag \"foo\"\r\nlet someContent = someTag []\r\n\r\n// Void tag will be rendered to valid HTML: <foo>\r\nlet output1 = renderHtmlNode someContent\r\n\r\n// Void tag will be rendered to valid XML: <foo />\r\nlet output2 = renderXmlNode someContent\r\n```\r\n\r\nAll `GiraffeViewEngine` http handlers are using a thread static `StringBuilderPool` to avoid the creation of large `StringBuilder` objects for each render call and dynamically grow/shrink that pool based on the application's needs. However if the application is running into any memory issues then this performance feature can be disabled by setting `StringBuilderPool.IsEnabled <- false`.\r\n\r\nAdditionally with Giraffe 3.0.0 or higher there is a new module called `ViewBuilder` under the `Giraffe.GiraffeViewEngine` namespace. This module exposes additional view rendering functions which compile a view into a `StringBuilder` object instead of returning a single `string`:\r\n\r\n- `ViewBuilder.buildHtmlDocument`\r\n- `ViewBuilder.buildHtmlNodes`\r\n- `ViewBuilder.buildHtmlNode`\r\n- `ViewBuilder.buildXmlNodes`\r\n- `ViewBuilder.buildXmlNode`\r\n\r\nThe `ViewBuilder.build[...]` functions can be useful if there is additional string processing required before/after composing a view by the `GiraffeViewEngine` (e.g. embedding HTML snippets in an email template, etc.). These functions also serve as the lower level building blocks of the equivalent `render[...]` functions.\r\n\r\nExample usage:\r\n\r\n```fsharp\r\nopen System.Text\r\nopen Giraffe.GiraffeViewEngine\r\n\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n\r\nlet sb = new StringBuilder()\r\n\r\n// Perform actions on the `sb` object...\r\nsb.AppendLine \"This is a HTML snippet inside a markdown string:\"\r\n  .AppendLine \"\"\r\n  .AppendLine \"```html\" |> ignore\r\n\r\nlet sb' = ViewBuilder.buildHtmlNode sb someHtml\r\n\r\n// Perform more actions on the `sb` object...\r\nsb'.AppendLine \"```\" |> ignore\r\n\r\nlet markdownOutput = sb'.ToString()\r\n```\r\n\r\n### Common View Engine Features\r\n\r\nThe Giraffe View Engine doesn't have any specially built functions for commonly known features such as master pages or partial views, mainly because the nature of the view engine itself doesn't require it in most cases.\r\n\r\n#### Master Pages\r\n\r\nCreating a master page is a simple matter of piping two functions together:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n... or even have multiple nested master pages:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master1 (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let master2 (content: XmlNode list) =\r\n        [\r\n            main [] content\r\n            footer [] [\r\n                p [] [\r\n                    str \"Copyright ...\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master2 |> master1 pageTitle\r\n```\r\n\r\n#### Partial Views\r\n\r\nA partial view is nothing more than one function or object being called from within another function:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n#### Working with Models\r\n\r\nA view which accepts a model is basically a function with an additional parameter:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index (model : IndexViewModel) =\r\n        [\r\n            h1 [] [ str model.PageTitle ]\r\n            p [] [ str model.WelcomeText ]\r\n        ] |> master model.PageTitle\r\n```\r\n\r\n#### If Statements, Loops, etc.\r\n\r\nThings like if statements, loops and other normal F# language constructs work just as expected:\r\n\r\n```fsharp\r\nlet partial (books : Book list) =\r\n    ul [] [\r\n        yield!\r\n            books\r\n            |> List.map (fun b -> li [] [ str book.Title ])\r\n    ]\r\n```\r\n\r\nOverall the Giraffe View Engine is extremely flexible and feature rich by nature based on the fact that it is generated via normal compiled F# code."},{"uri":"https://saturnframework.org/tutorials/adding-pages.html","title":"Adding Pages","content":"\r\n# Adding Pages\r\n\r\nThis guide uses the same project from the [how to start guide](how-to-start.html). Let's add two pages to it - one hello page and a page that can get your name from the URL.\r\n\r\n## Creating the View\r\n\r\nTo begin, create a `Hello` folder inside the `src/SaturnSample` folder.\r\n\r\nInside the folder, create a new file called \"HelloViews.fs\". This file will contain the functions to create the page.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Giraffe.GiraffeViewEngine\r\nopen Saturn\r\n\r\nmodule Views =\r\n  let index =\r\n    div [] [\r\n        h2 [] [rawText \"Hello from Saturn!\"]\r\n    ]\r\n```\r\n\r\nOne of the dependencies required is [Giraffe View Engine](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine). This will allow your project to define HTML within your function. The `index` function will result in the following HTML code:\r\n\r\n```html\r\n<div>\r\n    <h2>Hello from Saturn!</h2>\r\n</div>\r\n```\r\n\r\n## Creating the Controller\r\n\r\nCreate a `HelloController.fs` file inside the `Hello` folder.\r\n\r\nThe `index` function tells us what the HTML will be but we still need to tell Saturn to return it as an HTML page. We also need to tell Saturn where the page is.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Saturn\r\nopen Giraffe.ResponseWriters\r\n\r\nmodule Controller =\r\n    let indexAction =\r\n        htmlView (Views.index)\r\n\r\n    let helloView = router {\r\n        get \"/\" indexAction\r\n    }\r\n```\r\n\r\nThe `indexAction` tells Saturn to create an HTML page using the `index` function inside \"HelloViews.fs\"\r\n\r\n`helloView` lets Saturn know that the page is located at the root.\r\n\r\n## Adding the 2 new files to the project\r\n\r\nFor the project to see the new files, modify SaturnSample.fsproj as below:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <Compile Include=\"Database.fs\" />\r\n    <Compile Include=\"Config.fs\" />\r\n\r\n    <Compile Include=\"Hello\\HelloViews.fs\" />\r\n    <Compile Include=\"Hello\\HelloController.fs\" />\r\n    ...\r\n```\r\n\r\n## Adding it to Router.fs\r\n\r\n\r\nAfter setting up the route, you need to update the project with the new route.\r\n\r\nIn \"Router.fs\", add the following to the inside of the `browserRouter` function:\r\n\r\n\r\n```fsharp\r\nforward \"/hello\" Hello.Controller.helloView\r\n```\r\n\r\nThis means that when we navigate to [http://localhost:8085/hello](http://localhost:8085/hello), the `helloView` function will determine what page to load there. Looking inside the `helloView` function, we said that `indexAction` is called at the root. In conclusion, the page will be located at [http://localhost:8085/hello/](http://localhost:8085/hello/). (Note the \"/\" at the end)\r\n\r\nNow run the program and go to [http://localhost:8085/hello/](http://localhost:8085/hello/) and you will see a page saying \"Hello from Saturn!\"\r\n\r\n## Sending a parameter to your page\r\n\r\nWhat if you want the page to display your name?\r\n\r\nOne way to retrieve your name is to get it from the route. So when you go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) with {yourname} being your actual name, it will grab your name which can then be used to display on the page.\r\n\r\nTo begin, add a new view in your `HelloViews.fs`:\r\n\r\n```fsharp\r\n  let index2 (name : string) =\r\n    div [] [\r\n        h2 [] [rawText (\"Hello \" + name + \"!\")]\r\n    ]\r\n```\r\n\r\nThis function requires passing in the name to be displayed. The name will be retrieved from the route.\r\n\r\nAdd the following to the `HelloController.fs` file below the `helloView` handler:\r\n\r\n```fsharp\r\nlet index2Action name=\r\n    htmlView (Hello.Views.index2 name)\r\n```\r\n\r\nNow to set up the route. Add the following to the `HelloView` handler:\r\n\r\n```fsharp\r\ngetf \"/%s\" index2Action\r\n```\r\n\r\n\"%s\" is a format string. This lets Saturn know to save whatever you type in that spot. Since we want to save a name, we want to save it as a string so we use `%s`.\r\n\r\nThere are other format strings for different types:\r\n\r\n| Format String | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nNow run the program and go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) and replace `{yourname}` with your name to see a page that will greet you.\r\n"},{"uri":"https://saturnframework.org/tutorials/adding-saturn-to-an-existing-giraffe-app.html","title":"Adding Saturn to an existing Giraffe application","content":"\r\n# Adding Saturn to an existing Giraffe application\r\n\r\nThe previous chapter showed how to get started with a new application.\r\n\r\nIf you already have a working Giraffe webserver, you can gradually opt-in to Saturn.\r\n\r\nFor example, if your existing app looks like this:\r\n\r\n```fsharp\r\n\r\ntype Customer = {\r\n    Name : string\r\n    Address : string\r\n}\r\n\r\nlet customers =\r\n    choose [\r\n      GET >=> (json { Name = \"Mr. Smith\"; Address = \"Santa Monika\"})\r\n      PUT >=> (bindJson<Customer> (fun customer -> printfn \"Adding customer %A\" customer; setStatusCode 200))\r\n    ]\r\n\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"               >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n    ]\r\n```\r\n\r\nand you need to add \"vendor\" functionality, you could implement it as a Saturn ``router`` while keeping everything else intact:\r\n\r\n\r\n```fsharp\r\n// the new Saturn router\r\nlet vendors = router {\r\n    getf \"/%i\" (fun vendorId -> (json (readVendorFromDb vendorId)))\r\n    post \"/\" (bindJson<Vendor> (fun customer -> addVendor vendor; setStatusCode 200))\r\n}\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"                >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n        // plug the new Saturn router into the Giraffe app\r\n        route \"/api/vendors\"     >=> vendors\r\n    ]\r\n```\r\n\r\n## Embedding Giraffe Handlers into Saturn\r\n\r\nOf course the other way around also works.\r\n\r\nFor example, [Elmish.Bridge](https://github.com/Nhowka/Elmish.Bridge) does not provide a specialized implementation for Saturn. And it doesn't need to, because we can just use the Giraffe implementation!\r\n\r\n```fsharp\r\n\r\nopen Elmish\r\nopen Elmish.Bridge\r\n\r\nlet elmishBridgeHandler : HttpHandler =\r\n  Bridge.mkServer Shared.endpoint init update\r\n  |> Bridge.run Giraffe.server\r\n\r\n// our existing Saturn router\r\nlet router = router {\r\n\r\n    // ...\r\n\r\n    forward \"\" elmishBridgeHandler\r\n}\r\n```\r\n"},{"uri":"https://saturnframework.org/tutorials/how-to-start.html","title":"Getting started","content":"\r\n# How to start in 60 seconds\r\n\r\nRequirements:\r\n\r\n* `dotnet` SDK 3.1 [https://dotnet.microsoft.com/download/dotnet-core/3.1](https://dotnet.microsoft.com/download/dotnet-core/3.1)\r\n\r\n## Template\r\n\r\nThe easiest way to get started is to use the provided template:\r\n\r\n1. Install the `dotnet` template with `dotnet new -i Saturn.Template`\r\n2. Create a new folder and move into it - `mkdir SaturnSample && cd SaturnSample`\r\n3. Create a new Saturn application - `dotnet new saturn -lang F#`\r\n4. Install all necessary dev tools - `dotnet tool restore`\r\n6. Create a new controller with `dotnet saturn gen Book Books id:string title:string author:string`\r\n7. Run migrations that will create the database and Books table (as for now, the generator is using only SQLite DB) - `dotnet saturn migration`\r\n8. Open the folder in your favourite editor (VSCode) and insert the line (`forward \"/books\" Books.Controller.resource`) into `browserRouter` in `Router.fs` file\r\n9. Start the application by running `dotnet fake build -t run` from the root of the solution. This will start the application in watch mode (automatic recompilation on changes) and open your browser on [http://localhost:8085](http://localhost:8085) which should display the index page.\r\n10. Go to [http://localhost:8085/books](http://localhost:8085/books) to see the generated view. All buttons should be working; you can add new entries, and remove or edit old ones.\r\n\r\n\r\n## Hello World\r\n\r\nIf you want to start from scratch with a minimal Saturn webserver:\r\n\r\n1. Create a new F# Project (for example with `dotnet new console -lang F#`)\r\n2. Add the `Saturn` NuGet Package\r\n\r\n```fsharp\r\nopen Saturn\r\nopen Giraffe\r\n\r\nlet app = application {\r\n    use_router (text \"Hello World from Saturn\")\r\n}\r\n\r\nrun app\r\n```\r\n\r\nIf you compile and run this application, it will unconditionally return the text regardless of the path.\r\n\r\nFrom here on out you can add [routers](../explanations/routing.html), [controllers](../explanations/controller.html) and [views](../explanations/view.html).\r\n\r\n## Deep Dive\r\n\r\nTo get a better understanding of Saturn and the whole SAFE Stack you can look at the [SAFE-Dojo](https://github.com/CompositionalIT/SAFE-Dojo).\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/controller.html","title":"Controllers","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Controller\r\n\r\nIn Saturn, a **controller** is a list of routes that is focused on a **model** (an object that contains your data). So if you have a user model, some common operations are to display the list of users, show details of a user, add a user, update or user, or remove a user. A controller is a great way to organize all of these actions.\r\n\r\nEach of the operations is a separate route and a controller is an easy way to group these routes together.\r\n\r\nA basic user controller is shown below:\r\n\r\n*)\r\nopen Saturn\r\n\r\nlet userController = controller {\r\n    index (fun ctx -> \"Index handler version 1\" |> Controller.text ctx) //View list of users\r\n    add (fun ctx -> \"Add handler version 1\" |> Controller.text ctx) //Add a user\r\n    create (fun ctx -> \"Create handler version 1\" |> Controller.text ctx) //Create a user\r\n    show (fun ctx id -> (sprintf \"Show handler version 1 - %i\" id) |> Controller.text ctx) //Show details of a user\r\n    edit (fun ctx id -> (sprintf \"Edit handler version 1 - %i\" id) |> Controller.text ctx)  //Edit a user\r\n    update (fun ctx id -> (sprintf \"Update handler version 1 - %i\" id) |> Controller.text ctx)  //Update a user\r\n}\r\n\r\n(**\r\nHere we can see the `index`, `add`, `create`, `show`, `edit`, and `update` operations but there are more operations that are not shown here like `patch` and `delete`. You can see all the operations int the [API Reference](../reference/Saturn/saturn-controller-controllerbuilder-10.html). You do not have to handle all of the operations.\r\n\r\nYou might be wondering what the difference is between `add` and `create` or `edit` and `update`. The `add` operation tells the application to return the form so that the user can enter the data for the user to be added. The `create` operation will commit the data to the database of the application. It is the same with `edit` for displaying the form and `update` for committing the change.\r\n\r\nTo add the controller for the routes, you can add it to the `defaultView` router like so:\r\n\r\n*)\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n    forward \"/users\" userController\r\n}\r\n\r\n(**\r\nThe route will now be:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            ├── \"/default.html\"     -redirect to yoursite.com/\r\n            └── \"/users\"\r\n                ├── index \"/\"           -yoursite.com/users/\r\n                ├── add \"/add\"          -yoursite.com/users/add\r\n                ├── create              -POST yoursite.com/users/add\r\n                ├── show \"/%i\"          -yoursite.com/users/%i\r\n                ├── edit \"/%i/edit\"     -yoursite.com/users/%i/edit\r\n                └── update \"\"           -POST yoursite.com/users/%i/edit\r\n```\r\n\r\nThe create and update operations make changes to the database so you have to make a POST request containing the information you want to save to the database.\r\n\r\n## Subcontroller\r\n\r\nNow that you know how to chain routers together to create routes, we can look at a common scenario for a website. A website usually has users and each user can create multiple comments.\r\n\r\n```bash\r\nyoursite.com\r\n└── \"/users\"\r\n    └── \"/%i\"           -yoursite.com/users/%i\r\n        └── \"/comments\" (commentController)\r\n            ├── index \"/\"           -yoursite.com/users/{userId}/comments/\r\n            └── show \"/%i\"          -yoursite.com/users/{userId}/comments/{commentId}\r\n```\r\n\r\nIn Saturn, you can make the comment controller a subcontroller of the user controller. It looks like the following code:\r\n\r\n*)\r\n\r\nlet commentController userId = controller {\r\n    index (fun ctx -> (sprintf \"Comment Index handler for user %i\" userId ) |> Controller.text ctx)\r\n    add (fun ctx -> (sprintf \"Comment Add handler for user %i\" userId ) |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show comment %s handler for user %i\" id userId ) |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit comment %s handler for user %i\" id userId )  |> Controller.text ctx)\r\n}\r\n\r\nlet userController = controller {\r\n    subController \"/comments\" commentController\r\n\r\n    plug [All] (setHttpHeader \"user-controller-common\" \"123\")\r\n    plug [Index; Show] (setHttpHeader \"user-controller-specialized\" \"123\")\r\n\r\n    index (fun ctx -> \"Index handler no version\" |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show handler no version - %i\" id) |> Controller.text ctx)\r\n    add (fun ctx -> \"Add handler no version\" |> Controller.text ctx)\r\n    create (fun ctx -> \"Create handler no version\" |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit handler no version - %i\" id) |> Controller.text ctx)\r\n    update (fun ctx id -> (sprintf \"Update handler no version - %i\" id) |> Controller.text ctx)\r\n    delete (fun ctx id -> failwith (sprintf \"Delete handler no version failed - %i\" id) |> Controller.text ctx)\r\n    error_handler (fun ctx ex -> sprintf \"Error handler no version - %s\" ex.Message |> Controller.text ctx)\r\n}\r\n\r\n(**\r\n\r\nTo create a subcontroller, start with creating a controller for your model. After that, define it as a subcontroller inside the main controller with the following code:\r\n\r\n```fsharp\r\n    subController \"/yourModel\" yourModelController\r\n```\r\n\r\n\r\n## API Reference\r\n\r\nFull API reference for `controller` CE can be found [here](../reference/Saturn/saturn-controller-controllerbuilder-10.html)\r\n\r\nFull API reference for `Controller` module containing useful helpers can be found [here](../reference/Saturn/saturn-controllerhelpers-controller.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/pipeline.html","title":"Pipeline","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Pipelines\r\n\r\nPipeline is a computation expression used to combine `HttpHandlers` in a declarative manner.\r\n\r\nThe result of the computation expression is a standard Giraffe `HttpHandler` which means that it's easily composable with other parts of the Giraffe ecosystem.\r\n\r\n**Example:**\r\n\r\n*)\r\n\r\nopen Saturn\r\n\r\nlet headerPipe = pipeline {\r\n    set_header \"myCustomHeader\" \"abcd\"\r\n    set_header \"myCustomHeader2\" \"zxcv\"\r\n}\r\n\r\nlet endpointPipe = pipeline {\r\n    plug fetchSession\r\n    plug head\r\n    plug requestId\r\n}\r\n\r\n\r\n(**\r\n## API Reference\r\n\r\nFull API reference for `pipeline` CE can be found [here](../reference/Saturn/saturn-pipeline-pipelinebuilder.html)\r\n\r\nFull API reference for `PipelineHelpers` module containing useful helpers can be found [here](../reference/Saturn/saturn-pipelinehelpers.html)\r\n\r\nYou can also use in pipelines (using `plug`) any `HttpHandler` defined in Giraffe - documentation can be found [here](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/routing.html","title":"Router","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\nmodule Index =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nmodule NotFound =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nlet someScopeOrController = Giraffe.ResponseWriters.text \"\"\r\n\r\n(**\r\n# Routing\r\n\r\nRoutes are how Saturn connects all the HTTP requests to the different actions. Think of a route as the URL of the application. The site is yoursite.com but you may have a route for your about page such as yoursite.com/about.\r\n\r\nIn Saturn, `Routers` contain all the routes of your application. A router is a list of routes. A website can have a router that handles the different routes to your page like so:\r\n\r\n```bash\r\nyoursite.com\r\n├── \"/\"             -yoursite.com/\r\n├── \"/about\"        -yoursite.com/about\r\n├── \"/contact\"      -yoursite.com/contact\r\n├── \"/news\"         -yoursite.com/news\r\n└── \"/investors\"    -yoursite.com/investors\r\n```\r\n\r\nSince this is at the root, this is your router at `\"\"` path. You can then add a router inside another router to have the following:\r\n\r\n```bash\r\nyoursite.com\r\n├── books           -yoursite.com/books\r\n|   ├── list        -yoursite.com/books/list\r\n|   ├── add         -yoursite.com/books/add\r\n|   ├── update      -yoursite.com/books/update\r\n|   └── delete      -yoursite.com/books/update\r\n├── about           -yoursite.com/about\r\n├── contact         -yoursite.com/contact\r\n├── news            -yoursite.com/news\r\n└── investors       -yoursite.com/investors\r\n```\r\n\r\nNow you have a router for the `\"/books\"` path inside another router for the `\"\"` path.\r\n\r\nNow to see it in code, create a Saturn project from the template and you will have a `Router.fs` file like this:\r\n\r\n*)\r\n\r\n\r\nopen Saturn\r\nopen Giraffe.Core\r\nopen Giraffe.ResponseWriters\r\n\r\n\r\nlet browser = pipeline {\r\n    plug acceptHtml\r\n    plug putSecureBrowserHeaders\r\n    plug fetchSession\r\n    set_header \"x-pipeline-type\" \"Browser\"\r\n}\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\nlet browserRouter = router {\r\n    not_found_handler (htmlView NotFound.layout) //Use the default 404 webpage\r\n    pipe_through browser //Use the default browser pipeline\r\n\r\n    forward \"\" defaultView //Use the default view\r\n}\r\n\r\n//Other scopes may use different pipelines and error handlers\r\n\r\n// let api = pipeline {\r\n//     plug acceptJson\r\n//     set_header \"x-pipeline-type\" \"Api\"\r\n// }\r\n\r\n// let apiRouter = router {\r\n//     not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n//     pipe_through api\r\n//\r\n//     forward \"/someApi\" someScopeOrController\r\n// }\r\n\r\nlet appRouter = router {\r\n    // forward \"/api\" apiRouter\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nFirst, take a look at the `router` function.\r\n\r\n*)\r\n\r\nlet appRouter' = router {\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nThe `appRouter` value is a `router`. Inside is the `forward \"\" browserRouter` line. The `forward` function needs a path and a router. In this case, the path is an empty string and the router is `browserRouter`. That means that the `browserRouter` router will handle the routes at the current location. Since `appRouter` is the first router called, the current location is the root of the application.\r\n\r\nNow let's look at `browserRouter`:\r\n\r\n*)\r\n\r\nlet browserRouter' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    forward \"\" defaultView\r\n}\r\n\r\n(**\r\n\r\nThere are three lines. The first line, `not_found_handler (htmlView NotFound.layout)` tells `browserRouter` to display a not found page if the user enters a route that the application does not handle. The second line tells the application to use the `browser` pipeline defined above. The pipeline is a list of settings on how the website will deliver the pages. Lastly, `forward \"\" defaultView` is like `forward \"\" browserRouter` from the `appRouter`. Again, `browserRouter` does not contain any routes but it tells the `defaultView` router to handle them. Finally, we get to the part where the application is told how to handle the routes. Inside `defaultView`, we created 3 routes:\r\n\r\n*)\r\n\r\nlet defaultView' = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nHere, we see that `get` is used to define the routes. There are 3 routes here but 2 of them redirect to the first route. To illustrate, the routes are:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            └── \"/default.html\"     -redirect to yoursite.com/\r\n```\r\n\r\nLooking at the first line inside `defaultView`, `get \"/\" (htmlView Index.layout)` tells the application to display `Index.layout` at the root of the application. The `get` corresponds to the HTTP verb GET so when you type in a link, the browser tries to GET the page. The first parameter of `get` is \"/\", so basically when getting the root, the `get` function will return something. The second parameter is `(htmlView Index.layout)` so the `get` function returns an HTML page specified by Index.layout. The second and third line have `(redirectTo false \"/\")`, telling the application to go to \"yoursite.com/\" when going to \"yoursite.com/index\" or \"yoursite.com/default\"\r\n\r\n## Best Practices\r\n\r\nYou can combine all 3 routers into one router like so:\r\n\r\n*)\r\n\r\n\r\nlet appRouter'' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nThe template splits them into 3 to encourage good practices. In the first router, you can see the commented out code `forward \"/api\" apiRouter`. This is a good suggestion in the template to have a separate router to handle your API routes. We set up how to deliever the webpage with `pipe_through browser` in `browserRouter`. The settings are important for a browser to know how to handle your routes but not for a different application to access your routes as an API.\r\n\r\nThe template provides an example of how to set up the API routes in the commented out code, which I copied below:\r\n\r\n*)\r\n\r\nlet api = pipeline {\r\n    plug acceptJson\r\n    set_header \"x-pipeline-type\" \"Api\"\r\n}\r\n\r\nlet apiRouter = router {\r\n    not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n    pipe_through api\r\n\r\n    forward \"/someApi\" someScopeOrController\r\n}\r\n\r\n(**\r\n\r\nHere we have the `apiRouter` router which does not return a 404 page but a 404 text instead which is appropriate for an API. The router also uses a pipeline that is more appropriate for an API such as accepting JSON inputs instead of HTML as in the `browser` pipeline.\r\n\r\n## Format Strings\r\n\r\nYou might be wondering how to make routes that accept a numerical ID. You can make multiple routes for each ID like so\r\n\r\n```fsharp\r\nget \"/1\" (getApplication 1)\r\nget \"/2\" (getApplication 2)\r\nget \"/3\" (getApplication 3)\r\n...\r\n```\r\n\r\nBut this is impracticle because there can be a large number of items or new items are constantly being created with new IDs. Instead the solution is to use format strings. Remember that in the [Adding Pages Guide](../tutorials/adding-pages.html), we used `getf \"/%s\" index2Action` to pass a string to page.\r\n\r\n| Format Char | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nFor a numerical ID, we want to pass an int which is `%i` in the list above, so you can replace the lines above with\r\n\r\n```fsharp\r\ngetf \"/%i\" getApplication\r\n```\r\n\r\nNotice that `getf` is used instead of get. This is a separate version of get that handles `f`ormat characters.\r\n\r\n    You can use format strings with \"forward\" too by using \"forwardf\"\r\n\r\n## API Reference\r\n\r\nFull API reference for `router` CE can be found [here](../reference/Saturn/saturn-router-routerbuilder.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/reference/Saturn.AzureFunctions/index.html","title":"Saturn.AzureFunctions - API Reference","content":"Saturn.AzureFunctions \n Saturn"},{"uri":"https://saturnframework.org/reference/Saturn.AzureFunctions/saturn-azurefunctions.html","title":"AzureFunctions","content":"AzureFunctions \n  \n  \n FunctionBuilder  FunctionState  \n azureFunction  \n "},{"uri":"https://saturnframework.org/reference/Saturn.AzureFunctions/saturn-azurefunctions-functionbuilder.html","title":"FunctionBuilder","content":"FunctionBuilder \n  \n ConfigJSONSerializer <p>Configures built in JSON.Net (de)serializer with custom settings.</p>\r\n\r\n ConfigXMLSerializer <p>Configures built in XML (de)serializer with custom settings.</p>\r\n\r\n ErrorHandler <p>Adds error handler for the function</p>\r\n\r\n HostPrefix <p>Adds prefix for the endpoint. By default Azure Functions are using <code>/api</code> prefix.</p>\r\n\r\n Logger <p>Adds logger for the function. Used for error reporting and passed to the actions as <code>ctx.Items.[\"TraceWriter\"]</code></p>\r\n\r\n NotFoundHandler <p>Adds not found handler for the function</p>\r\n\r\n Router <p>Defines top-level router used for the function</p>\r\n\r\n Run  UseConfigNegotiation <p>Configures negotiation config</p>\r\n\r\n UseCustomJSONSerializer <p>Replaces built in JSON.Net (de)serializer with custom serializer</p>\r\n\r\n UseCustomXMLSerializer <p>Replaces built in XML (de)serializer with custom serializer</p>\r\n\r\n Yield  LogWriter  LogWriter "},{"uri":"https://saturnframework.org/reference/Saturn.AzureFunctions/saturn-azurefunctions-functionstate.html","title":"FunctionState","content":"FunctionState \n  \n Logger  Router  ErrorHandler  NotFoundHandler  HostPrefix  JsonSerializer  XmlSerializer  NegotiationConfig "},{"uri":"https://saturnframework.org/explanations/directory-structure.html","title":"Directory Structure","content":"\r\n# Directory Structure\r\n\r\nAfter creating a new Saturn project, let's take a deeper look into what files are created.\r\n\r\n```bash\r\n├── .fake\r\n├── .paket\r\n├── .vs\r\n├── .packages\r\n├── paket-files\r\n├── src\r\n|   ├── Migrations\r\n|   └── SaturnSample\r\n├── .gitignore\r\n├── build.fsx\r\n├── global.json\r\n├── paket.dependencies\r\n├── paket.lock\r\n└── SaturnSample.sln\r\n```\r\n\r\nAt this level most of it is basic configuration files to help with running Saturn. From looking at the `.paket`, `paket-files`, `paket.dependencies`, `paket.lock` folders and files, you can see that by default Saturn uses [paket](https://fsprojects.github.io/Paket/) to handle package management. You won't be working with these files directly but rather through the command line tools instead.\r\n\r\nSaturn also uses [FAKE](https://fake.build/) to build the project. You can see how it is set up by looking at the `.fake` folder and `build.fsx` file.\r\n\r\nSaturn also provides a `.gitignore` file that prevents some folders from being tracked by git when they don't need to.\r\n\r\nLastly, there is the `SaturnSample.sln` solution file so you can open the project in an IDE like Visual Sudio and a `global.json` file to configure the solution file.\r\n\r\n### Project structure\r\n\r\nMost of the work you will do in this project however, will be in `src/SaturnSample`, which looks like the following when expanded:\r\n\r\n```bash\r\n  ├── bin\r\n  ├── Books\r\n  |   ├── BooksController.fs\r\n  |   ├── BooksModel.fs\r\n  |   ├── BooksRepository.fs\r\n  |   └── BooksView.fs\r\n  ├── obj\r\n  ├── static\r\n  |   ├── app.css\r\n  |   └── app.js\r\n  ├── Templates\r\n  |   ├── App.fs\r\n  |   ├── Index.fs\r\n  |   ├── InternalError.fs\r\n  |   └── NotFound.fs\r\n  ├── Config.fs\r\n  ├── Database.fs\r\n  ├── database.sqlite\r\n  ├── paket.references\r\n  ├── Program.fs\r\n  ├── Router.fs\r\n  └── SaturnSample.fsproj\r\n```\r\n\r\n`bin` and `obj` folders store the compiled version of the program after you build the project.\r\n\r\nThe convention for Saturn is that the model and everything associated with it are inside one folder. Everything is also named with the plural form of the model so \"Books\" instead of \"Book\".\r\n\r\nYour static files like css, js, and images should be inside the `static` folder.\r\n\r\n`Config.fs` contains a `Config` record that stores settings that you can use inside your application. By default, the record only contains the `connectionString` field.\r\n\r\n`Database.fs` contains functions to execute SQL queries within the program through [Dapper](https://stackexchange.github.io/Dapper/).\r\n\r\nIf you did not run `dotnet saturn migration` as in the [how to start guide](../tutorials/how-to-start.html), you might not see `database.sqlite`, but that is the database file that your Saturn project is using to store data.\r\n\r\n`paket.references` shows the packages that your project is using.\r\n\r\n`Program.fs` handles intializing the program and loading up various settings.\r\n\r\n`Router.fs` is where you will set the route of the site and what page to load.\r\n\r\nLastly, `SaturnSample.fsproj` is the project file itself."},{"uri":"https://saturnframework.org/explanations/endpoint-routing.html","title":"Endpoint Routing","content":"\r\n# Endpoint Routing\r\n\r\nSaturn from version `0.15` supports [ASP.NET Endpoint Routing](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1) additionally to custom routing implementation provided by Giraffe. The main difference between old routing and new one is that Endpoint Routing assumes total separation of routing from behavior - it works by statically defining list of all possible routes on startup of application. This impacts design of some of our Saturn abstractions, and means new routing is not 100% compatible with old one. On the bright side, theoretically, Endpoint Routing should provide noticeable performance boost, and in the future it will allow for better ecosystem integration.\r\n\r\n> Currently endpoint routing API is treated as an experimental API - it's subject to changes.\r\n\r\nTo use Endpoint Routing you need to open `Saturn.Endpoint` namespace - this will override known `router` and `controller` Computation Expressions with their Endpoint Routing versions. In `application` CE instead of using `use_router` operation you should use `use_endpoint_router` operation. For many simple applications this may be enough to get things working - we've been trying to keep API as compatible as possible.\r\n\r\nHowever there are differences:\r\n\r\n* With Endpoint Routing `router` and `controller` computation expressions are not transformed to `HttpHandler` but rather to `Endpoint list`. This has a huge impact on composability of those abstractions - you can't do things like `myHttpHandler >=> router { ... }` any more. Such code should be replaced with `plug/pipe_through` functionality in both `router` and `controller`. `Endpoint list` can basically be used in 2 places - in `forward` operation in `router` and `use_endpoint_router` in `application`.\r\n* Lack of `subroutef` in Giraffe-EndpointRouting - beacuse EndpointRouting needs to have all possible route templates at the application startup it's really hard to emulate some of previous Giraffe's routing composibility capabilities. From Saturn point of view this created 2 major changes:\r\n  - there's no `forwardf` in `router` CE anymore - it should be replaced with set of `getf/postf/putf ... ` operations in child router.\r\n  - `subController` in `controller` CE doesn't work well in Endpoint Routing - you can use as subcontrollers only old, HttpHandler based controllers (even if you parent controller is Endpoint Routing controller). In `Saturn.Endpoint` we provide additonal `subcontroller` CE - it's an alias to old `controller` CE\r\n* Lack of `case_insensitive` in `router` and `controller` - with Endpoint Routing all routes are case insensitive by default and there's no easy way to change it\r\n* Lack of `not_found_handler` in `router` and `controller` - as Endpoint Routing creates global table of routing having scoped not-found handlers is really tricky. Use built-in ways of handle 404 in ASP.NET (such as `UseDeveloperExceptionPage`)\r\n* Unlike Giraffe routing, Endpoint Routing doesn't ensure order of routing checks - this shouldn't be a problem in most cases, but I can imagine some edge cases in which this would matter.\r\n\r\nIn general, to reiterate - Endpoint Routing API in Giraffe/Saturn is still experimental. However, it probably is a future of Giraffe/Saturn so if possible please check if your applications can move to the Endpoint Routing API, and try it out. It's important for everyone involved to get feedback on this new routing engine."},{"uri":"https://saturnframework.org/explanations/overview.html","title":"Saturn Overview","content":"\r\n# Saturn Overview\r\n\r\nSaturn is a web development framework written in F# which implements the server-side MVC pattern. Many of its components and concepts will seem familiar to those of us with experience in other web frameworks like Ruby on Rails or Python’s Django. It's heavily inspired by Elixir's [Phoenix](http://phoenixframework.org/).\r\n\r\nBuilt on top of the battle-tested ASP.NET Core foundation and the highly flexible, extendable model of Giraffe, Saturn provides high level abstractions, helpers and tools to enable high developer productivity, at the same time keeping high application performance provided by Kestrel and Giraffe.\r\n\r\nSaturn is made up of a number of distinct parts, each with its own purpose and role to play in building a web application.\r\n\r\n - Application\r\n    - the start and end of the request life cycle\r\n    - handles all aspects of requests up until the point where the router takes over\r\n    - provides a core set of plugs to apply to all requests\r\n    - dispatches requests into a router\r\n    - enables application and hosting configuration\r\n - [Router](routing.html)\r\n    - parses incoming requests and dispatches them to the correct controller/action, passing parameters as needed\r\n    - provides helpers to generate route paths or urls to resources\r\n    - defines named pipelines through which we may pass our requests\r\n    - allows easy application of groups of plugs to a set of routes\r\n - [Controllers](controller.html)\r\n    - provide functions, called *actions*, to handle requests\r\n    - actions:\r\n        - prepare data and pass it into views\r\n        - invoke rendering via views\r\n        - perform redirects\r\n        - return data as JSON or XML\r\n        - and much more\r\n - [Views](view.html)\r\n    - render templates\r\n    - act as a presentation layer\r\n    - define helper functions, available in templates, to decorate data for presentation\r\n - Channels\r\n    - manage sockets for easy realtime communication\r\n    - are analogous to controllers except that they allow bi-directional communication with persistent connections\r\n - [Scaffolding scripts](scaffolding.html)\r\n    - `dotnet new` template providing good starting point for new applications - [https://github.com/SaturnFramework/Saturn.Template](https://github.com/SaturnFramework/Saturn.Template)\r\n    - `dotnet saturn` CLI tool that controls migrations and let you easily scaffold new parts of application - [https://github.com/SaturnFramework/Saturn.Dotnet](https://github.com/SaturnFramework/Saturn.Dotnet)\r\n\r\n\r\n### Saturn rings\r\n\r\nSaturn itself is the top layer of a multi-layer system designed to create a flexible, productive environment for creating web applications.\r\n\r\n#### Kestrel and ASP.NET Core\r\n\r\nASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-based, Internet-connected applications. Kestrel is a cross-platform web server for ASP.NET Core based on `libuv`, a cross-platform asynchronous I/O library. ASP.NET Core documentation can be found [here](https://docs.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-3.1)\r\n\r\n#### [Giraffe](https://github.com/giraffe-fsharp/Giraffe)\r\n\r\nGiraffe is an F# micro web framework for building rich web applications. It has been heavily inspired and is similar to [Suave](https://suave.io), but has been specifically designed with ASP.NET Core in mind and can be plugged into the ASP.NET Core pipeline via middleware. Giraffe applications are composed of so-called HttpHandler functions which can be thought of as a mixture of Suave's WebParts and ASP.NET Core's middleware. As Saturn shares many basic helper functions with Giraffe it's highly recommended to also check out [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n\r\n### Saturn moons\r\n\r\nSaturn is not only a library building on top of Giraffe, but also a set of opinionated tooling for scaffolding a whole project and then generating some boilerplate code. At the moment our template is using (by default):\r\n\r\n#### [Dapper](https://github.com/StackExchange/Dapper)\r\n\r\nA simple, focused on performance object mapper for .Net that you can add in to your project and will extend your `IDbConnection` interface.\r\n\r\n#### [Simple.Migrations](https://github.com/canton7/Simple.Migrations)\r\n\r\nSimple.Migrations is a simple bare-bones migration framework for .NET Core (.NET Standard 1.2 and .NET 4.5). It doesn't provide SQL generation, nor an out-of-the-box command-line tool, nor any other fancy feature. It does however provide a set of simple, extendable, and composable tools for integrating migrations into your application.\r\n\r\n\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/scaffolding.html","title":"Scaffolding","content":"\r\n# Scaffolding\r\n\r\nSaturn provides a command line scaffolding tool to generate a model, database migration, controller, and associated views.\r\n\r\nTo use the generator, run the `dotnet saturn` command from the root of your application application.  If you have used the template to generate your project, this is the directory with `build.fsx` or `paket.dependencies` file.\r\n\r\nThere are three flavors of generators that provide flexibility about what types of code is generated to support your model.\r\n\r\n| Command      |  Generates                                                                     |\r\n|--------------|--------------------------------------------------------------------------------|\r\n| gen          | Creates a model, database layer, HTML views, and a controller.                 |\r\n| gen.json     | Creates a model, database layer, and an API controller to access the model.    |\r\n| gen.model    | Creates only the model and database layer (no controller or views)             |\r\n\r\nEach of these commands will generate a migration for your model as well as a folder containing generated files.\r\n\r\nFor example:\r\n\r\n`dotnet saturn gen Book Books id:string title:string`\r\n\r\nGenerates the following structure:\r\n\r\n```bash\r\nsrc\r\n├── Migrations\r\n│   └── 201903192143.Book.fs\r\n│\r\n└── SaturnSample\r\n    └── Books\r\n        ├── BooksController.fs\r\n        ├── BooksModel.fs\r\n        ├── BooksRepository.fs\r\n        └── BooksViews.fs\r\n```\r\n\r\nEach of the generators takes arguments in the same format:\r\n\r\n`dotnet saturn gen <SingularModelName> <PluralModelName> <List of model fields with types>`\r\n\r\nThe list of model fields are names and types separated by a colon.\r\n\r\n`<fieldname>:<type>`\r\n\r\nCurrently supported types are:\r\n\r\n* string\r\n* int\r\n* float\r\n* double\r\n* decimal\r\n* guid\r\n* datetime\r\n* bool\r\n\r\n## Migrations\r\n\r\nUsing the generator to create a model will also create a migration file that will create a supporting table in the database. Execute the migration script using:\r\n\r\n`dotnet saturn migration`"},{"uri":"https://saturnframework.org/explanations/view.html","title":"View Engine","content":"\r\n# View Engine\r\n\r\n> This post has been originally part of the [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine)\r\n\r\nSaturn is built on top of Giraffe and can use any helpers it provides. This is a case for suggested view engine that you can use in Saturn - Giraffe has its own functional view engine which can be used to build rich UIs for web applications. The single biggest and best contrast to other view engines (e.g. Razor, Liquid, etc.) is that the Giraffe View Engine is entirely functional written in normal (and compiled) F# code.\r\n\r\nThis means that the Giraffe View Engine is by definition one of the most feature rich view engines available, requires no disk IO to load a view and views are automatically compiled at build time.\r\n\r\nThe Giraffe View Engine uses traditional functions and F# record types to generate rich HTML/XML views.\r\n\r\n### HTML Elements and Attributes\r\n\r\nHTML elements and attributes are defined as F# objects:\r\n\r\n```fsharp\r\nlet indexView =\r\n    html [] [\r\n        head [] [\r\n            title [] [ str \"Giraffe Sample\" ]\r\n        ]\r\n        body [] [\r\n            h1 [] [ str \"I |> F#\" ]\r\n            p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                str \"Hello World\"\r\n            ]\r\n        ]\r\n    ]\r\n```\r\n\r\nA HTML element can either be a `ParentNode`, a `VoidElement` or a `Text` element.\r\n\r\nFor example the `<html>` or `<div>` tags are typical `ParentNode` elements. They can hold an `XmlAttribute list` and a second `XmlElement list` for their child elements:\r\n\r\n```fsharp\r\nlet someHtml = div [] []\r\n```\r\n\r\nAll `ParentNode` elements accept these two parameters:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [ _id \"someId\"; _class \"css-class\" ] [\r\n        a [ _href \"https://example.org\" ] [ str \"Some text...\" ]\r\n    ]\r\n```\r\n\r\nMost HTML tags are `ParentNode` elements, however there is a few HTML tags which cannot hold any child elements, such as `<br>`, `<hr>` or `<meta>` tags. These are represented as `VoidElement` objects and only accept the `XmlAttribute list` as single parameter:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        br []\r\n        hr [ _class \"css-class-for-hr\" ]\r\n        p [] [ str \"bla blah\" ]\r\n    ]\r\n```\r\n\r\nAttributes are further classified into two different cases. First and most commonly there are `KeyValue` attributes:\r\n\r\n```fsharp\r\na [\r\n    _href \"http://url.com\"\r\n    _target \"_blank\"\r\n    _class \"class1\" ] [ str \"Click here\" ]\r\n```\r\n\r\nAs the name suggests, they have a key, such as `class` and a value such as the name of a CSS class.\r\n\r\nThe second category of attributes are `Boolean` flags. There are not many but some HTML attributes which do not require any value (e.g. `async` or `defer` in script tags). The presence of such an attribute means that the feature is turned on, otherwise it is turned off:\r\n\r\n```fsharp\r\nscript [ _src \"some.js\"; _async ] []\r\n```\r\n\r\nThere's also a wealth of [accessibility attributes](https://www.w3.org/TR/html-aria/) available under the `Giraffe.GiraffeViewEngine.Accessibility` module (needs to be explicitly opened).\r\n\r\n### Text Content\r\n\r\nNaturally the most frequent content in any HTML document is pure text:\r\n\r\n```html\r\n<div>\r\n    <h1>This is text content</h1>\r\n    <p>This is even more text content!</p>\r\n</div>\r\n```\r\n\r\nThe Giraffe View Engine lets one create pure text content as a `Text` element. A `Text` element can either be generated via the `rawText` or `encodedText` (or the short alias `str`) functions:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        p [] [ rawText \"<div>Hello World</div>\" ]\r\n        p [] [ encodedText \"<div>Hello World</div>\" ]\r\n    ]\r\n```\r\n\r\nThe `rawText` function will create an object of type `XmlNode` where the content will be rendered in its original form and the `encodedText`/`str` function will output a string where the content has been HTML encoded.\r\n\r\nIn this example the first `p` element will literally output the string as it is (`<div>Hello World</div>`) while the second `p` element will output the value as HTML encoded string `&lt;div&gt;Hello World&lt;/div&gt;`.\r\n\r\nPlease be aware that the the usage of `rawText` is mainly designed for edge cases where someone would purposefully want to inject HTML (or JavaScript) code into a rendered view. If not used carefully this could potentially lead to serious security vulnerabilities and therefore should be used only when explicitly required.\r\n\r\nMost cases and particularly any user provided content should always be output via the `encodedText`/`str` function.\r\n\r\n### Javascript event handlers\r\n\r\nIt is possible to add JavaScript event handlers to HTML elements using the Giraffe View Engine.  These event handlers (all prefixed with names starting with `_on`, for example `_onclick`, `_onmouseover`) can either execute inline JavaScript code or can invoke functions that are part of the `window` scope.\r\n\r\nThis example illustrates how inline JavaScript could be used to log to the console when a button is clicked:\r\n\r\n```fsharp\r\nlet inlineJSButton =\r\n    button [_id \"inline-js\"\r\n            _onclick \"console.log(\\\"Hello from the 'inline-js' button!\\\");\"] [str \"Say Hello\" ]\r\n```\r\n\r\nThere are some caveats with this approach, namely that\r\n* it is not very scalable to write JavaScript inline in this manner, and more pressing\r\n* the Giraffe View Engine HTML-encodes the text provided to the `_onX` attributes.\r\n\r\nTo get around this, you can write dedicated scripts in your HTML and reference the functions from your event handlers:\r\n\r\n```fsharp\r\nlet page =\r\n    div [] [\r\n        script [_type \"application/javascript\"] [\r\n            rawText \"\"\"\r\n            window.greet = function () {\r\n                console.log(\"ping from the greet method\");\r\n            }\r\n            \"\"\"\r\n        ]\r\n        button [_id \"script-tag-js\"\r\n                _onclick \"greet();\"] [str \"Say Hello\"]\r\n    ]\r\n```\r\n\r\nHere it's important to note that we've included the text of our script using the `rawText` tag.  This ensures that our text is not encoded by Giraffe so that it remains as we have written it.\r\n\r\nHowever, writing large quantities of JavaScript in this manner can be difficult, because you don't have access to the large ecosystem of javascript editor tooling.  In this case you should write your functions in another script and use a `script` tag element to reference your script, then add the desired function to your HTML element's event handler.\r\n\r\nSay you had a JavaScript file named `greet.js` and had configured Giraffe to serve that script from the WebRoot. Let us also say that the content of that script was:\r\n\r\n```javascript\r\nfunction greet() {\r\n    console.log(\"Hello from the greet function of greet.js!\");\r\n}\r\n```\r\n\r\nThen, you could reference that javascript via a script element, and use `greet` in your event handler like so:\r\n\r\n```fsharp\r\nlet page =\r\n    html [] [\r\n        head [] [\r\n            script [_type \"application/javascript\"\r\n                    _src \"/greet.js\"] [] // include our `greet.js` function dynamically\r\n        ]\r\n        body [] [\r\n            button [_id \"greet-btn\"\r\n                    _onclick \"greet()\"] [] // use the `greet()` function from `greet.js` to say hello\r\n        ]\r\n    ]\r\n```\r\n\r\nIn this way, you can write `greet.js` with all of your expected tooling, and still hook up the event handlers all in one place in Giraffe.\r\n\r\n### Naming Convention\r\n\r\nThe Giraffe View Engine has a naming convention which lets you easily determine the correct function name without having to know anything about the view engine's implementation.\r\n\r\nAll HTML tags are defined as `XmlNode` elements under the exact same name as they are named in HTML. For example the `<html>` tag would be `html [] []`, an `<a>` tag would be `a [] []` and a `<span>` or `<canvas>` would be the `span [] []` or `canvas [] []` function.\r\n\r\nHTML attributes follow the same naming convention except that attributes have an underscore prepended. For example the `class` attribute would be `_class` and the `src` attribute would be `_src` in Giraffe.\r\n\r\nThe underscore does not only help to distinguish an attribute from an element, but also avoid a naming conflict between tags and attributes of the same name (e.g. `<form>` vs. `<input form=\"form1\">`).\r\n\r\nIf a HTML attribute has a hyphen in the name (e.g. `accept-charset`) then the equivalent Giraffe attribute would be written in camel case notion (e.g. `acceptCharset`).\r\n\r\n*Should you find a HTML tag or attribute missing in the Giraffe View Engine then you can either [create it yourself](#custom-elements-and-attributes) or send a [pull request on GitHub](https://github.com/giraffe-fsharp/Giraffe/pulls).*\r\n\r\n### View Engine Best Practices\r\n\r\nDue to the huge amount of available HTML tags and their fairly generic (and short) names (e.g. `<form>`, `<option>`, `<select>`, etc.) there is a significant danger of accidentally overriding a function of the same name in an application's codebase. For that reason the Giraffe View Engine becomes only available after opening the `GiraffeViewEngine` module.\r\n\r\nAs a measure of good practice it is recommended to create all views in a separate module:\r\n\r\n```fsharp\r\nmodule MyWebApplication\r\n\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let index =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str \"Giraffe Sample\" ]\r\n            ]\r\n            body [] [\r\n                h1 [] [ str \"I |> F#\" ]\r\n                p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                    str \"Hello World\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let other = //...\r\n```\r\n\r\nThis ensures that the opening of the `GiraffeViewEngine` is only contained in a small context of an application's codebase and therefore less of a threat to accidental overrides. In the above example views can always be accessed through the `Views` sub module (e.g. `Views.index`).\r\n\r\n### Custom Elements and Attributes\r\n\r\nAdding new elements or attributes is normally as simple as a single line of code:\r\n\r\n```fsharp\r\nopen Giraffe.GiraffeViewEngine\r\n\r\n// If there was a new <foo></foo> HTML element:\r\nlet foo = tag \"foo\"\r\n\r\n// If <foo> is an element which cannot hold any content then create it as voidTag:\r\nlet foo = voidTag \"foo\"\r\n\r\n// If <foo> has a new attribute called bar then create a new bar attribute:\r\nlet _bar = attr \"bar\"\r\n\r\n// if the bar attribute is a boolean flag:\r\nlet _bar = flag \"bar\"\r\n```\r\n\r\nAlternatively you can also create new elements and attributes from inside another element:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n```\r\n\r\n### Rendering Views\r\n\r\nRendering views in Giraffe is done through one of the following functions:\r\n\r\n- `renderHtmlDocument`\r\n- `renderHtmlNodes`\r\n- `renderHtmlNode`\r\n- `renderXmlNodes`\r\n- `renderXmlNode`\r\n\r\nThe Giraffe View Engine cannot only be used to render HTML views, but also for any other XML based content such as `<svg>` images or other arbitrary XML based data.\r\n\r\nThe `renderHtmlDocument` function takes a single `XmlNode` as input parameter and renders a HTML page with a `DOCTYPE` declaration. This function should be used for rendering a complete HTML document. The `WriteHtmlViewAsync` extension method and the `htmlView` http handler both use the `renderHtmlDocument` function under the covers.\r\n\r\nThe `renderHtmlNodes` function takes an `XmlNode list` as input parameter and will output a single HTML string containing all the rendered HTML code. The `renderHtmlNode` function renders a single `XmlNode` element into a valid HTML string. Both, the `renderHtmlNodes` and `renderHtmlNode` function are useful for use cases where a HTML snippet needs to be created without a `DOCTYPE` declaration (e.g. templated emails, etc.).\r\n\r\nThe `renderXmlNodes` and `renderXmlNode` function are identical to `renderHtmlNodes` and `renderHtmlNode`, except that they will render void elements differently:\r\n\r\n```fsharp\r\nlet someTag = voidTag \"foo\"\r\nlet someContent = someTag []\r\n\r\n// Void tag will be rendered to valid HTML: <foo>\r\nlet output1 = renderHtmlNode someContent\r\n\r\n// Void tag will be rendered to valid XML: <foo />\r\nlet output2 = renderXmlNode someContent\r\n```\r\n\r\nAll `GiraffeViewEngine` http handlers are using a thread static `StringBuilderPool` to avoid the creation of large `StringBuilder` objects for each render call and dynamically grow/shrink that pool based on the application's needs. However if the application is running into any memory issues then this performance feature can be disabled by setting `StringBuilderPool.IsEnabled <- false`.\r\n\r\nAdditionally with Giraffe 3.0.0 or higher there is a new module called `ViewBuilder` under the `Giraffe.GiraffeViewEngine` namespace. This module exposes additional view rendering functions which compile a view into a `StringBuilder` object instead of returning a single `string`:\r\n\r\n- `ViewBuilder.buildHtmlDocument`\r\n- `ViewBuilder.buildHtmlNodes`\r\n- `ViewBuilder.buildHtmlNode`\r\n- `ViewBuilder.buildXmlNodes`\r\n- `ViewBuilder.buildXmlNode`\r\n\r\nThe `ViewBuilder.build[...]` functions can be useful if there is additional string processing required before/after composing a view by the `GiraffeViewEngine` (e.g. embedding HTML snippets in an email template, etc.). These functions also serve as the lower level building blocks of the equivalent `render[...]` functions.\r\n\r\nExample usage:\r\n\r\n```fsharp\r\nopen System.Text\r\nopen Giraffe.GiraffeViewEngine\r\n\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n\r\nlet sb = new StringBuilder()\r\n\r\n// Perform actions on the `sb` object...\r\nsb.AppendLine \"This is a HTML snippet inside a markdown string:\"\r\n  .AppendLine \"\"\r\n  .AppendLine \"```html\" |> ignore\r\n\r\nlet sb' = ViewBuilder.buildHtmlNode sb someHtml\r\n\r\n// Perform more actions on the `sb` object...\r\nsb'.AppendLine \"```\" |> ignore\r\n\r\nlet markdownOutput = sb'.ToString()\r\n```\r\n\r\n### Common View Engine Features\r\n\r\nThe Giraffe View Engine doesn't have any specially built functions for commonly known features such as master pages or partial views, mainly because the nature of the view engine itself doesn't require it in most cases.\r\n\r\n#### Master Pages\r\n\r\nCreating a master page is a simple matter of piping two functions together:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n... or even have multiple nested master pages:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master1 (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let master2 (content: XmlNode list) =\r\n        [\r\n            main [] content\r\n            footer [] [\r\n                p [] [\r\n                    str \"Copyright ...\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master2 |> master1 pageTitle\r\n```\r\n\r\n#### Partial Views\r\n\r\nA partial view is nothing more than one function or object being called from within another function:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n#### Working with Models\r\n\r\nA view which accepts a model is basically a function with an additional parameter:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index (model : IndexViewModel) =\r\n        [\r\n            h1 [] [ str model.PageTitle ]\r\n            p [] [ str model.WelcomeText ]\r\n        ] |> master model.PageTitle\r\n```\r\n\r\n#### If Statements, Loops, etc.\r\n\r\nThings like if statements, loops and other normal F# language constructs work just as expected:\r\n\r\n```fsharp\r\nlet partial (books : Book list) =\r\n    ul [] [\r\n        yield!\r\n            books\r\n            |> List.map (fun b -> li [] [ str book.Title ])\r\n    ]\r\n```\r\n\r\nOverall the Giraffe View Engine is extremely flexible and feature rich by nature based on the fact that it is generated via normal compiled F# code."},{"uri":"https://saturnframework.org/tutorials/adding-pages.html","title":"Adding Pages","content":"\r\n# Adding Pages\r\n\r\nThis guide uses the same project from the [how to start guide](how-to-start.html). Let's add two pages to it - one hello page and a page that can get your name from the URL.\r\n\r\n## Creating the View\r\n\r\nTo begin, create a `Hello` folder inside the `src/SaturnSample` folder.\r\n\r\nInside the folder, create a new file called \"HelloViews.fs\". This file will contain the functions to create the page.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Giraffe.GiraffeViewEngine\r\nopen Saturn\r\n\r\nmodule Views =\r\n  let index =\r\n    div [] [\r\n        h2 [] [rawText \"Hello from Saturn!\"]\r\n    ]\r\n```\r\n\r\nOne of the dependencies required is [Giraffe View Engine](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine). This will allow your project to define HTML within your function. The `index` function will result in the following HTML code:\r\n\r\n```html\r\n<div>\r\n    <h2>Hello from Saturn!</h2>\r\n</div>\r\n```\r\n\r\n## Creating the Controller\r\n\r\nCreate a `HelloController.fs` file inside the `Hello` folder.\r\n\r\nThe `index` function tells us what the HTML will be but we still need to tell Saturn to return it as an HTML page. We also need to tell Saturn where the page is.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Saturn\r\nopen Giraffe.ResponseWriters\r\n\r\nmodule Controller =\r\n    let indexAction =\r\n        htmlView (Views.index)\r\n\r\n    let helloView = router {\r\n        get \"/\" indexAction\r\n    }\r\n```\r\n\r\nThe `indexAction` tells Saturn to create an HTML page using the `index` function inside \"HelloViews.fs\"\r\n\r\n`helloView` lets Saturn know that the page is located at the root.\r\n\r\n## Adding the 2 new files to the project\r\n\r\nFor the project to see the new files, modify SaturnSample.fsproj as below:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <Compile Include=\"Database.fs\" />\r\n    <Compile Include=\"Config.fs\" />\r\n\r\n    <Compile Include=\"Hello\\HelloViews.fs\" />\r\n    <Compile Include=\"Hello\\HelloController.fs\" />\r\n    ...\r\n```\r\n\r\n## Adding it to Router.fs\r\n\r\n\r\nAfter setting up the route, you need to update the project with the new route.\r\n\r\nIn \"Router.fs\", add the following to the inside of the `browserRouter` function:\r\n\r\n\r\n```fsharp\r\nforward \"/hello\" Hello.Controller.helloView\r\n```\r\n\r\nThis means that when we navigate to [http://localhost:8085/hello](http://localhost:8085/hello), the `helloView` function will determine what page to load there. Looking inside the `helloView` function, we said that `indexAction` is called at the root. In conclusion, the page will be located at [http://localhost:8085/hello/](http://localhost:8085/hello/). (Note the \"/\" at the end)\r\n\r\nNow run the program and go to [http://localhost:8085/hello/](http://localhost:8085/hello/) and you will see a page saying \"Hello from Saturn!\"\r\n\r\n## Sending a parameter to your page\r\n\r\nWhat if you want the page to display your name?\r\n\r\nOne way to retrieve your name is to get it from the route. So when you go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) with {yourname} being your actual name, it will grab your name which can then be used to display on the page.\r\n\r\nTo begin, add a new view in your `HelloViews.fs`:\r\n\r\n```fsharp\r\n  let index2 (name : string) =\r\n    div [] [\r\n        h2 [] [rawText (\"Hello \" + name + \"!\")]\r\n    ]\r\n```\r\n\r\nThis function requires passing in the name to be displayed. The name will be retrieved from the route.\r\n\r\nAdd the following to the `HelloController.fs` file below the `helloView` handler:\r\n\r\n```fsharp\r\nlet index2Action name=\r\n    htmlView (Hello.Views.index2 name)\r\n```\r\n\r\nNow to set up the route. Add the following to the `HelloView` handler:\r\n\r\n```fsharp\r\ngetf \"/%s\" index2Action\r\n```\r\n\r\n\"%s\" is a format string. This lets Saturn know to save whatever you type in that spot. Since we want to save a name, we want to save it as a string so we use `%s`.\r\n\r\nThere are other format strings for different types:\r\n\r\n| Format String | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nNow run the program and go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) and replace `{yourname}` with your name to see a page that will greet you.\r\n"},{"uri":"https://saturnframework.org/tutorials/adding-saturn-to-an-existing-giraffe-app.html","title":"Adding Saturn to an existing Giraffe application","content":"\r\n# Adding Saturn to an existing Giraffe application\r\n\r\nThe previous chapter showed how to get started with a new application.\r\n\r\nIf you already have a working Giraffe webserver, you can gradually opt-in to Saturn.\r\n\r\nFor example, if your existing app looks like this:\r\n\r\n```fsharp\r\n\r\ntype Customer = {\r\n    Name : string\r\n    Address : string\r\n}\r\n\r\nlet customers =\r\n    choose [\r\n      GET >=> (json { Name = \"Mr. Smith\"; Address = \"Santa Monika\"})\r\n      PUT >=> (bindJson<Customer> (fun customer -> printfn \"Adding customer %A\" customer; setStatusCode 200))\r\n    ]\r\n\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"               >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n    ]\r\n```\r\n\r\nand you need to add \"vendor\" functionality, you could implement it as a Saturn ``router`` while keeping everything else intact:\r\n\r\n\r\n```fsharp\r\n// the new Saturn router\r\nlet vendors = router {\r\n    getf \"/%i\" (fun vendorId -> (json (readVendorFromDb vendorId)))\r\n    post \"/\" (bindJson<Vendor> (fun customer -> addVendor vendor; setStatusCode 200))\r\n}\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"                >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n        // plug the new Saturn router into the Giraffe app\r\n        route \"/api/vendors\"     >=> vendors\r\n    ]\r\n```\r\n\r\n## Embedding Giraffe Handlers into Saturn\r\n\r\nOf course the other way around also works.\r\n\r\nFor example, [Elmish.Bridge](https://github.com/Nhowka/Elmish.Bridge) does not provide a specialized implementation for Saturn. And it doesn't need to, because we can just use the Giraffe implementation!\r\n\r\n```fsharp\r\n\r\nopen Elmish\r\nopen Elmish.Bridge\r\n\r\nlet elmishBridgeHandler : HttpHandler =\r\n  Bridge.mkServer Shared.endpoint init update\r\n  |> Bridge.run Giraffe.server\r\n\r\n// our existing Saturn router\r\nlet router = router {\r\n\r\n    // ...\r\n\r\n    forward \"\" elmishBridgeHandler\r\n}\r\n```\r\n"},{"uri":"https://saturnframework.org/tutorials/how-to-start.html","title":"Getting started","content":"\r\n# How to start in 60 seconds\r\n\r\nRequirements:\r\n\r\n* `dotnet` SDK 3.1 [https://dotnet.microsoft.com/download/dotnet-core/3.1](https://dotnet.microsoft.com/download/dotnet-core/3.1)\r\n\r\n## Template\r\n\r\nThe easiest way to get started is to use the provided template:\r\n\r\n1. Install the `dotnet` template with `dotnet new -i Saturn.Template`\r\n2. Create a new folder and move into it - `mkdir SaturnSample && cd SaturnSample`\r\n3. Create a new Saturn application - `dotnet new saturn -lang F#`\r\n4. Install all necessary dev tools - `dotnet tool restore`\r\n6. Create a new controller with `dotnet saturn gen Book Books id:string title:string author:string`\r\n7. Run migrations that will create the database and Books table (as for now, the generator is using only SQLite DB) - `dotnet saturn migration`\r\n8. Open the folder in your favourite editor (VSCode) and insert the line (`forward \"/books\" Books.Controller.resource`) into `browserRouter` in `Router.fs` file\r\n9. Start the application by running `dotnet fake build -t run` from the root of the solution. This will start the application in watch mode (automatic recompilation on changes) and open your browser on [http://localhost:8085](http://localhost:8085) which should display the index page.\r\n10. Go to [http://localhost:8085/books](http://localhost:8085/books) to see the generated view. All buttons should be working; you can add new entries, and remove or edit old ones.\r\n\r\n\r\n## Hello World\r\n\r\nIf you want to start from scratch with a minimal Saturn webserver:\r\n\r\n1. Create a new F# Project (for example with `dotnet new console -lang F#`)\r\n2. Add the `Saturn` NuGet Package\r\n\r\n```fsharp\r\nopen Saturn\r\nopen Giraffe\r\n\r\nlet app = application {\r\n    use_router (text \"Hello World from Saturn\")\r\n}\r\n\r\nrun app\r\n```\r\n\r\nIf you compile and run this application, it will unconditionally return the text regardless of the path.\r\n\r\nFrom here on out you can add [routers](../explanations/routing.html), [controllers](../explanations/controller.html) and [views](../explanations/view.html).\r\n\r\n## Deep Dive\r\n\r\nTo get a better understanding of Saturn and the whole SAFE Stack you can look at the [SAFE-Dojo](https://github.com/CompositionalIT/SAFE-Dojo).\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/controller.html","title":"Controllers","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Controller\r\n\r\nIn Saturn, a **controller** is a list of routes that is focused on a **model** (an object that contains your data). So if you have a user model, some common operations are to display the list of users, show details of a user, add a user, update or user, or remove a user. A controller is a great way to organize all of these actions.\r\n\r\nEach of the operations is a separate route and a controller is an easy way to group these routes together.\r\n\r\nA basic user controller is shown below:\r\n\r\n*)\r\nopen Saturn\r\n\r\nlet userController = controller {\r\n    index (fun ctx -> \"Index handler version 1\" |> Controller.text ctx) //View list of users\r\n    add (fun ctx -> \"Add handler version 1\" |> Controller.text ctx) //Add a user\r\n    create (fun ctx -> \"Create handler version 1\" |> Controller.text ctx) //Create a user\r\n    show (fun ctx id -> (sprintf \"Show handler version 1 - %i\" id) |> Controller.text ctx) //Show details of a user\r\n    edit (fun ctx id -> (sprintf \"Edit handler version 1 - %i\" id) |> Controller.text ctx)  //Edit a user\r\n    update (fun ctx id -> (sprintf \"Update handler version 1 - %i\" id) |> Controller.text ctx)  //Update a user\r\n}\r\n\r\n(**\r\nHere we can see the `index`, `add`, `create`, `show`, `edit`, and `update` operations but there are more operations that are not shown here like `patch` and `delete`. You can see all the operations int the [API Reference](../reference/Saturn/saturn-controller-controllerbuilder-10.html). You do not have to handle all of the operations.\r\n\r\nYou might be wondering what the difference is between `add` and `create` or `edit` and `update`. The `add` operation tells the application to return the form so that the user can enter the data for the user to be added. The `create` operation will commit the data to the database of the application. It is the same with `edit` for displaying the form and `update` for committing the change.\r\n\r\nTo add the controller for the routes, you can add it to the `defaultView` router like so:\r\n\r\n*)\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n    forward \"/users\" userController\r\n}\r\n\r\n(**\r\nThe route will now be:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            ├── \"/default.html\"     -redirect to yoursite.com/\r\n            └── \"/users\"\r\n                ├── index \"/\"           -yoursite.com/users/\r\n                ├── add \"/add\"          -yoursite.com/users/add\r\n                ├── create              -POST yoursite.com/users/add\r\n                ├── show \"/%i\"          -yoursite.com/users/%i\r\n                ├── edit \"/%i/edit\"     -yoursite.com/users/%i/edit\r\n                └── update \"\"           -POST yoursite.com/users/%i/edit\r\n```\r\n\r\nThe create and update operations make changes to the database so you have to make a POST request containing the information you want to save to the database.\r\n\r\n## Subcontroller\r\n\r\nNow that you know how to chain routers together to create routes, we can look at a common scenario for a website. A website usually has users and each user can create multiple comments.\r\n\r\n```bash\r\nyoursite.com\r\n└── \"/users\"\r\n    └── \"/%i\"           -yoursite.com/users/%i\r\n        └── \"/comments\" (commentController)\r\n            ├── index \"/\"           -yoursite.com/users/{userId}/comments/\r\n            └── show \"/%i\"          -yoursite.com/users/{userId}/comments/{commentId}\r\n```\r\n\r\nIn Saturn, you can make the comment controller a subcontroller of the user controller. It looks like the following code:\r\n\r\n*)\r\n\r\nlet commentController userId = controller {\r\n    index (fun ctx -> (sprintf \"Comment Index handler for user %i\" userId ) |> Controller.text ctx)\r\n    add (fun ctx -> (sprintf \"Comment Add handler for user %i\" userId ) |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show comment %s handler for user %i\" id userId ) |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit comment %s handler for user %i\" id userId )  |> Controller.text ctx)\r\n}\r\n\r\nlet userController = controller {\r\n    subController \"/comments\" commentController\r\n\r\n    plug [All] (setHttpHeader \"user-controller-common\" \"123\")\r\n    plug [Index; Show] (setHttpHeader \"user-controller-specialized\" \"123\")\r\n\r\n    index (fun ctx -> \"Index handler no version\" |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show handler no version - %i\" id) |> Controller.text ctx)\r\n    add (fun ctx -> \"Add handler no version\" |> Controller.text ctx)\r\n    create (fun ctx -> \"Create handler no version\" |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit handler no version - %i\" id) |> Controller.text ctx)\r\n    update (fun ctx id -> (sprintf \"Update handler no version - %i\" id) |> Controller.text ctx)\r\n    delete (fun ctx id -> failwith (sprintf \"Delete handler no version failed - %i\" id) |> Controller.text ctx)\r\n    error_handler (fun ctx ex -> sprintf \"Error handler no version - %s\" ex.Message |> Controller.text ctx)\r\n}\r\n\r\n(**\r\n\r\nTo create a subcontroller, start with creating a controller for your model. After that, define it as a subcontroller inside the main controller with the following code:\r\n\r\n```fsharp\r\n    subController \"/yourModel\" yourModelController\r\n```\r\n\r\n\r\n## API Reference\r\n\r\nFull API reference for `controller` CE can be found [here](../reference/Saturn/saturn-controller-controllerbuilder-10.html)\r\n\r\nFull API reference for `Controller` module containing useful helpers can be found [here](../reference/Saturn/saturn-controllerhelpers-controller.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/pipeline.html","title":"Pipeline","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Pipelines\r\n\r\nPipeline is a computation expression used to combine `HttpHandlers` in a declarative manner.\r\n\r\nThe result of the computation expression is a standard Giraffe `HttpHandler` which means that it's easily composable with other parts of the Giraffe ecosystem.\r\n\r\n**Example:**\r\n\r\n*)\r\n\r\nopen Saturn\r\n\r\nlet headerPipe = pipeline {\r\n    set_header \"myCustomHeader\" \"abcd\"\r\n    set_header \"myCustomHeader2\" \"zxcv\"\r\n}\r\n\r\nlet endpointPipe = pipeline {\r\n    plug fetchSession\r\n    plug head\r\n    plug requestId\r\n}\r\n\r\n\r\n(**\r\n## API Reference\r\n\r\nFull API reference for `pipeline` CE can be found [here](../reference/Saturn/saturn-pipeline-pipelinebuilder.html)\r\n\r\nFull API reference for `PipelineHelpers` module containing useful helpers can be found [here](../reference/Saturn/saturn-pipelinehelpers.html)\r\n\r\nYou can also use in pipelines (using `plug`) any `HttpHandler` defined in Giraffe - documentation can be found [here](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/routing.html","title":"Router","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\nmodule Index =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nmodule NotFound =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nlet someScopeOrController = Giraffe.ResponseWriters.text \"\"\r\n\r\n(**\r\n# Routing\r\n\r\nRoutes are how Saturn connects all the HTTP requests to the different actions. Think of a route as the URL of the application. The site is yoursite.com but you may have a route for your about page such as yoursite.com/about.\r\n\r\nIn Saturn, `Routers` contain all the routes of your application. A router is a list of routes. A website can have a router that handles the different routes to your page like so:\r\n\r\n```bash\r\nyoursite.com\r\n├── \"/\"             -yoursite.com/\r\n├── \"/about\"        -yoursite.com/about\r\n├── \"/contact\"      -yoursite.com/contact\r\n├── \"/news\"         -yoursite.com/news\r\n└── \"/investors\"    -yoursite.com/investors\r\n```\r\n\r\nSince this is at the root, this is your router at `\"\"` path. You can then add a router inside another router to have the following:\r\n\r\n```bash\r\nyoursite.com\r\n├── books           -yoursite.com/books\r\n|   ├── list        -yoursite.com/books/list\r\n|   ├── add         -yoursite.com/books/add\r\n|   ├── update      -yoursite.com/books/update\r\n|   └── delete      -yoursite.com/books/update\r\n├── about           -yoursite.com/about\r\n├── contact         -yoursite.com/contact\r\n├── news            -yoursite.com/news\r\n└── investors       -yoursite.com/investors\r\n```\r\n\r\nNow you have a router for the `\"/books\"` path inside another router for the `\"\"` path.\r\n\r\nNow to see it in code, create a Saturn project from the template and you will have a `Router.fs` file like this:\r\n\r\n*)\r\n\r\n\r\nopen Saturn\r\nopen Giraffe.Core\r\nopen Giraffe.ResponseWriters\r\n\r\n\r\nlet browser = pipeline {\r\n    plug acceptHtml\r\n    plug putSecureBrowserHeaders\r\n    plug fetchSession\r\n    set_header \"x-pipeline-type\" \"Browser\"\r\n}\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\nlet browserRouter = router {\r\n    not_found_handler (htmlView NotFound.layout) //Use the default 404 webpage\r\n    pipe_through browser //Use the default browser pipeline\r\n\r\n    forward \"\" defaultView //Use the default view\r\n}\r\n\r\n//Other scopes may use different pipelines and error handlers\r\n\r\n// let api = pipeline {\r\n//     plug acceptJson\r\n//     set_header \"x-pipeline-type\" \"Api\"\r\n// }\r\n\r\n// let apiRouter = router {\r\n//     not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n//     pipe_through api\r\n//\r\n//     forward \"/someApi\" someScopeOrController\r\n// }\r\n\r\nlet appRouter = router {\r\n    // forward \"/api\" apiRouter\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nFirst, take a look at the `router` function.\r\n\r\n*)\r\n\r\nlet appRouter' = router {\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nThe `appRouter` value is a `router`. Inside is the `forward \"\" browserRouter` line. The `forward` function needs a path and a router. In this case, the path is an empty string and the router is `browserRouter`. That means that the `browserRouter` router will handle the routes at the current location. Since `appRouter` is the first router called, the current location is the root of the application.\r\n\r\nNow let's look at `browserRouter`:\r\n\r\n*)\r\n\r\nlet browserRouter' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    forward \"\" defaultView\r\n}\r\n\r\n(**\r\n\r\nThere are three lines. The first line, `not_found_handler (htmlView NotFound.layout)` tells `browserRouter` to display a not found page if the user enters a route that the application does not handle. The second line tells the application to use the `browser` pipeline defined above. The pipeline is a list of settings on how the website will deliver the pages. Lastly, `forward \"\" defaultView` is like `forward \"\" browserRouter` from the `appRouter`. Again, `browserRouter` does not contain any routes but it tells the `defaultView` router to handle them. Finally, we get to the part where the application is told how to handle the routes. Inside `defaultView`, we created 3 routes:\r\n\r\n*)\r\n\r\nlet defaultView' = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nHere, we see that `get` is used to define the routes. There are 3 routes here but 2 of them redirect to the first route. To illustrate, the routes are:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            └── \"/default.html\"     -redirect to yoursite.com/\r\n```\r\n\r\nLooking at the first line inside `defaultView`, `get \"/\" (htmlView Index.layout)` tells the application to display `Index.layout` at the root of the application. The `get` corresponds to the HTTP verb GET so when you type in a link, the browser tries to GET the page. The first parameter of `get` is \"/\", so basically when getting the root, the `get` function will return something. The second parameter is `(htmlView Index.layout)` so the `get` function returns an HTML page specified by Index.layout. The second and third line have `(redirectTo false \"/\")`, telling the application to go to \"yoursite.com/\" when going to \"yoursite.com/index\" or \"yoursite.com/default\"\r\n\r\n## Best Practices\r\n\r\nYou can combine all 3 routers into one router like so:\r\n\r\n*)\r\n\r\n\r\nlet appRouter'' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nThe template splits them into 3 to encourage good practices. In the first router, you can see the commented out code `forward \"/api\" apiRouter`. This is a good suggestion in the template to have a separate router to handle your API routes. We set up how to deliever the webpage with `pipe_through browser` in `browserRouter`. The settings are important for a browser to know how to handle your routes but not for a different application to access your routes as an API.\r\n\r\nThe template provides an example of how to set up the API routes in the commented out code, which I copied below:\r\n\r\n*)\r\n\r\nlet api = pipeline {\r\n    plug acceptJson\r\n    set_header \"x-pipeline-type\" \"Api\"\r\n}\r\n\r\nlet apiRouter = router {\r\n    not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n    pipe_through api\r\n\r\n    forward \"/someApi\" someScopeOrController\r\n}\r\n\r\n(**\r\n\r\nHere we have the `apiRouter` router which does not return a 404 page but a 404 text instead which is appropriate for an API. The router also uses a pipeline that is more appropriate for an API such as accepting JSON inputs instead of HTML as in the `browser` pipeline.\r\n\r\n## Format Strings\r\n\r\nYou might be wondering how to make routes that accept a numerical ID. You can make multiple routes for each ID like so\r\n\r\n```fsharp\r\nget \"/1\" (getApplication 1)\r\nget \"/2\" (getApplication 2)\r\nget \"/3\" (getApplication 3)\r\n...\r\n```\r\n\r\nBut this is impracticle because there can be a large number of items or new items are constantly being created with new IDs. Instead the solution is to use format strings. Remember that in the [Adding Pages Guide](../tutorials/adding-pages.html), we used `getf \"/%s\" index2Action` to pass a string to page.\r\n\r\n| Format Char | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nFor a numerical ID, we want to pass an int which is `%i` in the list above, so you can replace the lines above with\r\n\r\n```fsharp\r\ngetf \"/%i\" getApplication\r\n```\r\n\r\nNotice that `getf` is used instead of get. This is a separate version of get that handles `f`ormat characters.\r\n\r\n    You can use format strings with \"forward\" too by using \"forwardf\"\r\n\r\n## API Reference\r\n\r\nFull API reference for `router` CE can be found [here](../reference/Saturn/saturn-router-routerbuilder.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/reference/Saturn.Extensions.Authorization/index.html","title":"Saturn.Extensions.Authorization - API Reference","content":"Saturn.Extensions.Authorization \n global"},{"uri":"https://saturnframework.org/reference/Saturn.Extensions.Authorization/global-saturn.html","title":"Saturn","content":"Saturn \n  \n  \n  \n  \n UseGoogleAuth <p>Enables default Google OAuth authentication.\r\n<code>jsonToClaimMap</code> should contain sequance of tuples where first element is a name of the of the key in JSON object and second element is a name of the claim.\r\nFor example: <code>[\"id\", ClaimTypes.NameIdentifier; \"displayName\", ClaimTypes.Name]</code> where <code>id</code> and <code>displayName</code> are names of fields in the Google JSON response (<a href=\"https://developers.google.com/+/web/api/rest/latest/people#resource).\">https://developers.google.com/+/web/api/rest/latest/people#resource).</a></p>\r\n\r\n UseGoogleAuthWithConfig <p>Enables Google OAuth authentication with custom configuration</p>\r\n\r\n UseGithubAuth <p>Enables default GitHub OAuth authentication.\r\n<code>jsonToClaimMap</code> should contain sequance of tuples where first element is a name of the of the key in JSON object and second element is a name of the claim.\r\nFor example: <code>[\"login\", \"githubUsername\"; \"name\", \"fullName\"]</code> where <code>login</code> and <code>name</code> are names of fields in GitHub JSON response (<a href=\"https://developer.github.com/v3/users/#get-the-authenticated-user).\">https://developer.github.com/v3/users/#get-the-authenticated-user).</a></p>\r\n\r\n UseGithubAuthWithConfig <p>Enables GitHub OAuth authentication with custom configuration</p>\r\n\r\n UseAzureADAuth <p>Enalbes default Azure AD OAuth authentication.\r\n<code>scopes</code> must be at least on of the scopes defined in <a href=\"https://docs.microsoft.com/en-us/graph/permissions-reference,\">https://docs.microsoft.com/en-us/graph/permissions-reference,</a> for instance \"User.Read\".\r\n<code>jsonToClaimMap</code> should contain sequance of tuples where first element is a name of the of the key in JSON object and second element is a name of the claim.\r\nFor example: <code>[\"name\", \"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\" ]</code> where <code>name</code> is the names of a field in Azure AD's JSON response (see <a href=\"https://docs.microsoft.com/en-us/azure/active-directory/develop/id-tokens\">https://docs.microsoft.com/en-us/azure/active-directory/develop/id-tokens</a> or inspect tokens with <a href=\"https://jwt.ms).\">https://jwt.ms).</a></p>\r\n\r\n UseAzureADAuthWithConfig <p>Enables AzureAD OAuth authentication with custom configuration</p>\r\n\r\n UseOpenIdAuthWithConfig <p>Enables OpenId authentication with custom configuration</p>\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/directory-structure.html","title":"Directory Structure","content":"\r\n# Directory Structure\r\n\r\nAfter creating a new Saturn project, let's take a deeper look into what files are created.\r\n\r\n```bash\r\n├── .fake\r\n├── .paket\r\n├── .vs\r\n├── .packages\r\n├── paket-files\r\n├── src\r\n|   ├── Migrations\r\n|   └── SaturnSample\r\n├── .gitignore\r\n├── build.fsx\r\n├── global.json\r\n├── paket.dependencies\r\n├── paket.lock\r\n└── SaturnSample.sln\r\n```\r\n\r\nAt this level most of it is basic configuration files to help with running Saturn. From looking at the `.paket`, `paket-files`, `paket.dependencies`, `paket.lock` folders and files, you can see that by default Saturn uses [paket](https://fsprojects.github.io/Paket/) to handle package management. You won't be working with these files directly but rather through the command line tools instead.\r\n\r\nSaturn also uses [FAKE](https://fake.build/) to build the project. You can see how it is set up by looking at the `.fake` folder and `build.fsx` file.\r\n\r\nSaturn also provides a `.gitignore` file that prevents some folders from being tracked by git when they don't need to.\r\n\r\nLastly, there is the `SaturnSample.sln` solution file so you can open the project in an IDE like Visual Sudio and a `global.json` file to configure the solution file.\r\n\r\n### Project structure\r\n\r\nMost of the work you will do in this project however, will be in `src/SaturnSample`, which looks like the following when expanded:\r\n\r\n```bash\r\n  ├── bin\r\n  ├── Books\r\n  |   ├── BooksController.fs\r\n  |   ├── BooksModel.fs\r\n  |   ├── BooksRepository.fs\r\n  |   └── BooksView.fs\r\n  ├── obj\r\n  ├── static\r\n  |   ├── app.css\r\n  |   └── app.js\r\n  ├── Templates\r\n  |   ├── App.fs\r\n  |   ├── Index.fs\r\n  |   ├── InternalError.fs\r\n  |   └── NotFound.fs\r\n  ├── Config.fs\r\n  ├── Database.fs\r\n  ├── database.sqlite\r\n  ├── paket.references\r\n  ├── Program.fs\r\n  ├── Router.fs\r\n  └── SaturnSample.fsproj\r\n```\r\n\r\n`bin` and `obj` folders store the compiled version of the program after you build the project.\r\n\r\nThe convention for Saturn is that the model and everything associated with it are inside one folder. Everything is also named with the plural form of the model so \"Books\" instead of \"Book\".\r\n\r\nYour static files like css, js, and images should be inside the `static` folder.\r\n\r\n`Config.fs` contains a `Config` record that stores settings that you can use inside your application. By default, the record only contains the `connectionString` field.\r\n\r\n`Database.fs` contains functions to execute SQL queries within the program through [Dapper](https://stackexchange.github.io/Dapper/).\r\n\r\nIf you did not run `dotnet saturn migration` as in the [how to start guide](../tutorials/how-to-start.html), you might not see `database.sqlite`, but that is the database file that your Saturn project is using to store data.\r\n\r\n`paket.references` shows the packages that your project is using.\r\n\r\n`Program.fs` handles intializing the program and loading up various settings.\r\n\r\n`Router.fs` is where you will set the route of the site and what page to load.\r\n\r\nLastly, `SaturnSample.fsproj` is the project file itself."},{"uri":"https://saturnframework.org/explanations/endpoint-routing.html","title":"Endpoint Routing","content":"\r\n# Endpoint Routing\r\n\r\nSaturn from version `0.15` supports [ASP.NET Endpoint Routing](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1) additionally to custom routing implementation provided by Giraffe. The main difference between old routing and new one is that Endpoint Routing assumes total separation of routing from behavior - it works by statically defining list of all possible routes on startup of application. This impacts design of some of our Saturn abstractions, and means new routing is not 100% compatible with old one. On the bright side, theoretically, Endpoint Routing should provide noticeable performance boost, and in the future it will allow for better ecosystem integration.\r\n\r\n> Currently endpoint routing API is treated as an experimental API - it's subject to changes.\r\n\r\nTo use Endpoint Routing you need to open `Saturn.Endpoint` namespace - this will override known `router` and `controller` Computation Expressions with their Endpoint Routing versions. In `application` CE instead of using `use_router` operation you should use `use_endpoint_router` operation. For many simple applications this may be enough to get things working - we've been trying to keep API as compatible as possible.\r\n\r\nHowever there are differences:\r\n\r\n* With Endpoint Routing `router` and `controller` computation expressions are not transformed to `HttpHandler` but rather to `Endpoint list`. This has a huge impact on composability of those abstractions - you can't do things like `myHttpHandler >=> router { ... }` any more. Such code should be replaced with `plug/pipe_through` functionality in both `router` and `controller`. `Endpoint list` can basically be used in 2 places - in `forward` operation in `router` and `use_endpoint_router` in `application`.\r\n* Lack of `subroutef` in Giraffe-EndpointRouting - beacuse EndpointRouting needs to have all possible route templates at the application startup it's really hard to emulate some of previous Giraffe's routing composibility capabilities. From Saturn point of view this created 2 major changes:\r\n  - there's no `forwardf` in `router` CE anymore - it should be replaced with set of `getf/postf/putf ... ` operations in child router.\r\n  - `subController` in `controller` CE doesn't work well in Endpoint Routing - you can use as subcontrollers only old, HttpHandler based controllers (even if you parent controller is Endpoint Routing controller). In `Saturn.Endpoint` we provide additonal `subcontroller` CE - it's an alias to old `controller` CE\r\n* Lack of `case_insensitive` in `router` and `controller` - with Endpoint Routing all routes are case insensitive by default and there's no easy way to change it\r\n* Lack of `not_found_handler` in `router` and `controller` - as Endpoint Routing creates global table of routing having scoped not-found handlers is really tricky. Use built-in ways of handle 404 in ASP.NET (such as `UseDeveloperExceptionPage`)\r\n* Unlike Giraffe routing, Endpoint Routing doesn't ensure order of routing checks - this shouldn't be a problem in most cases, but I can imagine some edge cases in which this would matter.\r\n\r\nIn general, to reiterate - Endpoint Routing API in Giraffe/Saturn is still experimental. However, it probably is a future of Giraffe/Saturn so if possible please check if your applications can move to the Endpoint Routing API, and try it out. It's important for everyone involved to get feedback on this new routing engine."},{"uri":"https://saturnframework.org/explanations/overview.html","title":"Saturn Overview","content":"\r\n# Saturn Overview\r\n\r\nSaturn is a web development framework written in F# which implements the server-side MVC pattern. Many of its components and concepts will seem familiar to those of us with experience in other web frameworks like Ruby on Rails or Python’s Django. It's heavily inspired by Elixir's [Phoenix](http://phoenixframework.org/).\r\n\r\nBuilt on top of the battle-tested ASP.NET Core foundation and the highly flexible, extendable model of Giraffe, Saturn provides high level abstractions, helpers and tools to enable high developer productivity, at the same time keeping high application performance provided by Kestrel and Giraffe.\r\n\r\nSaturn is made up of a number of distinct parts, each with its own purpose and role to play in building a web application.\r\n\r\n - Application\r\n    - the start and end of the request life cycle\r\n    - handles all aspects of requests up until the point where the router takes over\r\n    - provides a core set of plugs to apply to all requests\r\n    - dispatches requests into a router\r\n    - enables application and hosting configuration\r\n - [Router](routing.html)\r\n    - parses incoming requests and dispatches them to the correct controller/action, passing parameters as needed\r\n    - provides helpers to generate route paths or urls to resources\r\n    - defines named pipelines through which we may pass our requests\r\n    - allows easy application of groups of plugs to a set of routes\r\n - [Controllers](controller.html)\r\n    - provide functions, called *actions*, to handle requests\r\n    - actions:\r\n        - prepare data and pass it into views\r\n        - invoke rendering via views\r\n        - perform redirects\r\n        - return data as JSON or XML\r\n        - and much more\r\n - [Views](view.html)\r\n    - render templates\r\n    - act as a presentation layer\r\n    - define helper functions, available in templates, to decorate data for presentation\r\n - Channels\r\n    - manage sockets for easy realtime communication\r\n    - are analogous to controllers except that they allow bi-directional communication with persistent connections\r\n - [Scaffolding scripts](scaffolding.html)\r\n    - `dotnet new` template providing good starting point for new applications - [https://github.com/SaturnFramework/Saturn.Template](https://github.com/SaturnFramework/Saturn.Template)\r\n    - `dotnet saturn` CLI tool that controls migrations and let you easily scaffold new parts of application - [https://github.com/SaturnFramework/Saturn.Dotnet](https://github.com/SaturnFramework/Saturn.Dotnet)\r\n\r\n\r\n### Saturn rings\r\n\r\nSaturn itself is the top layer of a multi-layer system designed to create a flexible, productive environment for creating web applications.\r\n\r\n#### Kestrel and ASP.NET Core\r\n\r\nASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-based, Internet-connected applications. Kestrel is a cross-platform web server for ASP.NET Core based on `libuv`, a cross-platform asynchronous I/O library. ASP.NET Core documentation can be found [here](https://docs.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-3.1)\r\n\r\n#### [Giraffe](https://github.com/giraffe-fsharp/Giraffe)\r\n\r\nGiraffe is an F# micro web framework for building rich web applications. It has been heavily inspired and is similar to [Suave](https://suave.io), but has been specifically designed with ASP.NET Core in mind and can be plugged into the ASP.NET Core pipeline via middleware. Giraffe applications are composed of so-called HttpHandler functions which can be thought of as a mixture of Suave's WebParts and ASP.NET Core's middleware. As Saturn shares many basic helper functions with Giraffe it's highly recommended to also check out [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n\r\n### Saturn moons\r\n\r\nSaturn is not only a library building on top of Giraffe, but also a set of opinionated tooling for scaffolding a whole project and then generating some boilerplate code. At the moment our template is using (by default):\r\n\r\n#### [Dapper](https://github.com/StackExchange/Dapper)\r\n\r\nA simple, focused on performance object mapper for .Net that you can add in to your project and will extend your `IDbConnection` interface.\r\n\r\n#### [Simple.Migrations](https://github.com/canton7/Simple.Migrations)\r\n\r\nSimple.Migrations is a simple bare-bones migration framework for .NET Core (.NET Standard 1.2 and .NET 4.5). It doesn't provide SQL generation, nor an out-of-the-box command-line tool, nor any other fancy feature. It does however provide a set of simple, extendable, and composable tools for integrating migrations into your application.\r\n\r\n\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/scaffolding.html","title":"Scaffolding","content":"\r\n# Scaffolding\r\n\r\nSaturn provides a command line scaffolding tool to generate a model, database migration, controller, and associated views.\r\n\r\nTo use the generator, run the `dotnet saturn` command from the root of your application application.  If you have used the template to generate your project, this is the directory with `build.fsx` or `paket.dependencies` file.\r\n\r\nThere are three flavors of generators that provide flexibility about what types of code is generated to support your model.\r\n\r\n| Command      |  Generates                                                                     |\r\n|--------------|--------------------------------------------------------------------------------|\r\n| gen          | Creates a model, database layer, HTML views, and a controller.                 |\r\n| gen.json     | Creates a model, database layer, and an API controller to access the model.    |\r\n| gen.model    | Creates only the model and database layer (no controller or views)             |\r\n\r\nEach of these commands will generate a migration for your model as well as a folder containing generated files.\r\n\r\nFor example:\r\n\r\n`dotnet saturn gen Book Books id:string title:string`\r\n\r\nGenerates the following structure:\r\n\r\n```bash\r\nsrc\r\n├── Migrations\r\n│   └── 201903192143.Book.fs\r\n│\r\n└── SaturnSample\r\n    └── Books\r\n        ├── BooksController.fs\r\n        ├── BooksModel.fs\r\n        ├── BooksRepository.fs\r\n        └── BooksViews.fs\r\n```\r\n\r\nEach of the generators takes arguments in the same format:\r\n\r\n`dotnet saturn gen <SingularModelName> <PluralModelName> <List of model fields with types>`\r\n\r\nThe list of model fields are names and types separated by a colon.\r\n\r\n`<fieldname>:<type>`\r\n\r\nCurrently supported types are:\r\n\r\n* string\r\n* int\r\n* float\r\n* double\r\n* decimal\r\n* guid\r\n* datetime\r\n* bool\r\n\r\n## Migrations\r\n\r\nUsing the generator to create a model will also create a migration file that will create a supporting table in the database. Execute the migration script using:\r\n\r\n`dotnet saturn migration`"},{"uri":"https://saturnframework.org/explanations/view.html","title":"View Engine","content":"\r\n# View Engine\r\n\r\n> This post has been originally part of the [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine)\r\n\r\nSaturn is built on top of Giraffe and can use any helpers it provides. This is a case for suggested view engine that you can use in Saturn - Giraffe has its own functional view engine which can be used to build rich UIs for web applications. The single biggest and best contrast to other view engines (e.g. Razor, Liquid, etc.) is that the Giraffe View Engine is entirely functional written in normal (and compiled) F# code.\r\n\r\nThis means that the Giraffe View Engine is by definition one of the most feature rich view engines available, requires no disk IO to load a view and views are automatically compiled at build time.\r\n\r\nThe Giraffe View Engine uses traditional functions and F# record types to generate rich HTML/XML views.\r\n\r\n### HTML Elements and Attributes\r\n\r\nHTML elements and attributes are defined as F# objects:\r\n\r\n```fsharp\r\nlet indexView =\r\n    html [] [\r\n        head [] [\r\n            title [] [ str \"Giraffe Sample\" ]\r\n        ]\r\n        body [] [\r\n            h1 [] [ str \"I |> F#\" ]\r\n            p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                str \"Hello World\"\r\n            ]\r\n        ]\r\n    ]\r\n```\r\n\r\nA HTML element can either be a `ParentNode`, a `VoidElement` or a `Text` element.\r\n\r\nFor example the `<html>` or `<div>` tags are typical `ParentNode` elements. They can hold an `XmlAttribute list` and a second `XmlElement list` for their child elements:\r\n\r\n```fsharp\r\nlet someHtml = div [] []\r\n```\r\n\r\nAll `ParentNode` elements accept these two parameters:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [ _id \"someId\"; _class \"css-class\" ] [\r\n        a [ _href \"https://example.org\" ] [ str \"Some text...\" ]\r\n    ]\r\n```\r\n\r\nMost HTML tags are `ParentNode` elements, however there is a few HTML tags which cannot hold any child elements, such as `<br>`, `<hr>` or `<meta>` tags. These are represented as `VoidElement` objects and only accept the `XmlAttribute list` as single parameter:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        br []\r\n        hr [ _class \"css-class-for-hr\" ]\r\n        p [] [ str \"bla blah\" ]\r\n    ]\r\n```\r\n\r\nAttributes are further classified into two different cases. First and most commonly there are `KeyValue` attributes:\r\n\r\n```fsharp\r\na [\r\n    _href \"http://url.com\"\r\n    _target \"_blank\"\r\n    _class \"class1\" ] [ str \"Click here\" ]\r\n```\r\n\r\nAs the name suggests, they have a key, such as `class` and a value such as the name of a CSS class.\r\n\r\nThe second category of attributes are `Boolean` flags. There are not many but some HTML attributes which do not require any value (e.g. `async` or `defer` in script tags). The presence of such an attribute means that the feature is turned on, otherwise it is turned off:\r\n\r\n```fsharp\r\nscript [ _src \"some.js\"; _async ] []\r\n```\r\n\r\nThere's also a wealth of [accessibility attributes](https://www.w3.org/TR/html-aria/) available under the `Giraffe.GiraffeViewEngine.Accessibility` module (needs to be explicitly opened).\r\n\r\n### Text Content\r\n\r\nNaturally the most frequent content in any HTML document is pure text:\r\n\r\n```html\r\n<div>\r\n    <h1>This is text content</h1>\r\n    <p>This is even more text content!</p>\r\n</div>\r\n```\r\n\r\nThe Giraffe View Engine lets one create pure text content as a `Text` element. A `Text` element can either be generated via the `rawText` or `encodedText` (or the short alias `str`) functions:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        p [] [ rawText \"<div>Hello World</div>\" ]\r\n        p [] [ encodedText \"<div>Hello World</div>\" ]\r\n    ]\r\n```\r\n\r\nThe `rawText` function will create an object of type `XmlNode` where the content will be rendered in its original form and the `encodedText`/`str` function will output a string where the content has been HTML encoded.\r\n\r\nIn this example the first `p` element will literally output the string as it is (`<div>Hello World</div>`) while the second `p` element will output the value as HTML encoded string `&lt;div&gt;Hello World&lt;/div&gt;`.\r\n\r\nPlease be aware that the the usage of `rawText` is mainly designed for edge cases where someone would purposefully want to inject HTML (or JavaScript) code into a rendered view. If not used carefully this could potentially lead to serious security vulnerabilities and therefore should be used only when explicitly required.\r\n\r\nMost cases and particularly any user provided content should always be output via the `encodedText`/`str` function.\r\n\r\n### Javascript event handlers\r\n\r\nIt is possible to add JavaScript event handlers to HTML elements using the Giraffe View Engine.  These event handlers (all prefixed with names starting with `_on`, for example `_onclick`, `_onmouseover`) can either execute inline JavaScript code or can invoke functions that are part of the `window` scope.\r\n\r\nThis example illustrates how inline JavaScript could be used to log to the console when a button is clicked:\r\n\r\n```fsharp\r\nlet inlineJSButton =\r\n    button [_id \"inline-js\"\r\n            _onclick \"console.log(\\\"Hello from the 'inline-js' button!\\\");\"] [str \"Say Hello\" ]\r\n```\r\n\r\nThere are some caveats with this approach, namely that\r\n* it is not very scalable to write JavaScript inline in this manner, and more pressing\r\n* the Giraffe View Engine HTML-encodes the text provided to the `_onX` attributes.\r\n\r\nTo get around this, you can write dedicated scripts in your HTML and reference the functions from your event handlers:\r\n\r\n```fsharp\r\nlet page =\r\n    div [] [\r\n        script [_type \"application/javascript\"] [\r\n            rawText \"\"\"\r\n            window.greet = function () {\r\n                console.log(\"ping from the greet method\");\r\n            }\r\n            \"\"\"\r\n        ]\r\n        button [_id \"script-tag-js\"\r\n                _onclick \"greet();\"] [str \"Say Hello\"]\r\n    ]\r\n```\r\n\r\nHere it's important to note that we've included the text of our script using the `rawText` tag.  This ensures that our text is not encoded by Giraffe so that it remains as we have written it.\r\n\r\nHowever, writing large quantities of JavaScript in this manner can be difficult, because you don't have access to the large ecosystem of javascript editor tooling.  In this case you should write your functions in another script and use a `script` tag element to reference your script, then add the desired function to your HTML element's event handler.\r\n\r\nSay you had a JavaScript file named `greet.js` and had configured Giraffe to serve that script from the WebRoot. Let us also say that the content of that script was:\r\n\r\n```javascript\r\nfunction greet() {\r\n    console.log(\"Hello from the greet function of greet.js!\");\r\n}\r\n```\r\n\r\nThen, you could reference that javascript via a script element, and use `greet` in your event handler like so:\r\n\r\n```fsharp\r\nlet page =\r\n    html [] [\r\n        head [] [\r\n            script [_type \"application/javascript\"\r\n                    _src \"/greet.js\"] [] // include our `greet.js` function dynamically\r\n        ]\r\n        body [] [\r\n            button [_id \"greet-btn\"\r\n                    _onclick \"greet()\"] [] // use the `greet()` function from `greet.js` to say hello\r\n        ]\r\n    ]\r\n```\r\n\r\nIn this way, you can write `greet.js` with all of your expected tooling, and still hook up the event handlers all in one place in Giraffe.\r\n\r\n### Naming Convention\r\n\r\nThe Giraffe View Engine has a naming convention which lets you easily determine the correct function name without having to know anything about the view engine's implementation.\r\n\r\nAll HTML tags are defined as `XmlNode` elements under the exact same name as they are named in HTML. For example the `<html>` tag would be `html [] []`, an `<a>` tag would be `a [] []` and a `<span>` or `<canvas>` would be the `span [] []` or `canvas [] []` function.\r\n\r\nHTML attributes follow the same naming convention except that attributes have an underscore prepended. For example the `class` attribute would be `_class` and the `src` attribute would be `_src` in Giraffe.\r\n\r\nThe underscore does not only help to distinguish an attribute from an element, but also avoid a naming conflict between tags and attributes of the same name (e.g. `<form>` vs. `<input form=\"form1\">`).\r\n\r\nIf a HTML attribute has a hyphen in the name (e.g. `accept-charset`) then the equivalent Giraffe attribute would be written in camel case notion (e.g. `acceptCharset`).\r\n\r\n*Should you find a HTML tag or attribute missing in the Giraffe View Engine then you can either [create it yourself](#custom-elements-and-attributes) or send a [pull request on GitHub](https://github.com/giraffe-fsharp/Giraffe/pulls).*\r\n\r\n### View Engine Best Practices\r\n\r\nDue to the huge amount of available HTML tags and their fairly generic (and short) names (e.g. `<form>`, `<option>`, `<select>`, etc.) there is a significant danger of accidentally overriding a function of the same name in an application's codebase. For that reason the Giraffe View Engine becomes only available after opening the `GiraffeViewEngine` module.\r\n\r\nAs a measure of good practice it is recommended to create all views in a separate module:\r\n\r\n```fsharp\r\nmodule MyWebApplication\r\n\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let index =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str \"Giraffe Sample\" ]\r\n            ]\r\n            body [] [\r\n                h1 [] [ str \"I |> F#\" ]\r\n                p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                    str \"Hello World\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let other = //...\r\n```\r\n\r\nThis ensures that the opening of the `GiraffeViewEngine` is only contained in a small context of an application's codebase and therefore less of a threat to accidental overrides. In the above example views can always be accessed through the `Views` sub module (e.g. `Views.index`).\r\n\r\n### Custom Elements and Attributes\r\n\r\nAdding new elements or attributes is normally as simple as a single line of code:\r\n\r\n```fsharp\r\nopen Giraffe.GiraffeViewEngine\r\n\r\n// If there was a new <foo></foo> HTML element:\r\nlet foo = tag \"foo\"\r\n\r\n// If <foo> is an element which cannot hold any content then create it as voidTag:\r\nlet foo = voidTag \"foo\"\r\n\r\n// If <foo> has a new attribute called bar then create a new bar attribute:\r\nlet _bar = attr \"bar\"\r\n\r\n// if the bar attribute is a boolean flag:\r\nlet _bar = flag \"bar\"\r\n```\r\n\r\nAlternatively you can also create new elements and attributes from inside another element:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n```\r\n\r\n### Rendering Views\r\n\r\nRendering views in Giraffe is done through one of the following functions:\r\n\r\n- `renderHtmlDocument`\r\n- `renderHtmlNodes`\r\n- `renderHtmlNode`\r\n- `renderXmlNodes`\r\n- `renderXmlNode`\r\n\r\nThe Giraffe View Engine cannot only be used to render HTML views, but also for any other XML based content such as `<svg>` images or other arbitrary XML based data.\r\n\r\nThe `renderHtmlDocument` function takes a single `XmlNode` as input parameter and renders a HTML page with a `DOCTYPE` declaration. This function should be used for rendering a complete HTML document. The `WriteHtmlViewAsync` extension method and the `htmlView` http handler both use the `renderHtmlDocument` function under the covers.\r\n\r\nThe `renderHtmlNodes` function takes an `XmlNode list` as input parameter and will output a single HTML string containing all the rendered HTML code. The `renderHtmlNode` function renders a single `XmlNode` element into a valid HTML string. Both, the `renderHtmlNodes` and `renderHtmlNode` function are useful for use cases where a HTML snippet needs to be created without a `DOCTYPE` declaration (e.g. templated emails, etc.).\r\n\r\nThe `renderXmlNodes` and `renderXmlNode` function are identical to `renderHtmlNodes` and `renderHtmlNode`, except that they will render void elements differently:\r\n\r\n```fsharp\r\nlet someTag = voidTag \"foo\"\r\nlet someContent = someTag []\r\n\r\n// Void tag will be rendered to valid HTML: <foo>\r\nlet output1 = renderHtmlNode someContent\r\n\r\n// Void tag will be rendered to valid XML: <foo />\r\nlet output2 = renderXmlNode someContent\r\n```\r\n\r\nAll `GiraffeViewEngine` http handlers are using a thread static `StringBuilderPool` to avoid the creation of large `StringBuilder` objects for each render call and dynamically grow/shrink that pool based on the application's needs. However if the application is running into any memory issues then this performance feature can be disabled by setting `StringBuilderPool.IsEnabled <- false`.\r\n\r\nAdditionally with Giraffe 3.0.0 or higher there is a new module called `ViewBuilder` under the `Giraffe.GiraffeViewEngine` namespace. This module exposes additional view rendering functions which compile a view into a `StringBuilder` object instead of returning a single `string`:\r\n\r\n- `ViewBuilder.buildHtmlDocument`\r\n- `ViewBuilder.buildHtmlNodes`\r\n- `ViewBuilder.buildHtmlNode`\r\n- `ViewBuilder.buildXmlNodes`\r\n- `ViewBuilder.buildXmlNode`\r\n\r\nThe `ViewBuilder.build[...]` functions can be useful if there is additional string processing required before/after composing a view by the `GiraffeViewEngine` (e.g. embedding HTML snippets in an email template, etc.). These functions also serve as the lower level building blocks of the equivalent `render[...]` functions.\r\n\r\nExample usage:\r\n\r\n```fsharp\r\nopen System.Text\r\nopen Giraffe.GiraffeViewEngine\r\n\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n\r\nlet sb = new StringBuilder()\r\n\r\n// Perform actions on the `sb` object...\r\nsb.AppendLine \"This is a HTML snippet inside a markdown string:\"\r\n  .AppendLine \"\"\r\n  .AppendLine \"```html\" |> ignore\r\n\r\nlet sb' = ViewBuilder.buildHtmlNode sb someHtml\r\n\r\n// Perform more actions on the `sb` object...\r\nsb'.AppendLine \"```\" |> ignore\r\n\r\nlet markdownOutput = sb'.ToString()\r\n```\r\n\r\n### Common View Engine Features\r\n\r\nThe Giraffe View Engine doesn't have any specially built functions for commonly known features such as master pages or partial views, mainly because the nature of the view engine itself doesn't require it in most cases.\r\n\r\n#### Master Pages\r\n\r\nCreating a master page is a simple matter of piping two functions together:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n... or even have multiple nested master pages:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master1 (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let master2 (content: XmlNode list) =\r\n        [\r\n            main [] content\r\n            footer [] [\r\n                p [] [\r\n                    str \"Copyright ...\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master2 |> master1 pageTitle\r\n```\r\n\r\n#### Partial Views\r\n\r\nA partial view is nothing more than one function or object being called from within another function:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n#### Working with Models\r\n\r\nA view which accepts a model is basically a function with an additional parameter:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index (model : IndexViewModel) =\r\n        [\r\n            h1 [] [ str model.PageTitle ]\r\n            p [] [ str model.WelcomeText ]\r\n        ] |> master model.PageTitle\r\n```\r\n\r\n#### If Statements, Loops, etc.\r\n\r\nThings like if statements, loops and other normal F# language constructs work just as expected:\r\n\r\n```fsharp\r\nlet partial (books : Book list) =\r\n    ul [] [\r\n        yield!\r\n            books\r\n            |> List.map (fun b -> li [] [ str book.Title ])\r\n    ]\r\n```\r\n\r\nOverall the Giraffe View Engine is extremely flexible and feature rich by nature based on the fact that it is generated via normal compiled F# code."},{"uri":"https://saturnframework.org/tutorials/adding-pages.html","title":"Adding Pages","content":"\r\n# Adding Pages\r\n\r\nThis guide uses the same project from the [how to start guide](how-to-start.html). Let's add two pages to it - one hello page and a page that can get your name from the URL.\r\n\r\n## Creating the View\r\n\r\nTo begin, create a `Hello` folder inside the `src/SaturnSample` folder.\r\n\r\nInside the folder, create a new file called \"HelloViews.fs\". This file will contain the functions to create the page.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Giraffe.GiraffeViewEngine\r\nopen Saturn\r\n\r\nmodule Views =\r\n  let index =\r\n    div [] [\r\n        h2 [] [rawText \"Hello from Saturn!\"]\r\n    ]\r\n```\r\n\r\nOne of the dependencies required is [Giraffe View Engine](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine). This will allow your project to define HTML within your function. The `index` function will result in the following HTML code:\r\n\r\n```html\r\n<div>\r\n    <h2>Hello from Saturn!</h2>\r\n</div>\r\n```\r\n\r\n## Creating the Controller\r\n\r\nCreate a `HelloController.fs` file inside the `Hello` folder.\r\n\r\nThe `index` function tells us what the HTML will be but we still need to tell Saturn to return it as an HTML page. We also need to tell Saturn where the page is.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Saturn\r\nopen Giraffe.ResponseWriters\r\n\r\nmodule Controller =\r\n    let indexAction =\r\n        htmlView (Views.index)\r\n\r\n    let helloView = router {\r\n        get \"/\" indexAction\r\n    }\r\n```\r\n\r\nThe `indexAction` tells Saturn to create an HTML page using the `index` function inside \"HelloViews.fs\"\r\n\r\n`helloView` lets Saturn know that the page is located at the root.\r\n\r\n## Adding the 2 new files to the project\r\n\r\nFor the project to see the new files, modify SaturnSample.fsproj as below:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <Compile Include=\"Database.fs\" />\r\n    <Compile Include=\"Config.fs\" />\r\n\r\n    <Compile Include=\"Hello\\HelloViews.fs\" />\r\n    <Compile Include=\"Hello\\HelloController.fs\" />\r\n    ...\r\n```\r\n\r\n## Adding it to Router.fs\r\n\r\n\r\nAfter setting up the route, you need to update the project with the new route.\r\n\r\nIn \"Router.fs\", add the following to the inside of the `browserRouter` function:\r\n\r\n\r\n```fsharp\r\nforward \"/hello\" Hello.Controller.helloView\r\n```\r\n\r\nThis means that when we navigate to [http://localhost:8085/hello](http://localhost:8085/hello), the `helloView` function will determine what page to load there. Looking inside the `helloView` function, we said that `indexAction` is called at the root. In conclusion, the page will be located at [http://localhost:8085/hello/](http://localhost:8085/hello/). (Note the \"/\" at the end)\r\n\r\nNow run the program and go to [http://localhost:8085/hello/](http://localhost:8085/hello/) and you will see a page saying \"Hello from Saturn!\"\r\n\r\n## Sending a parameter to your page\r\n\r\nWhat if you want the page to display your name?\r\n\r\nOne way to retrieve your name is to get it from the route. So when you go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) with {yourname} being your actual name, it will grab your name which can then be used to display on the page.\r\n\r\nTo begin, add a new view in your `HelloViews.fs`:\r\n\r\n```fsharp\r\n  let index2 (name : string) =\r\n    div [] [\r\n        h2 [] [rawText (\"Hello \" + name + \"!\")]\r\n    ]\r\n```\r\n\r\nThis function requires passing in the name to be displayed. The name will be retrieved from the route.\r\n\r\nAdd the following to the `HelloController.fs` file below the `helloView` handler:\r\n\r\n```fsharp\r\nlet index2Action name=\r\n    htmlView (Hello.Views.index2 name)\r\n```\r\n\r\nNow to set up the route. Add the following to the `HelloView` handler:\r\n\r\n```fsharp\r\ngetf \"/%s\" index2Action\r\n```\r\n\r\n\"%s\" is a format string. This lets Saturn know to save whatever you type in that spot. Since we want to save a name, we want to save it as a string so we use `%s`.\r\n\r\nThere are other format strings for different types:\r\n\r\n| Format String | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nNow run the program and go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) and replace `{yourname}` with your name to see a page that will greet you.\r\n"},{"uri":"https://saturnframework.org/tutorials/adding-saturn-to-an-existing-giraffe-app.html","title":"Adding Saturn to an existing Giraffe application","content":"\r\n# Adding Saturn to an existing Giraffe application\r\n\r\nThe previous chapter showed how to get started with a new application.\r\n\r\nIf you already have a working Giraffe webserver, you can gradually opt-in to Saturn.\r\n\r\nFor example, if your existing app looks like this:\r\n\r\n```fsharp\r\n\r\ntype Customer = {\r\n    Name : string\r\n    Address : string\r\n}\r\n\r\nlet customers =\r\n    choose [\r\n      GET >=> (json { Name = \"Mr. Smith\"; Address = \"Santa Monika\"})\r\n      PUT >=> (bindJson<Customer> (fun customer -> printfn \"Adding customer %A\" customer; setStatusCode 200))\r\n    ]\r\n\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"               >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n    ]\r\n```\r\n\r\nand you need to add \"vendor\" functionality, you could implement it as a Saturn ``router`` while keeping everything else intact:\r\n\r\n\r\n```fsharp\r\n// the new Saturn router\r\nlet vendors = router {\r\n    getf \"/%i\" (fun vendorId -> (json (readVendorFromDb vendorId)))\r\n    post \"/\" (bindJson<Vendor> (fun customer -> addVendor vendor; setStatusCode 200))\r\n}\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"                >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n        // plug the new Saturn router into the Giraffe app\r\n        route \"/api/vendors\"     >=> vendors\r\n    ]\r\n```\r\n\r\n## Embedding Giraffe Handlers into Saturn\r\n\r\nOf course the other way around also works.\r\n\r\nFor example, [Elmish.Bridge](https://github.com/Nhowka/Elmish.Bridge) does not provide a specialized implementation for Saturn. And it doesn't need to, because we can just use the Giraffe implementation!\r\n\r\n```fsharp\r\n\r\nopen Elmish\r\nopen Elmish.Bridge\r\n\r\nlet elmishBridgeHandler : HttpHandler =\r\n  Bridge.mkServer Shared.endpoint init update\r\n  |> Bridge.run Giraffe.server\r\n\r\n// our existing Saturn router\r\nlet router = router {\r\n\r\n    // ...\r\n\r\n    forward \"\" elmishBridgeHandler\r\n}\r\n```\r\n"},{"uri":"https://saturnframework.org/tutorials/how-to-start.html","title":"Getting started","content":"\r\n# How to start in 60 seconds\r\n\r\nRequirements:\r\n\r\n* `dotnet` SDK 3.1 [https://dotnet.microsoft.com/download/dotnet-core/3.1](https://dotnet.microsoft.com/download/dotnet-core/3.1)\r\n\r\n## Template\r\n\r\nThe easiest way to get started is to use the provided template:\r\n\r\n1. Install the `dotnet` template with `dotnet new -i Saturn.Template`\r\n2. Create a new folder and move into it - `mkdir SaturnSample && cd SaturnSample`\r\n3. Create a new Saturn application - `dotnet new saturn -lang F#`\r\n4. Install all necessary dev tools - `dotnet tool restore`\r\n6. Create a new controller with `dotnet saturn gen Book Books id:string title:string author:string`\r\n7. Run migrations that will create the database and Books table (as for now, the generator is using only SQLite DB) - `dotnet saturn migration`\r\n8. Open the folder in your favourite editor (VSCode) and insert the line (`forward \"/books\" Books.Controller.resource`) into `browserRouter` in `Router.fs` file\r\n9. Start the application by running `dotnet fake build -t run` from the root of the solution. This will start the application in watch mode (automatic recompilation on changes) and open your browser on [http://localhost:8085](http://localhost:8085) which should display the index page.\r\n10. Go to [http://localhost:8085/books](http://localhost:8085/books) to see the generated view. All buttons should be working; you can add new entries, and remove or edit old ones.\r\n\r\n\r\n## Hello World\r\n\r\nIf you want to start from scratch with a minimal Saturn webserver:\r\n\r\n1. Create a new F# Project (for example with `dotnet new console -lang F#`)\r\n2. Add the `Saturn` NuGet Package\r\n\r\n```fsharp\r\nopen Saturn\r\nopen Giraffe\r\n\r\nlet app = application {\r\n    use_router (text \"Hello World from Saturn\")\r\n}\r\n\r\nrun app\r\n```\r\n\r\nIf you compile and run this application, it will unconditionally return the text regardless of the path.\r\n\r\nFrom here on out you can add [routers](../explanations/routing.html), [controllers](../explanations/controller.html) and [views](../explanations/view.html).\r\n\r\n## Deep Dive\r\n\r\nTo get a better understanding of Saturn and the whole SAFE Stack you can look at the [SAFE-Dojo](https://github.com/CompositionalIT/SAFE-Dojo).\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/controller.html","title":"Controllers","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Controller\r\n\r\nIn Saturn, a **controller** is a list of routes that is focused on a **model** (an object that contains your data). So if you have a user model, some common operations are to display the list of users, show details of a user, add a user, update or user, or remove a user. A controller is a great way to organize all of these actions.\r\n\r\nEach of the operations is a separate route and a controller is an easy way to group these routes together.\r\n\r\nA basic user controller is shown below:\r\n\r\n*)\r\nopen Saturn\r\n\r\nlet userController = controller {\r\n    index (fun ctx -> \"Index handler version 1\" |> Controller.text ctx) //View list of users\r\n    add (fun ctx -> \"Add handler version 1\" |> Controller.text ctx) //Add a user\r\n    create (fun ctx -> \"Create handler version 1\" |> Controller.text ctx) //Create a user\r\n    show (fun ctx id -> (sprintf \"Show handler version 1 - %i\" id) |> Controller.text ctx) //Show details of a user\r\n    edit (fun ctx id -> (sprintf \"Edit handler version 1 - %i\" id) |> Controller.text ctx)  //Edit a user\r\n    update (fun ctx id -> (sprintf \"Update handler version 1 - %i\" id) |> Controller.text ctx)  //Update a user\r\n}\r\n\r\n(**\r\nHere we can see the `index`, `add`, `create`, `show`, `edit`, and `update` operations but there are more operations that are not shown here like `patch` and `delete`. You can see all the operations int the [API Reference](../reference/Saturn/saturn-controller-controllerbuilder-10.html). You do not have to handle all of the operations.\r\n\r\nYou might be wondering what the difference is between `add` and `create` or `edit` and `update`. The `add` operation tells the application to return the form so that the user can enter the data for the user to be added. The `create` operation will commit the data to the database of the application. It is the same with `edit` for displaying the form and `update` for committing the change.\r\n\r\nTo add the controller for the routes, you can add it to the `defaultView` router like so:\r\n\r\n*)\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n    forward \"/users\" userController\r\n}\r\n\r\n(**\r\nThe route will now be:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            ├── \"/default.html\"     -redirect to yoursite.com/\r\n            └── \"/users\"\r\n                ├── index \"/\"           -yoursite.com/users/\r\n                ├── add \"/add\"          -yoursite.com/users/add\r\n                ├── create              -POST yoursite.com/users/add\r\n                ├── show \"/%i\"          -yoursite.com/users/%i\r\n                ├── edit \"/%i/edit\"     -yoursite.com/users/%i/edit\r\n                └── update \"\"           -POST yoursite.com/users/%i/edit\r\n```\r\n\r\nThe create and update operations make changes to the database so you have to make a POST request containing the information you want to save to the database.\r\n\r\n## Subcontroller\r\n\r\nNow that you know how to chain routers together to create routes, we can look at a common scenario for a website. A website usually has users and each user can create multiple comments.\r\n\r\n```bash\r\nyoursite.com\r\n└── \"/users\"\r\n    └── \"/%i\"           -yoursite.com/users/%i\r\n        └── \"/comments\" (commentController)\r\n            ├── index \"/\"           -yoursite.com/users/{userId}/comments/\r\n            └── show \"/%i\"          -yoursite.com/users/{userId}/comments/{commentId}\r\n```\r\n\r\nIn Saturn, you can make the comment controller a subcontroller of the user controller. It looks like the following code:\r\n\r\n*)\r\n\r\nlet commentController userId = controller {\r\n    index (fun ctx -> (sprintf \"Comment Index handler for user %i\" userId ) |> Controller.text ctx)\r\n    add (fun ctx -> (sprintf \"Comment Add handler for user %i\" userId ) |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show comment %s handler for user %i\" id userId ) |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit comment %s handler for user %i\" id userId )  |> Controller.text ctx)\r\n}\r\n\r\nlet userController = controller {\r\n    subController \"/comments\" commentController\r\n\r\n    plug [All] (setHttpHeader \"user-controller-common\" \"123\")\r\n    plug [Index; Show] (setHttpHeader \"user-controller-specialized\" \"123\")\r\n\r\n    index (fun ctx -> \"Index handler no version\" |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show handler no version - %i\" id) |> Controller.text ctx)\r\n    add (fun ctx -> \"Add handler no version\" |> Controller.text ctx)\r\n    create (fun ctx -> \"Create handler no version\" |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit handler no version - %i\" id) |> Controller.text ctx)\r\n    update (fun ctx id -> (sprintf \"Update handler no version - %i\" id) |> Controller.text ctx)\r\n    delete (fun ctx id -> failwith (sprintf \"Delete handler no version failed - %i\" id) |> Controller.text ctx)\r\n    error_handler (fun ctx ex -> sprintf \"Error handler no version - %s\" ex.Message |> Controller.text ctx)\r\n}\r\n\r\n(**\r\n\r\nTo create a subcontroller, start with creating a controller for your model. After that, define it as a subcontroller inside the main controller with the following code:\r\n\r\n```fsharp\r\n    subController \"/yourModel\" yourModelController\r\n```\r\n\r\n\r\n## API Reference\r\n\r\nFull API reference for `controller` CE can be found [here](../reference/Saturn/saturn-controller-controllerbuilder-10.html)\r\n\r\nFull API reference for `Controller` module containing useful helpers can be found [here](../reference/Saturn/saturn-controllerhelpers-controller.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/pipeline.html","title":"Pipeline","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Pipelines\r\n\r\nPipeline is a computation expression used to combine `HttpHandlers` in a declarative manner.\r\n\r\nThe result of the computation expression is a standard Giraffe `HttpHandler` which means that it's easily composable with other parts of the Giraffe ecosystem.\r\n\r\n**Example:**\r\n\r\n*)\r\n\r\nopen Saturn\r\n\r\nlet headerPipe = pipeline {\r\n    set_header \"myCustomHeader\" \"abcd\"\r\n    set_header \"myCustomHeader2\" \"zxcv\"\r\n}\r\n\r\nlet endpointPipe = pipeline {\r\n    plug fetchSession\r\n    plug head\r\n    plug requestId\r\n}\r\n\r\n\r\n(**\r\n## API Reference\r\n\r\nFull API reference for `pipeline` CE can be found [here](../reference/Saturn/saturn-pipeline-pipelinebuilder.html)\r\n\r\nFull API reference for `PipelineHelpers` module containing useful helpers can be found [here](../reference/Saturn/saturn-pipelinehelpers.html)\r\n\r\nYou can also use in pipelines (using `plug`) any `HttpHandler` defined in Giraffe - documentation can be found [here](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/routing.html","title":"Router","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\nmodule Index =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nmodule NotFound =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nlet someScopeOrController = Giraffe.ResponseWriters.text \"\"\r\n\r\n(**\r\n# Routing\r\n\r\nRoutes are how Saturn connects all the HTTP requests to the different actions. Think of a route as the URL of the application. The site is yoursite.com but you may have a route for your about page such as yoursite.com/about.\r\n\r\nIn Saturn, `Routers` contain all the routes of your application. A router is a list of routes. A website can have a router that handles the different routes to your page like so:\r\n\r\n```bash\r\nyoursite.com\r\n├── \"/\"             -yoursite.com/\r\n├── \"/about\"        -yoursite.com/about\r\n├── \"/contact\"      -yoursite.com/contact\r\n├── \"/news\"         -yoursite.com/news\r\n└── \"/investors\"    -yoursite.com/investors\r\n```\r\n\r\nSince this is at the root, this is your router at `\"\"` path. You can then add a router inside another router to have the following:\r\n\r\n```bash\r\nyoursite.com\r\n├── books           -yoursite.com/books\r\n|   ├── list        -yoursite.com/books/list\r\n|   ├── add         -yoursite.com/books/add\r\n|   ├── update      -yoursite.com/books/update\r\n|   └── delete      -yoursite.com/books/update\r\n├── about           -yoursite.com/about\r\n├── contact         -yoursite.com/contact\r\n├── news            -yoursite.com/news\r\n└── investors       -yoursite.com/investors\r\n```\r\n\r\nNow you have a router for the `\"/books\"` path inside another router for the `\"\"` path.\r\n\r\nNow to see it in code, create a Saturn project from the template and you will have a `Router.fs` file like this:\r\n\r\n*)\r\n\r\n\r\nopen Saturn\r\nopen Giraffe.Core\r\nopen Giraffe.ResponseWriters\r\n\r\n\r\nlet browser = pipeline {\r\n    plug acceptHtml\r\n    plug putSecureBrowserHeaders\r\n    plug fetchSession\r\n    set_header \"x-pipeline-type\" \"Browser\"\r\n}\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\nlet browserRouter = router {\r\n    not_found_handler (htmlView NotFound.layout) //Use the default 404 webpage\r\n    pipe_through browser //Use the default browser pipeline\r\n\r\n    forward \"\" defaultView //Use the default view\r\n}\r\n\r\n//Other scopes may use different pipelines and error handlers\r\n\r\n// let api = pipeline {\r\n//     plug acceptJson\r\n//     set_header \"x-pipeline-type\" \"Api\"\r\n// }\r\n\r\n// let apiRouter = router {\r\n//     not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n//     pipe_through api\r\n//\r\n//     forward \"/someApi\" someScopeOrController\r\n// }\r\n\r\nlet appRouter = router {\r\n    // forward \"/api\" apiRouter\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nFirst, take a look at the `router` function.\r\n\r\n*)\r\n\r\nlet appRouter' = router {\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nThe `appRouter` value is a `router`. Inside is the `forward \"\" browserRouter` line. The `forward` function needs a path and a router. In this case, the path is an empty string and the router is `browserRouter`. That means that the `browserRouter` router will handle the routes at the current location. Since `appRouter` is the first router called, the current location is the root of the application.\r\n\r\nNow let's look at `browserRouter`:\r\n\r\n*)\r\n\r\nlet browserRouter' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    forward \"\" defaultView\r\n}\r\n\r\n(**\r\n\r\nThere are three lines. The first line, `not_found_handler (htmlView NotFound.layout)` tells `browserRouter` to display a not found page if the user enters a route that the application does not handle. The second line tells the application to use the `browser` pipeline defined above. The pipeline is a list of settings on how the website will deliver the pages. Lastly, `forward \"\" defaultView` is like `forward \"\" browserRouter` from the `appRouter`. Again, `browserRouter` does not contain any routes but it tells the `defaultView` router to handle them. Finally, we get to the part where the application is told how to handle the routes. Inside `defaultView`, we created 3 routes:\r\n\r\n*)\r\n\r\nlet defaultView' = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nHere, we see that `get` is used to define the routes. There are 3 routes here but 2 of them redirect to the first route. To illustrate, the routes are:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            └── \"/default.html\"     -redirect to yoursite.com/\r\n```\r\n\r\nLooking at the first line inside `defaultView`, `get \"/\" (htmlView Index.layout)` tells the application to display `Index.layout` at the root of the application. The `get` corresponds to the HTTP verb GET so when you type in a link, the browser tries to GET the page. The first parameter of `get` is \"/\", so basically when getting the root, the `get` function will return something. The second parameter is `(htmlView Index.layout)` so the `get` function returns an HTML page specified by Index.layout. The second and third line have `(redirectTo false \"/\")`, telling the application to go to \"yoursite.com/\" when going to \"yoursite.com/index\" or \"yoursite.com/default\"\r\n\r\n## Best Practices\r\n\r\nYou can combine all 3 routers into one router like so:\r\n\r\n*)\r\n\r\n\r\nlet appRouter'' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nThe template splits them into 3 to encourage good practices. In the first router, you can see the commented out code `forward \"/api\" apiRouter`. This is a good suggestion in the template to have a separate router to handle your API routes. We set up how to deliever the webpage with `pipe_through browser` in `browserRouter`. The settings are important for a browser to know how to handle your routes but not for a different application to access your routes as an API.\r\n\r\nThe template provides an example of how to set up the API routes in the commented out code, which I copied below:\r\n\r\n*)\r\n\r\nlet api = pipeline {\r\n    plug acceptJson\r\n    set_header \"x-pipeline-type\" \"Api\"\r\n}\r\n\r\nlet apiRouter = router {\r\n    not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n    pipe_through api\r\n\r\n    forward \"/someApi\" someScopeOrController\r\n}\r\n\r\n(**\r\n\r\nHere we have the `apiRouter` router which does not return a 404 page but a 404 text instead which is appropriate for an API. The router also uses a pipeline that is more appropriate for an API such as accepting JSON inputs instead of HTML as in the `browser` pipeline.\r\n\r\n## Format Strings\r\n\r\nYou might be wondering how to make routes that accept a numerical ID. You can make multiple routes for each ID like so\r\n\r\n```fsharp\r\nget \"/1\" (getApplication 1)\r\nget \"/2\" (getApplication 2)\r\nget \"/3\" (getApplication 3)\r\n...\r\n```\r\n\r\nBut this is impracticle because there can be a large number of items or new items are constantly being created with new IDs. Instead the solution is to use format strings. Remember that in the [Adding Pages Guide](../tutorials/adding-pages.html), we used `getf \"/%s\" index2Action` to pass a string to page.\r\n\r\n| Format Char | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nFor a numerical ID, we want to pass an int which is `%i` in the list above, so you can replace the lines above with\r\n\r\n```fsharp\r\ngetf \"/%i\" getApplication\r\n```\r\n\r\nNotice that `getf` is used instead of get. This is a separate version of get that handles `f`ormat characters.\r\n\r\n    You can use format strings with \"forward\" too by using \"forwardf\"\r\n\r\n## API Reference\r\n\r\nFull API reference for `router` CE can be found [here](../reference/Saturn/saturn-router-routerbuilder.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/reference/Saturn.Extensions.gRPC/index.html","title":"Saturn.Extensions.gRPC - API Reference","content":"Saturn.Extensions.gRPC \n global"},{"uri":"https://saturnframework.org/reference/Saturn.Extensions.gRPC/global-saturn.html","title":"Saturn","content":"Saturn \n  \n  \n  \n  \n UseGrpc <p>Adds gRPC Code First endpoint. Passed parameter should be any constructor of the gRPC service implementation.</p>\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/directory-structure.html","title":"Directory Structure","content":"\r\n# Directory Structure\r\n\r\nAfter creating a new Saturn project, let's take a deeper look into what files are created.\r\n\r\n```bash\r\n├── .fake\r\n├── .paket\r\n├── .vs\r\n├── .packages\r\n├── paket-files\r\n├── src\r\n|   ├── Migrations\r\n|   └── SaturnSample\r\n├── .gitignore\r\n├── build.fsx\r\n├── global.json\r\n├── paket.dependencies\r\n├── paket.lock\r\n└── SaturnSample.sln\r\n```\r\n\r\nAt this level most of it is basic configuration files to help with running Saturn. From looking at the `.paket`, `paket-files`, `paket.dependencies`, `paket.lock` folders and files, you can see that by default Saturn uses [paket](https://fsprojects.github.io/Paket/) to handle package management. You won't be working with these files directly but rather through the command line tools instead.\r\n\r\nSaturn also uses [FAKE](https://fake.build/) to build the project. You can see how it is set up by looking at the `.fake` folder and `build.fsx` file.\r\n\r\nSaturn also provides a `.gitignore` file that prevents some folders from being tracked by git when they don't need to.\r\n\r\nLastly, there is the `SaturnSample.sln` solution file so you can open the project in an IDE like Visual Sudio and a `global.json` file to configure the solution file.\r\n\r\n### Project structure\r\n\r\nMost of the work you will do in this project however, will be in `src/SaturnSample`, which looks like the following when expanded:\r\n\r\n```bash\r\n  ├── bin\r\n  ├── Books\r\n  |   ├── BooksController.fs\r\n  |   ├── BooksModel.fs\r\n  |   ├── BooksRepository.fs\r\n  |   └── BooksView.fs\r\n  ├── obj\r\n  ├── static\r\n  |   ├── app.css\r\n  |   └── app.js\r\n  ├── Templates\r\n  |   ├── App.fs\r\n  |   ├── Index.fs\r\n  |   ├── InternalError.fs\r\n  |   └── NotFound.fs\r\n  ├── Config.fs\r\n  ├── Database.fs\r\n  ├── database.sqlite\r\n  ├── paket.references\r\n  ├── Program.fs\r\n  ├── Router.fs\r\n  └── SaturnSample.fsproj\r\n```\r\n\r\n`bin` and `obj` folders store the compiled version of the program after you build the project.\r\n\r\nThe convention for Saturn is that the model and everything associated with it are inside one folder. Everything is also named with the plural form of the model so \"Books\" instead of \"Book\".\r\n\r\nYour static files like css, js, and images should be inside the `static` folder.\r\n\r\n`Config.fs` contains a `Config` record that stores settings that you can use inside your application. By default, the record only contains the `connectionString` field.\r\n\r\n`Database.fs` contains functions to execute SQL queries within the program through [Dapper](https://stackexchange.github.io/Dapper/).\r\n\r\nIf you did not run `dotnet saturn migration` as in the [how to start guide](../tutorials/how-to-start.html), you might not see `database.sqlite`, but that is the database file that your Saturn project is using to store data.\r\n\r\n`paket.references` shows the packages that your project is using.\r\n\r\n`Program.fs` handles intializing the program and loading up various settings.\r\n\r\n`Router.fs` is where you will set the route of the site and what page to load.\r\n\r\nLastly, `SaturnSample.fsproj` is the project file itself."},{"uri":"https://saturnframework.org/explanations/endpoint-routing.html","title":"Endpoint Routing","content":"\r\n# Endpoint Routing\r\n\r\nSaturn from version `0.15` supports [ASP.NET Endpoint Routing](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1) additionally to custom routing implementation provided by Giraffe. The main difference between old routing and new one is that Endpoint Routing assumes total separation of routing from behavior - it works by statically defining list of all possible routes on startup of application. This impacts design of some of our Saturn abstractions, and means new routing is not 100% compatible with old one. On the bright side, theoretically, Endpoint Routing should provide noticeable performance boost, and in the future it will allow for better ecosystem integration.\r\n\r\n> Currently endpoint routing API is treated as an experimental API - it's subject to changes.\r\n\r\nTo use Endpoint Routing you need to open `Saturn.Endpoint` namespace - this will override known `router` and `controller` Computation Expressions with their Endpoint Routing versions. In `application` CE instead of using `use_router` operation you should use `use_endpoint_router` operation. For many simple applications this may be enough to get things working - we've been trying to keep API as compatible as possible.\r\n\r\nHowever there are differences:\r\n\r\n* With Endpoint Routing `router` and `controller` computation expressions are not transformed to `HttpHandler` but rather to `Endpoint list`. This has a huge impact on composability of those abstractions - you can't do things like `myHttpHandler >=> router { ... }` any more. Such code should be replaced with `plug/pipe_through` functionality in both `router` and `controller`. `Endpoint list` can basically be used in 2 places - in `forward` operation in `router` and `use_endpoint_router` in `application`.\r\n* Lack of `subroutef` in Giraffe-EndpointRouting - beacuse EndpointRouting needs to have all possible route templates at the application startup it's really hard to emulate some of previous Giraffe's routing composibility capabilities. From Saturn point of view this created 2 major changes:\r\n  - there's no `forwardf` in `router` CE anymore - it should be replaced with set of `getf/postf/putf ... ` operations in child router.\r\n  - `subController` in `controller` CE doesn't work well in Endpoint Routing - you can use as subcontrollers only old, HttpHandler based controllers (even if you parent controller is Endpoint Routing controller). In `Saturn.Endpoint` we provide additonal `subcontroller` CE - it's an alias to old `controller` CE\r\n* Lack of `case_insensitive` in `router` and `controller` - with Endpoint Routing all routes are case insensitive by default and there's no easy way to change it\r\n* Lack of `not_found_handler` in `router` and `controller` - as Endpoint Routing creates global table of routing having scoped not-found handlers is really tricky. Use built-in ways of handle 404 in ASP.NET (such as `UseDeveloperExceptionPage`)\r\n* Unlike Giraffe routing, Endpoint Routing doesn't ensure order of routing checks - this shouldn't be a problem in most cases, but I can imagine some edge cases in which this would matter.\r\n\r\nIn general, to reiterate - Endpoint Routing API in Giraffe/Saturn is still experimental. However, it probably is a future of Giraffe/Saturn so if possible please check if your applications can move to the Endpoint Routing API, and try it out. It's important for everyone involved to get feedback on this new routing engine."},{"uri":"https://saturnframework.org/explanations/overview.html","title":"Saturn Overview","content":"\r\n# Saturn Overview\r\n\r\nSaturn is a web development framework written in F# which implements the server-side MVC pattern. Many of its components and concepts will seem familiar to those of us with experience in other web frameworks like Ruby on Rails or Python’s Django. It's heavily inspired by Elixir's [Phoenix](http://phoenixframework.org/).\r\n\r\nBuilt on top of the battle-tested ASP.NET Core foundation and the highly flexible, extendable model of Giraffe, Saturn provides high level abstractions, helpers and tools to enable high developer productivity, at the same time keeping high application performance provided by Kestrel and Giraffe.\r\n\r\nSaturn is made up of a number of distinct parts, each with its own purpose and role to play in building a web application.\r\n\r\n - Application\r\n    - the start and end of the request life cycle\r\n    - handles all aspects of requests up until the point where the router takes over\r\n    - provides a core set of plugs to apply to all requests\r\n    - dispatches requests into a router\r\n    - enables application and hosting configuration\r\n - [Router](routing.html)\r\n    - parses incoming requests and dispatches them to the correct controller/action, passing parameters as needed\r\n    - provides helpers to generate route paths or urls to resources\r\n    - defines named pipelines through which we may pass our requests\r\n    - allows easy application of groups of plugs to a set of routes\r\n - [Controllers](controller.html)\r\n    - provide functions, called *actions*, to handle requests\r\n    - actions:\r\n        - prepare data and pass it into views\r\n        - invoke rendering via views\r\n        - perform redirects\r\n        - return data as JSON or XML\r\n        - and much more\r\n - [Views](view.html)\r\n    - render templates\r\n    - act as a presentation layer\r\n    - define helper functions, available in templates, to decorate data for presentation\r\n - Channels\r\n    - manage sockets for easy realtime communication\r\n    - are analogous to controllers except that they allow bi-directional communication with persistent connections\r\n - [Scaffolding scripts](scaffolding.html)\r\n    - `dotnet new` template providing good starting point for new applications - [https://github.com/SaturnFramework/Saturn.Template](https://github.com/SaturnFramework/Saturn.Template)\r\n    - `dotnet saturn` CLI tool that controls migrations and let you easily scaffold new parts of application - [https://github.com/SaturnFramework/Saturn.Dotnet](https://github.com/SaturnFramework/Saturn.Dotnet)\r\n\r\n\r\n### Saturn rings\r\n\r\nSaturn itself is the top layer of a multi-layer system designed to create a flexible, productive environment for creating web applications.\r\n\r\n#### Kestrel and ASP.NET Core\r\n\r\nASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-based, Internet-connected applications. Kestrel is a cross-platform web server for ASP.NET Core based on `libuv`, a cross-platform asynchronous I/O library. ASP.NET Core documentation can be found [here](https://docs.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-3.1)\r\n\r\n#### [Giraffe](https://github.com/giraffe-fsharp/Giraffe)\r\n\r\nGiraffe is an F# micro web framework for building rich web applications. It has been heavily inspired and is similar to [Suave](https://suave.io), but has been specifically designed with ASP.NET Core in mind and can be plugged into the ASP.NET Core pipeline via middleware. Giraffe applications are composed of so-called HttpHandler functions which can be thought of as a mixture of Suave's WebParts and ASP.NET Core's middleware. As Saturn shares many basic helper functions with Giraffe it's highly recommended to also check out [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n\r\n### Saturn moons\r\n\r\nSaturn is not only a library building on top of Giraffe, but also a set of opinionated tooling for scaffolding a whole project and then generating some boilerplate code. At the moment our template is using (by default):\r\n\r\n#### [Dapper](https://github.com/StackExchange/Dapper)\r\n\r\nA simple, focused on performance object mapper for .Net that you can add in to your project and will extend your `IDbConnection` interface.\r\n\r\n#### [Simple.Migrations](https://github.com/canton7/Simple.Migrations)\r\n\r\nSimple.Migrations is a simple bare-bones migration framework for .NET Core (.NET Standard 1.2 and .NET 4.5). It doesn't provide SQL generation, nor an out-of-the-box command-line tool, nor any other fancy feature. It does however provide a set of simple, extendable, and composable tools for integrating migrations into your application.\r\n\r\n\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/scaffolding.html","title":"Scaffolding","content":"\r\n# Scaffolding\r\n\r\nSaturn provides a command line scaffolding tool to generate a model, database migration, controller, and associated views.\r\n\r\nTo use the generator, run the `dotnet saturn` command from the root of your application application.  If you have used the template to generate your project, this is the directory with `build.fsx` or `paket.dependencies` file.\r\n\r\nThere are three flavors of generators that provide flexibility about what types of code is generated to support your model.\r\n\r\n| Command      |  Generates                                                                     |\r\n|--------------|--------------------------------------------------------------------------------|\r\n| gen          | Creates a model, database layer, HTML views, and a controller.                 |\r\n| gen.json     | Creates a model, database layer, and an API controller to access the model.    |\r\n| gen.model    | Creates only the model and database layer (no controller or views)             |\r\n\r\nEach of these commands will generate a migration for your model as well as a folder containing generated files.\r\n\r\nFor example:\r\n\r\n`dotnet saturn gen Book Books id:string title:string`\r\n\r\nGenerates the following structure:\r\n\r\n```bash\r\nsrc\r\n├── Migrations\r\n│   └── 201903192143.Book.fs\r\n│\r\n└── SaturnSample\r\n    └── Books\r\n        ├── BooksController.fs\r\n        ├── BooksModel.fs\r\n        ├── BooksRepository.fs\r\n        └── BooksViews.fs\r\n```\r\n\r\nEach of the generators takes arguments in the same format:\r\n\r\n`dotnet saturn gen <SingularModelName> <PluralModelName> <List of model fields with types>`\r\n\r\nThe list of model fields are names and types separated by a colon.\r\n\r\n`<fieldname>:<type>`\r\n\r\nCurrently supported types are:\r\n\r\n* string\r\n* int\r\n* float\r\n* double\r\n* decimal\r\n* guid\r\n* datetime\r\n* bool\r\n\r\n## Migrations\r\n\r\nUsing the generator to create a model will also create a migration file that will create a supporting table in the database. Execute the migration script using:\r\n\r\n`dotnet saturn migration`"},{"uri":"https://saturnframework.org/explanations/view.html","title":"View Engine","content":"\r\n# View Engine\r\n\r\n> This post has been originally part of the [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine)\r\n\r\nSaturn is built on top of Giraffe and can use any helpers it provides. This is a case for suggested view engine that you can use in Saturn - Giraffe has its own functional view engine which can be used to build rich UIs for web applications. The single biggest and best contrast to other view engines (e.g. Razor, Liquid, etc.) is that the Giraffe View Engine is entirely functional written in normal (and compiled) F# code.\r\n\r\nThis means that the Giraffe View Engine is by definition one of the most feature rich view engines available, requires no disk IO to load a view and views are automatically compiled at build time.\r\n\r\nThe Giraffe View Engine uses traditional functions and F# record types to generate rich HTML/XML views.\r\n\r\n### HTML Elements and Attributes\r\n\r\nHTML elements and attributes are defined as F# objects:\r\n\r\n```fsharp\r\nlet indexView =\r\n    html [] [\r\n        head [] [\r\n            title [] [ str \"Giraffe Sample\" ]\r\n        ]\r\n        body [] [\r\n            h1 [] [ str \"I |> F#\" ]\r\n            p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                str \"Hello World\"\r\n            ]\r\n        ]\r\n    ]\r\n```\r\n\r\nA HTML element can either be a `ParentNode`, a `VoidElement` or a `Text` element.\r\n\r\nFor example the `<html>` or `<div>` tags are typical `ParentNode` elements. They can hold an `XmlAttribute list` and a second `XmlElement list` for their child elements:\r\n\r\n```fsharp\r\nlet someHtml = div [] []\r\n```\r\n\r\nAll `ParentNode` elements accept these two parameters:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [ _id \"someId\"; _class \"css-class\" ] [\r\n        a [ _href \"https://example.org\" ] [ str \"Some text...\" ]\r\n    ]\r\n```\r\n\r\nMost HTML tags are `ParentNode` elements, however there is a few HTML tags which cannot hold any child elements, such as `<br>`, `<hr>` or `<meta>` tags. These are represented as `VoidElement` objects and only accept the `XmlAttribute list` as single parameter:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        br []\r\n        hr [ _class \"css-class-for-hr\" ]\r\n        p [] [ str \"bla blah\" ]\r\n    ]\r\n```\r\n\r\nAttributes are further classified into two different cases. First and most commonly there are `KeyValue` attributes:\r\n\r\n```fsharp\r\na [\r\n    _href \"http://url.com\"\r\n    _target \"_blank\"\r\n    _class \"class1\" ] [ str \"Click here\" ]\r\n```\r\n\r\nAs the name suggests, they have a key, such as `class` and a value such as the name of a CSS class.\r\n\r\nThe second category of attributes are `Boolean` flags. There are not many but some HTML attributes which do not require any value (e.g. `async` or `defer` in script tags). The presence of such an attribute means that the feature is turned on, otherwise it is turned off:\r\n\r\n```fsharp\r\nscript [ _src \"some.js\"; _async ] []\r\n```\r\n\r\nThere's also a wealth of [accessibility attributes](https://www.w3.org/TR/html-aria/) available under the `Giraffe.GiraffeViewEngine.Accessibility` module (needs to be explicitly opened).\r\n\r\n### Text Content\r\n\r\nNaturally the most frequent content in any HTML document is pure text:\r\n\r\n```html\r\n<div>\r\n    <h1>This is text content</h1>\r\n    <p>This is even more text content!</p>\r\n</div>\r\n```\r\n\r\nThe Giraffe View Engine lets one create pure text content as a `Text` element. A `Text` element can either be generated via the `rawText` or `encodedText` (or the short alias `str`) functions:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        p [] [ rawText \"<div>Hello World</div>\" ]\r\n        p [] [ encodedText \"<div>Hello World</div>\" ]\r\n    ]\r\n```\r\n\r\nThe `rawText` function will create an object of type `XmlNode` where the content will be rendered in its original form and the `encodedText`/`str` function will output a string where the content has been HTML encoded.\r\n\r\nIn this example the first `p` element will literally output the string as it is (`<div>Hello World</div>`) while the second `p` element will output the value as HTML encoded string `&lt;div&gt;Hello World&lt;/div&gt;`.\r\n\r\nPlease be aware that the the usage of `rawText` is mainly designed for edge cases where someone would purposefully want to inject HTML (or JavaScript) code into a rendered view. If not used carefully this could potentially lead to serious security vulnerabilities and therefore should be used only when explicitly required.\r\n\r\nMost cases and particularly any user provided content should always be output via the `encodedText`/`str` function.\r\n\r\n### Javascript event handlers\r\n\r\nIt is possible to add JavaScript event handlers to HTML elements using the Giraffe View Engine.  These event handlers (all prefixed with names starting with `_on`, for example `_onclick`, `_onmouseover`) can either execute inline JavaScript code or can invoke functions that are part of the `window` scope.\r\n\r\nThis example illustrates how inline JavaScript could be used to log to the console when a button is clicked:\r\n\r\n```fsharp\r\nlet inlineJSButton =\r\n    button [_id \"inline-js\"\r\n            _onclick \"console.log(\\\"Hello from the 'inline-js' button!\\\");\"] [str \"Say Hello\" ]\r\n```\r\n\r\nThere are some caveats with this approach, namely that\r\n* it is not very scalable to write JavaScript inline in this manner, and more pressing\r\n* the Giraffe View Engine HTML-encodes the text provided to the `_onX` attributes.\r\n\r\nTo get around this, you can write dedicated scripts in your HTML and reference the functions from your event handlers:\r\n\r\n```fsharp\r\nlet page =\r\n    div [] [\r\n        script [_type \"application/javascript\"] [\r\n            rawText \"\"\"\r\n            window.greet = function () {\r\n                console.log(\"ping from the greet method\");\r\n            }\r\n            \"\"\"\r\n        ]\r\n        button [_id \"script-tag-js\"\r\n                _onclick \"greet();\"] [str \"Say Hello\"]\r\n    ]\r\n```\r\n\r\nHere it's important to note that we've included the text of our script using the `rawText` tag.  This ensures that our text is not encoded by Giraffe so that it remains as we have written it.\r\n\r\nHowever, writing large quantities of JavaScript in this manner can be difficult, because you don't have access to the large ecosystem of javascript editor tooling.  In this case you should write your functions in another script and use a `script` tag element to reference your script, then add the desired function to your HTML element's event handler.\r\n\r\nSay you had a JavaScript file named `greet.js` and had configured Giraffe to serve that script from the WebRoot. Let us also say that the content of that script was:\r\n\r\n```javascript\r\nfunction greet() {\r\n    console.log(\"Hello from the greet function of greet.js!\");\r\n}\r\n```\r\n\r\nThen, you could reference that javascript via a script element, and use `greet` in your event handler like so:\r\n\r\n```fsharp\r\nlet page =\r\n    html [] [\r\n        head [] [\r\n            script [_type \"application/javascript\"\r\n                    _src \"/greet.js\"] [] // include our `greet.js` function dynamically\r\n        ]\r\n        body [] [\r\n            button [_id \"greet-btn\"\r\n                    _onclick \"greet()\"] [] // use the `greet()` function from `greet.js` to say hello\r\n        ]\r\n    ]\r\n```\r\n\r\nIn this way, you can write `greet.js` with all of your expected tooling, and still hook up the event handlers all in one place in Giraffe.\r\n\r\n### Naming Convention\r\n\r\nThe Giraffe View Engine has a naming convention which lets you easily determine the correct function name without having to know anything about the view engine's implementation.\r\n\r\nAll HTML tags are defined as `XmlNode` elements under the exact same name as they are named in HTML. For example the `<html>` tag would be `html [] []`, an `<a>` tag would be `a [] []` and a `<span>` or `<canvas>` would be the `span [] []` or `canvas [] []` function.\r\n\r\nHTML attributes follow the same naming convention except that attributes have an underscore prepended. For example the `class` attribute would be `_class` and the `src` attribute would be `_src` in Giraffe.\r\n\r\nThe underscore does not only help to distinguish an attribute from an element, but also avoid a naming conflict between tags and attributes of the same name (e.g. `<form>` vs. `<input form=\"form1\">`).\r\n\r\nIf a HTML attribute has a hyphen in the name (e.g. `accept-charset`) then the equivalent Giraffe attribute would be written in camel case notion (e.g. `acceptCharset`).\r\n\r\n*Should you find a HTML tag or attribute missing in the Giraffe View Engine then you can either [create it yourself](#custom-elements-and-attributes) or send a [pull request on GitHub](https://github.com/giraffe-fsharp/Giraffe/pulls).*\r\n\r\n### View Engine Best Practices\r\n\r\nDue to the huge amount of available HTML tags and their fairly generic (and short) names (e.g. `<form>`, `<option>`, `<select>`, etc.) there is a significant danger of accidentally overriding a function of the same name in an application's codebase. For that reason the Giraffe View Engine becomes only available after opening the `GiraffeViewEngine` module.\r\n\r\nAs a measure of good practice it is recommended to create all views in a separate module:\r\n\r\n```fsharp\r\nmodule MyWebApplication\r\n\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let index =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str \"Giraffe Sample\" ]\r\n            ]\r\n            body [] [\r\n                h1 [] [ str \"I |> F#\" ]\r\n                p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                    str \"Hello World\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let other = //...\r\n```\r\n\r\nThis ensures that the opening of the `GiraffeViewEngine` is only contained in a small context of an application's codebase and therefore less of a threat to accidental overrides. In the above example views can always be accessed through the `Views` sub module (e.g. `Views.index`).\r\n\r\n### Custom Elements and Attributes\r\n\r\nAdding new elements or attributes is normally as simple as a single line of code:\r\n\r\n```fsharp\r\nopen Giraffe.GiraffeViewEngine\r\n\r\n// If there was a new <foo></foo> HTML element:\r\nlet foo = tag \"foo\"\r\n\r\n// If <foo> is an element which cannot hold any content then create it as voidTag:\r\nlet foo = voidTag \"foo\"\r\n\r\n// If <foo> has a new attribute called bar then create a new bar attribute:\r\nlet _bar = attr \"bar\"\r\n\r\n// if the bar attribute is a boolean flag:\r\nlet _bar = flag \"bar\"\r\n```\r\n\r\nAlternatively you can also create new elements and attributes from inside another element:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n```\r\n\r\n### Rendering Views\r\n\r\nRendering views in Giraffe is done through one of the following functions:\r\n\r\n- `renderHtmlDocument`\r\n- `renderHtmlNodes`\r\n- `renderHtmlNode`\r\n- `renderXmlNodes`\r\n- `renderXmlNode`\r\n\r\nThe Giraffe View Engine cannot only be used to render HTML views, but also for any other XML based content such as `<svg>` images or other arbitrary XML based data.\r\n\r\nThe `renderHtmlDocument` function takes a single `XmlNode` as input parameter and renders a HTML page with a `DOCTYPE` declaration. This function should be used for rendering a complete HTML document. The `WriteHtmlViewAsync` extension method and the `htmlView` http handler both use the `renderHtmlDocument` function under the covers.\r\n\r\nThe `renderHtmlNodes` function takes an `XmlNode list` as input parameter and will output a single HTML string containing all the rendered HTML code. The `renderHtmlNode` function renders a single `XmlNode` element into a valid HTML string. Both, the `renderHtmlNodes` and `renderHtmlNode` function are useful for use cases where a HTML snippet needs to be created without a `DOCTYPE` declaration (e.g. templated emails, etc.).\r\n\r\nThe `renderXmlNodes` and `renderXmlNode` function are identical to `renderHtmlNodes` and `renderHtmlNode`, except that they will render void elements differently:\r\n\r\n```fsharp\r\nlet someTag = voidTag \"foo\"\r\nlet someContent = someTag []\r\n\r\n// Void tag will be rendered to valid HTML: <foo>\r\nlet output1 = renderHtmlNode someContent\r\n\r\n// Void tag will be rendered to valid XML: <foo />\r\nlet output2 = renderXmlNode someContent\r\n```\r\n\r\nAll `GiraffeViewEngine` http handlers are using a thread static `StringBuilderPool` to avoid the creation of large `StringBuilder` objects for each render call and dynamically grow/shrink that pool based on the application's needs. However if the application is running into any memory issues then this performance feature can be disabled by setting `StringBuilderPool.IsEnabled <- false`.\r\n\r\nAdditionally with Giraffe 3.0.0 or higher there is a new module called `ViewBuilder` under the `Giraffe.GiraffeViewEngine` namespace. This module exposes additional view rendering functions which compile a view into a `StringBuilder` object instead of returning a single `string`:\r\n\r\n- `ViewBuilder.buildHtmlDocument`\r\n- `ViewBuilder.buildHtmlNodes`\r\n- `ViewBuilder.buildHtmlNode`\r\n- `ViewBuilder.buildXmlNodes`\r\n- `ViewBuilder.buildXmlNode`\r\n\r\nThe `ViewBuilder.build[...]` functions can be useful if there is additional string processing required before/after composing a view by the `GiraffeViewEngine` (e.g. embedding HTML snippets in an email template, etc.). These functions also serve as the lower level building blocks of the equivalent `render[...]` functions.\r\n\r\nExample usage:\r\n\r\n```fsharp\r\nopen System.Text\r\nopen Giraffe.GiraffeViewEngine\r\n\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n\r\nlet sb = new StringBuilder()\r\n\r\n// Perform actions on the `sb` object...\r\nsb.AppendLine \"This is a HTML snippet inside a markdown string:\"\r\n  .AppendLine \"\"\r\n  .AppendLine \"```html\" |> ignore\r\n\r\nlet sb' = ViewBuilder.buildHtmlNode sb someHtml\r\n\r\n// Perform more actions on the `sb` object...\r\nsb'.AppendLine \"```\" |> ignore\r\n\r\nlet markdownOutput = sb'.ToString()\r\n```\r\n\r\n### Common View Engine Features\r\n\r\nThe Giraffe View Engine doesn't have any specially built functions for commonly known features such as master pages or partial views, mainly because the nature of the view engine itself doesn't require it in most cases.\r\n\r\n#### Master Pages\r\n\r\nCreating a master page is a simple matter of piping two functions together:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n... or even have multiple nested master pages:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master1 (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let master2 (content: XmlNode list) =\r\n        [\r\n            main [] content\r\n            footer [] [\r\n                p [] [\r\n                    str \"Copyright ...\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master2 |> master1 pageTitle\r\n```\r\n\r\n#### Partial Views\r\n\r\nA partial view is nothing more than one function or object being called from within another function:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n#### Working with Models\r\n\r\nA view which accepts a model is basically a function with an additional parameter:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index (model : IndexViewModel) =\r\n        [\r\n            h1 [] [ str model.PageTitle ]\r\n            p [] [ str model.WelcomeText ]\r\n        ] |> master model.PageTitle\r\n```\r\n\r\n#### If Statements, Loops, etc.\r\n\r\nThings like if statements, loops and other normal F# language constructs work just as expected:\r\n\r\n```fsharp\r\nlet partial (books : Book list) =\r\n    ul [] [\r\n        yield!\r\n            books\r\n            |> List.map (fun b -> li [] [ str book.Title ])\r\n    ]\r\n```\r\n\r\nOverall the Giraffe View Engine is extremely flexible and feature rich by nature based on the fact that it is generated via normal compiled F# code."},{"uri":"https://saturnframework.org/tutorials/adding-pages.html","title":"Adding Pages","content":"\r\n# Adding Pages\r\n\r\nThis guide uses the same project from the [how to start guide](how-to-start.html). Let's add two pages to it - one hello page and a page that can get your name from the URL.\r\n\r\n## Creating the View\r\n\r\nTo begin, create a `Hello` folder inside the `src/SaturnSample` folder.\r\n\r\nInside the folder, create a new file called \"HelloViews.fs\". This file will contain the functions to create the page.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Giraffe.GiraffeViewEngine\r\nopen Saturn\r\n\r\nmodule Views =\r\n  let index =\r\n    div [] [\r\n        h2 [] [rawText \"Hello from Saturn!\"]\r\n    ]\r\n```\r\n\r\nOne of the dependencies required is [Giraffe View Engine](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine). This will allow your project to define HTML within your function. The `index` function will result in the following HTML code:\r\n\r\n```html\r\n<div>\r\n    <h2>Hello from Saturn!</h2>\r\n</div>\r\n```\r\n\r\n## Creating the Controller\r\n\r\nCreate a `HelloController.fs` file inside the `Hello` folder.\r\n\r\nThe `index` function tells us what the HTML will be but we still need to tell Saturn to return it as an HTML page. We also need to tell Saturn where the page is.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Saturn\r\nopen Giraffe.ResponseWriters\r\n\r\nmodule Controller =\r\n    let indexAction =\r\n        htmlView (Views.index)\r\n\r\n    let helloView = router {\r\n        get \"/\" indexAction\r\n    }\r\n```\r\n\r\nThe `indexAction` tells Saturn to create an HTML page using the `index` function inside \"HelloViews.fs\"\r\n\r\n`helloView` lets Saturn know that the page is located at the root.\r\n\r\n## Adding the 2 new files to the project\r\n\r\nFor the project to see the new files, modify SaturnSample.fsproj as below:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <Compile Include=\"Database.fs\" />\r\n    <Compile Include=\"Config.fs\" />\r\n\r\n    <Compile Include=\"Hello\\HelloViews.fs\" />\r\n    <Compile Include=\"Hello\\HelloController.fs\" />\r\n    ...\r\n```\r\n\r\n## Adding it to Router.fs\r\n\r\n\r\nAfter setting up the route, you need to update the project with the new route.\r\n\r\nIn \"Router.fs\", add the following to the inside of the `browserRouter` function:\r\n\r\n\r\n```fsharp\r\nforward \"/hello\" Hello.Controller.helloView\r\n```\r\n\r\nThis means that when we navigate to [http://localhost:8085/hello](http://localhost:8085/hello), the `helloView` function will determine what page to load there. Looking inside the `helloView` function, we said that `indexAction` is called at the root. In conclusion, the page will be located at [http://localhost:8085/hello/](http://localhost:8085/hello/). (Note the \"/\" at the end)\r\n\r\nNow run the program and go to [http://localhost:8085/hello/](http://localhost:8085/hello/) and you will see a page saying \"Hello from Saturn!\"\r\n\r\n## Sending a parameter to your page\r\n\r\nWhat if you want the page to display your name?\r\n\r\nOne way to retrieve your name is to get it from the route. So when you go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) with {yourname} being your actual name, it will grab your name which can then be used to display on the page.\r\n\r\nTo begin, add a new view in your `HelloViews.fs`:\r\n\r\n```fsharp\r\n  let index2 (name : string) =\r\n    div [] [\r\n        h2 [] [rawText (\"Hello \" + name + \"!\")]\r\n    ]\r\n```\r\n\r\nThis function requires passing in the name to be displayed. The name will be retrieved from the route.\r\n\r\nAdd the following to the `HelloController.fs` file below the `helloView` handler:\r\n\r\n```fsharp\r\nlet index2Action name=\r\n    htmlView (Hello.Views.index2 name)\r\n```\r\n\r\nNow to set up the route. Add the following to the `HelloView` handler:\r\n\r\n```fsharp\r\ngetf \"/%s\" index2Action\r\n```\r\n\r\n\"%s\" is a format string. This lets Saturn know to save whatever you type in that spot. Since we want to save a name, we want to save it as a string so we use `%s`.\r\n\r\nThere are other format strings for different types:\r\n\r\n| Format String | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nNow run the program and go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) and replace `{yourname}` with your name to see a page that will greet you.\r\n"},{"uri":"https://saturnframework.org/tutorials/adding-saturn-to-an-existing-giraffe-app.html","title":"Adding Saturn to an existing Giraffe application","content":"\r\n# Adding Saturn to an existing Giraffe application\r\n\r\nThe previous chapter showed how to get started with a new application.\r\n\r\nIf you already have a working Giraffe webserver, you can gradually opt-in to Saturn.\r\n\r\nFor example, if your existing app looks like this:\r\n\r\n```fsharp\r\n\r\ntype Customer = {\r\n    Name : string\r\n    Address : string\r\n}\r\n\r\nlet customers =\r\n    choose [\r\n      GET >=> (json { Name = \"Mr. Smith\"; Address = \"Santa Monika\"})\r\n      PUT >=> (bindJson<Customer> (fun customer -> printfn \"Adding customer %A\" customer; setStatusCode 200))\r\n    ]\r\n\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"               >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n    ]\r\n```\r\n\r\nand you need to add \"vendor\" functionality, you could implement it as a Saturn ``router`` while keeping everything else intact:\r\n\r\n\r\n```fsharp\r\n// the new Saturn router\r\nlet vendors = router {\r\n    getf \"/%i\" (fun vendorId -> (json (readVendorFromDb vendorId)))\r\n    post \"/\" (bindJson<Vendor> (fun customer -> addVendor vendor; setStatusCode 200))\r\n}\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"                >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n        // plug the new Saturn router into the Giraffe app\r\n        route \"/api/vendors\"     >=> vendors\r\n    ]\r\n```\r\n\r\n## Embedding Giraffe Handlers into Saturn\r\n\r\nOf course the other way around also works.\r\n\r\nFor example, [Elmish.Bridge](https://github.com/Nhowka/Elmish.Bridge) does not provide a specialized implementation for Saturn. And it doesn't need to, because we can just use the Giraffe implementation!\r\n\r\n```fsharp\r\n\r\nopen Elmish\r\nopen Elmish.Bridge\r\n\r\nlet elmishBridgeHandler : HttpHandler =\r\n  Bridge.mkServer Shared.endpoint init update\r\n  |> Bridge.run Giraffe.server\r\n\r\n// our existing Saturn router\r\nlet router = router {\r\n\r\n    // ...\r\n\r\n    forward \"\" elmishBridgeHandler\r\n}\r\n```\r\n"},{"uri":"https://saturnframework.org/tutorials/how-to-start.html","title":"Getting started","content":"\r\n# How to start in 60 seconds\r\n\r\nRequirements:\r\n\r\n* `dotnet` SDK 3.1 [https://dotnet.microsoft.com/download/dotnet-core/3.1](https://dotnet.microsoft.com/download/dotnet-core/3.1)\r\n\r\n## Template\r\n\r\nThe easiest way to get started is to use the provided template:\r\n\r\n1. Install the `dotnet` template with `dotnet new -i Saturn.Template`\r\n2. Create a new folder and move into it - `mkdir SaturnSample && cd SaturnSample`\r\n3. Create a new Saturn application - `dotnet new saturn -lang F#`\r\n4. Install all necessary dev tools - `dotnet tool restore`\r\n6. Create a new controller with `dotnet saturn gen Book Books id:string title:string author:string`\r\n7. Run migrations that will create the database and Books table (as for now, the generator is using only SQLite DB) - `dotnet saturn migration`\r\n8. Open the folder in your favourite editor (VSCode) and insert the line (`forward \"/books\" Books.Controller.resource`) into `browserRouter` in `Router.fs` file\r\n9. Start the application by running `dotnet fake build -t run` from the root of the solution. This will start the application in watch mode (automatic recompilation on changes) and open your browser on [http://localhost:8085](http://localhost:8085) which should display the index page.\r\n10. Go to [http://localhost:8085/books](http://localhost:8085/books) to see the generated view. All buttons should be working; you can add new entries, and remove or edit old ones.\r\n\r\n\r\n## Hello World\r\n\r\nIf you want to start from scratch with a minimal Saturn webserver:\r\n\r\n1. Create a new F# Project (for example with `dotnet new console -lang F#`)\r\n2. Add the `Saturn` NuGet Package\r\n\r\n```fsharp\r\nopen Saturn\r\nopen Giraffe\r\n\r\nlet app = application {\r\n    use_router (text \"Hello World from Saturn\")\r\n}\r\n\r\nrun app\r\n```\r\n\r\nIf you compile and run this application, it will unconditionally return the text regardless of the path.\r\n\r\nFrom here on out you can add [routers](../explanations/routing.html), [controllers](../explanations/controller.html) and [views](../explanations/view.html).\r\n\r\n## Deep Dive\r\n\r\nTo get a better understanding of Saturn and the whole SAFE Stack you can look at the [SAFE-Dojo](https://github.com/CompositionalIT/SAFE-Dojo).\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/controller.html","title":"Controllers","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Controller\r\n\r\nIn Saturn, a **controller** is a list of routes that is focused on a **model** (an object that contains your data). So if you have a user model, some common operations are to display the list of users, show details of a user, add a user, update or user, or remove a user. A controller is a great way to organize all of these actions.\r\n\r\nEach of the operations is a separate route and a controller is an easy way to group these routes together.\r\n\r\nA basic user controller is shown below:\r\n\r\n*)\r\nopen Saturn\r\n\r\nlet userController = controller {\r\n    index (fun ctx -> \"Index handler version 1\" |> Controller.text ctx) //View list of users\r\n    add (fun ctx -> \"Add handler version 1\" |> Controller.text ctx) //Add a user\r\n    create (fun ctx -> \"Create handler version 1\" |> Controller.text ctx) //Create a user\r\n    show (fun ctx id -> (sprintf \"Show handler version 1 - %i\" id) |> Controller.text ctx) //Show details of a user\r\n    edit (fun ctx id -> (sprintf \"Edit handler version 1 - %i\" id) |> Controller.text ctx)  //Edit a user\r\n    update (fun ctx id -> (sprintf \"Update handler version 1 - %i\" id) |> Controller.text ctx)  //Update a user\r\n}\r\n\r\n(**\r\nHere we can see the `index`, `add`, `create`, `show`, `edit`, and `update` operations but there are more operations that are not shown here like `patch` and `delete`. You can see all the operations int the [API Reference](../reference/Saturn/saturn-controller-controllerbuilder-10.html). You do not have to handle all of the operations.\r\n\r\nYou might be wondering what the difference is between `add` and `create` or `edit` and `update`. The `add` operation tells the application to return the form so that the user can enter the data for the user to be added. The `create` operation will commit the data to the database of the application. It is the same with `edit` for displaying the form and `update` for committing the change.\r\n\r\nTo add the controller for the routes, you can add it to the `defaultView` router like so:\r\n\r\n*)\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n    forward \"/users\" userController\r\n}\r\n\r\n(**\r\nThe route will now be:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            ├── \"/default.html\"     -redirect to yoursite.com/\r\n            └── \"/users\"\r\n                ├── index \"/\"           -yoursite.com/users/\r\n                ├── add \"/add\"          -yoursite.com/users/add\r\n                ├── create              -POST yoursite.com/users/add\r\n                ├── show \"/%i\"          -yoursite.com/users/%i\r\n                ├── edit \"/%i/edit\"     -yoursite.com/users/%i/edit\r\n                └── update \"\"           -POST yoursite.com/users/%i/edit\r\n```\r\n\r\nThe create and update operations make changes to the database so you have to make a POST request containing the information you want to save to the database.\r\n\r\n## Subcontroller\r\n\r\nNow that you know how to chain routers together to create routes, we can look at a common scenario for a website. A website usually has users and each user can create multiple comments.\r\n\r\n```bash\r\nyoursite.com\r\n└── \"/users\"\r\n    └── \"/%i\"           -yoursite.com/users/%i\r\n        └── \"/comments\" (commentController)\r\n            ├── index \"/\"           -yoursite.com/users/{userId}/comments/\r\n            └── show \"/%i\"          -yoursite.com/users/{userId}/comments/{commentId}\r\n```\r\n\r\nIn Saturn, you can make the comment controller a subcontroller of the user controller. It looks like the following code:\r\n\r\n*)\r\n\r\nlet commentController userId = controller {\r\n    index (fun ctx -> (sprintf \"Comment Index handler for user %i\" userId ) |> Controller.text ctx)\r\n    add (fun ctx -> (sprintf \"Comment Add handler for user %i\" userId ) |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show comment %s handler for user %i\" id userId ) |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit comment %s handler for user %i\" id userId )  |> Controller.text ctx)\r\n}\r\n\r\nlet userController = controller {\r\n    subController \"/comments\" commentController\r\n\r\n    plug [All] (setHttpHeader \"user-controller-common\" \"123\")\r\n    plug [Index; Show] (setHttpHeader \"user-controller-specialized\" \"123\")\r\n\r\n    index (fun ctx -> \"Index handler no version\" |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show handler no version - %i\" id) |> Controller.text ctx)\r\n    add (fun ctx -> \"Add handler no version\" |> Controller.text ctx)\r\n    create (fun ctx -> \"Create handler no version\" |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit handler no version - %i\" id) |> Controller.text ctx)\r\n    update (fun ctx id -> (sprintf \"Update handler no version - %i\" id) |> Controller.text ctx)\r\n    delete (fun ctx id -> failwith (sprintf \"Delete handler no version failed - %i\" id) |> Controller.text ctx)\r\n    error_handler (fun ctx ex -> sprintf \"Error handler no version - %s\" ex.Message |> Controller.text ctx)\r\n}\r\n\r\n(**\r\n\r\nTo create a subcontroller, start with creating a controller for your model. After that, define it as a subcontroller inside the main controller with the following code:\r\n\r\n```fsharp\r\n    subController \"/yourModel\" yourModelController\r\n```\r\n\r\n\r\n## API Reference\r\n\r\nFull API reference for `controller` CE can be found [here](../reference/Saturn/saturn-controller-controllerbuilder-10.html)\r\n\r\nFull API reference for `Controller` module containing useful helpers can be found [here](../reference/Saturn/saturn-controllerhelpers-controller.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/pipeline.html","title":"Pipeline","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Pipelines\r\n\r\nPipeline is a computation expression used to combine `HttpHandlers` in a declarative manner.\r\n\r\nThe result of the computation expression is a standard Giraffe `HttpHandler` which means that it's easily composable with other parts of the Giraffe ecosystem.\r\n\r\n**Example:**\r\n\r\n*)\r\n\r\nopen Saturn\r\n\r\nlet headerPipe = pipeline {\r\n    set_header \"myCustomHeader\" \"abcd\"\r\n    set_header \"myCustomHeader2\" \"zxcv\"\r\n}\r\n\r\nlet endpointPipe = pipeline {\r\n    plug fetchSession\r\n    plug head\r\n    plug requestId\r\n}\r\n\r\n\r\n(**\r\n## API Reference\r\n\r\nFull API reference for `pipeline` CE can be found [here](../reference/Saturn/saturn-pipeline-pipelinebuilder.html)\r\n\r\nFull API reference for `PipelineHelpers` module containing useful helpers can be found [here](../reference/Saturn/saturn-pipelinehelpers.html)\r\n\r\nYou can also use in pipelines (using `plug`) any `HttpHandler` defined in Giraffe - documentation can be found [here](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/routing.html","title":"Router","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\nmodule Index =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nmodule NotFound =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nlet someScopeOrController = Giraffe.ResponseWriters.text \"\"\r\n\r\n(**\r\n# Routing\r\n\r\nRoutes are how Saturn connects all the HTTP requests to the different actions. Think of a route as the URL of the application. The site is yoursite.com but you may have a route for your about page such as yoursite.com/about.\r\n\r\nIn Saturn, `Routers` contain all the routes of your application. A router is a list of routes. A website can have a router that handles the different routes to your page like so:\r\n\r\n```bash\r\nyoursite.com\r\n├── \"/\"             -yoursite.com/\r\n├── \"/about\"        -yoursite.com/about\r\n├── \"/contact\"      -yoursite.com/contact\r\n├── \"/news\"         -yoursite.com/news\r\n└── \"/investors\"    -yoursite.com/investors\r\n```\r\n\r\nSince this is at the root, this is your router at `\"\"` path. You can then add a router inside another router to have the following:\r\n\r\n```bash\r\nyoursite.com\r\n├── books           -yoursite.com/books\r\n|   ├── list        -yoursite.com/books/list\r\n|   ├── add         -yoursite.com/books/add\r\n|   ├── update      -yoursite.com/books/update\r\n|   └── delete      -yoursite.com/books/update\r\n├── about           -yoursite.com/about\r\n├── contact         -yoursite.com/contact\r\n├── news            -yoursite.com/news\r\n└── investors       -yoursite.com/investors\r\n```\r\n\r\nNow you have a router for the `\"/books\"` path inside another router for the `\"\"` path.\r\n\r\nNow to see it in code, create a Saturn project from the template and you will have a `Router.fs` file like this:\r\n\r\n*)\r\n\r\n\r\nopen Saturn\r\nopen Giraffe.Core\r\nopen Giraffe.ResponseWriters\r\n\r\n\r\nlet browser = pipeline {\r\n    plug acceptHtml\r\n    plug putSecureBrowserHeaders\r\n    plug fetchSession\r\n    set_header \"x-pipeline-type\" \"Browser\"\r\n}\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\nlet browserRouter = router {\r\n    not_found_handler (htmlView NotFound.layout) //Use the default 404 webpage\r\n    pipe_through browser //Use the default browser pipeline\r\n\r\n    forward \"\" defaultView //Use the default view\r\n}\r\n\r\n//Other scopes may use different pipelines and error handlers\r\n\r\n// let api = pipeline {\r\n//     plug acceptJson\r\n//     set_header \"x-pipeline-type\" \"Api\"\r\n// }\r\n\r\n// let apiRouter = router {\r\n//     not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n//     pipe_through api\r\n//\r\n//     forward \"/someApi\" someScopeOrController\r\n// }\r\n\r\nlet appRouter = router {\r\n    // forward \"/api\" apiRouter\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nFirst, take a look at the `router` function.\r\n\r\n*)\r\n\r\nlet appRouter' = router {\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nThe `appRouter` value is a `router`. Inside is the `forward \"\" browserRouter` line. The `forward` function needs a path and a router. In this case, the path is an empty string and the router is `browserRouter`. That means that the `browserRouter` router will handle the routes at the current location. Since `appRouter` is the first router called, the current location is the root of the application.\r\n\r\nNow let's look at `browserRouter`:\r\n\r\n*)\r\n\r\nlet browserRouter' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    forward \"\" defaultView\r\n}\r\n\r\n(**\r\n\r\nThere are three lines. The first line, `not_found_handler (htmlView NotFound.layout)` tells `browserRouter` to display a not found page if the user enters a route that the application does not handle. The second line tells the application to use the `browser` pipeline defined above. The pipeline is a list of settings on how the website will deliver the pages. Lastly, `forward \"\" defaultView` is like `forward \"\" browserRouter` from the `appRouter`. Again, `browserRouter` does not contain any routes but it tells the `defaultView` router to handle them. Finally, we get to the part where the application is told how to handle the routes. Inside `defaultView`, we created 3 routes:\r\n\r\n*)\r\n\r\nlet defaultView' = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nHere, we see that `get` is used to define the routes. There are 3 routes here but 2 of them redirect to the first route. To illustrate, the routes are:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            └── \"/default.html\"     -redirect to yoursite.com/\r\n```\r\n\r\nLooking at the first line inside `defaultView`, `get \"/\" (htmlView Index.layout)` tells the application to display `Index.layout` at the root of the application. The `get` corresponds to the HTTP verb GET so when you type in a link, the browser tries to GET the page. The first parameter of `get` is \"/\", so basically when getting the root, the `get` function will return something. The second parameter is `(htmlView Index.layout)` so the `get` function returns an HTML page specified by Index.layout. The second and third line have `(redirectTo false \"/\")`, telling the application to go to \"yoursite.com/\" when going to \"yoursite.com/index\" or \"yoursite.com/default\"\r\n\r\n## Best Practices\r\n\r\nYou can combine all 3 routers into one router like so:\r\n\r\n*)\r\n\r\n\r\nlet appRouter'' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nThe template splits them into 3 to encourage good practices. In the first router, you can see the commented out code `forward \"/api\" apiRouter`. This is a good suggestion in the template to have a separate router to handle your API routes. We set up how to deliever the webpage with `pipe_through browser` in `browserRouter`. The settings are important for a browser to know how to handle your routes but not for a different application to access your routes as an API.\r\n\r\nThe template provides an example of how to set up the API routes in the commented out code, which I copied below:\r\n\r\n*)\r\n\r\nlet api = pipeline {\r\n    plug acceptJson\r\n    set_header \"x-pipeline-type\" \"Api\"\r\n}\r\n\r\nlet apiRouter = router {\r\n    not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n    pipe_through api\r\n\r\n    forward \"/someApi\" someScopeOrController\r\n}\r\n\r\n(**\r\n\r\nHere we have the `apiRouter` router which does not return a 404 page but a 404 text instead which is appropriate for an API. The router also uses a pipeline that is more appropriate for an API such as accepting JSON inputs instead of HTML as in the `browser` pipeline.\r\n\r\n## Format Strings\r\n\r\nYou might be wondering how to make routes that accept a numerical ID. You can make multiple routes for each ID like so\r\n\r\n```fsharp\r\nget \"/1\" (getApplication 1)\r\nget \"/2\" (getApplication 2)\r\nget \"/3\" (getApplication 3)\r\n...\r\n```\r\n\r\nBut this is impracticle because there can be a large number of items or new items are constantly being created with new IDs. Instead the solution is to use format strings. Remember that in the [Adding Pages Guide](../tutorials/adding-pages.html), we used `getf \"/%s\" index2Action` to pass a string to page.\r\n\r\n| Format Char | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nFor a numerical ID, we want to pass an int which is `%i` in the list above, so you can replace the lines above with\r\n\r\n```fsharp\r\ngetf \"/%i\" getApplication\r\n```\r\n\r\nNotice that `getf` is used instead of get. This is a separate version of get that handles `f`ormat characters.\r\n\r\n    You can use format strings with \"forward\" too by using \"forwardf\"\r\n\r\n## API Reference\r\n\r\nFull API reference for `router` CE can be found [here](../reference/Saturn/saturn-router-routerbuilder.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/reference/Saturn.Extensions.HttpSys/index.html","title":"Saturn.Extensions.HttpSys - API Reference","content":"Saturn.Extensions.HttpSys \n global"},{"uri":"https://saturnframework.org/reference/Saturn.Extensions.HttpSys/global-saturn.html","title":"Saturn","content":"Saturn \n  \n  \n  \n  \n UseHttpSys <p>HTTP.sys is a web server for ASP.NET Core that only runs on Windows. HTTP.sys is an alternative to Kestrel server and offers some features that Kestrel doesn't provide.\r\n(<a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/httpsys)\r\nThis\">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/httpsys)\r\nThis</a> operation switches hosting to the HTTP.sys server.</p>\r\n\r\n UseHttpSysWithConfig <p>HTTP.sys is a web server for ASP.NET Core that only runs on Windows. HTTP.sys is an alternative to Kestrel server and offers some features that Kestrel doesn't provide.\r\n(<a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/httpsys)\r\nThis\">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/httpsys)\r\nThis</a> operation switches hosting to the HTTP.sys server and takes additional config.</p>\r\n\r\n UserHttpSysWindowsAuth <p>HTTP.sys is a web server for ASP.NET Core that only runs on Windows. HTTP.sys is an alternative to Kestrel server and offers some features that Kestrel doesn't provide.\r\n(<a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/httpsys)\r\nThis\">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/httpsys)\r\nThis</a> operation switches hosting to the HTTP.sys server and enables Windows Auth (NTLM/Negotiate).</p>\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/directory-structure.html","title":"Directory Structure","content":"\r\n# Directory Structure\r\n\r\nAfter creating a new Saturn project, let's take a deeper look into what files are created.\r\n\r\n```bash\r\n├── .fake\r\n├── .paket\r\n├── .vs\r\n├── .packages\r\n├── paket-files\r\n├── src\r\n|   ├── Migrations\r\n|   └── SaturnSample\r\n├── .gitignore\r\n├── build.fsx\r\n├── global.json\r\n├── paket.dependencies\r\n├── paket.lock\r\n└── SaturnSample.sln\r\n```\r\n\r\nAt this level most of it is basic configuration files to help with running Saturn. From looking at the `.paket`, `paket-files`, `paket.dependencies`, `paket.lock` folders and files, you can see that by default Saturn uses [paket](https://fsprojects.github.io/Paket/) to handle package management. You won't be working with these files directly but rather through the command line tools instead.\r\n\r\nSaturn also uses [FAKE](https://fake.build/) to build the project. You can see how it is set up by looking at the `.fake` folder and `build.fsx` file.\r\n\r\nSaturn also provides a `.gitignore` file that prevents some folders from being tracked by git when they don't need to.\r\n\r\nLastly, there is the `SaturnSample.sln` solution file so you can open the project in an IDE like Visual Sudio and a `global.json` file to configure the solution file.\r\n\r\n### Project structure\r\n\r\nMost of the work you will do in this project however, will be in `src/SaturnSample`, which looks like the following when expanded:\r\n\r\n```bash\r\n  ├── bin\r\n  ├── Books\r\n  |   ├── BooksController.fs\r\n  |   ├── BooksModel.fs\r\n  |   ├── BooksRepository.fs\r\n  |   └── BooksView.fs\r\n  ├── obj\r\n  ├── static\r\n  |   ├── app.css\r\n  |   └── app.js\r\n  ├── Templates\r\n  |   ├── App.fs\r\n  |   ├── Index.fs\r\n  |   ├── InternalError.fs\r\n  |   └── NotFound.fs\r\n  ├── Config.fs\r\n  ├── Database.fs\r\n  ├── database.sqlite\r\n  ├── paket.references\r\n  ├── Program.fs\r\n  ├── Router.fs\r\n  └── SaturnSample.fsproj\r\n```\r\n\r\n`bin` and `obj` folders store the compiled version of the program after you build the project.\r\n\r\nThe convention for Saturn is that the model and everything associated with it are inside one folder. Everything is also named with the plural form of the model so \"Books\" instead of \"Book\".\r\n\r\nYour static files like css, js, and images should be inside the `static` folder.\r\n\r\n`Config.fs` contains a `Config` record that stores settings that you can use inside your application. By default, the record only contains the `connectionString` field.\r\n\r\n`Database.fs` contains functions to execute SQL queries within the program through [Dapper](https://stackexchange.github.io/Dapper/).\r\n\r\nIf you did not run `dotnet saturn migration` as in the [how to start guide](../tutorials/how-to-start.html), you might not see `database.sqlite`, but that is the database file that your Saturn project is using to store data.\r\n\r\n`paket.references` shows the packages that your project is using.\r\n\r\n`Program.fs` handles intializing the program and loading up various settings.\r\n\r\n`Router.fs` is where you will set the route of the site and what page to load.\r\n\r\nLastly, `SaturnSample.fsproj` is the project file itself."},{"uri":"https://saturnframework.org/explanations/endpoint-routing.html","title":"Endpoint Routing","content":"\r\n# Endpoint Routing\r\n\r\nSaturn from version `0.15` supports [ASP.NET Endpoint Routing](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1) additionally to custom routing implementation provided by Giraffe. The main difference between old routing and new one is that Endpoint Routing assumes total separation of routing from behavior - it works by statically defining list of all possible routes on startup of application. This impacts design of some of our Saturn abstractions, and means new routing is not 100% compatible with old one. On the bright side, theoretically, Endpoint Routing should provide noticeable performance boost, and in the future it will allow for better ecosystem integration.\r\n\r\n> Currently endpoint routing API is treated as an experimental API - it's subject to changes.\r\n\r\nTo use Endpoint Routing you need to open `Saturn.Endpoint` namespace - this will override known `router` and `controller` Computation Expressions with their Endpoint Routing versions. In `application` CE instead of using `use_router` operation you should use `use_endpoint_router` operation. For many simple applications this may be enough to get things working - we've been trying to keep API as compatible as possible.\r\n\r\nHowever there are differences:\r\n\r\n* With Endpoint Routing `router` and `controller` computation expressions are not transformed to `HttpHandler` but rather to `Endpoint list`. This has a huge impact on composability of those abstractions - you can't do things like `myHttpHandler >=> router { ... }` any more. Such code should be replaced with `plug/pipe_through` functionality in both `router` and `controller`. `Endpoint list` can basically be used in 2 places - in `forward` operation in `router` and `use_endpoint_router` in `application`.\r\n* Lack of `subroutef` in Giraffe-EndpointRouting - beacuse EndpointRouting needs to have all possible route templates at the application startup it's really hard to emulate some of previous Giraffe's routing composibility capabilities. From Saturn point of view this created 2 major changes:\r\n  - there's no `forwardf` in `router` CE anymore - it should be replaced with set of `getf/postf/putf ... ` operations in child router.\r\n  - `subController` in `controller` CE doesn't work well in Endpoint Routing - you can use as subcontrollers only old, HttpHandler based controllers (even if you parent controller is Endpoint Routing controller). In `Saturn.Endpoint` we provide additonal `subcontroller` CE - it's an alias to old `controller` CE\r\n* Lack of `case_insensitive` in `router` and `controller` - with Endpoint Routing all routes are case insensitive by default and there's no easy way to change it\r\n* Lack of `not_found_handler` in `router` and `controller` - as Endpoint Routing creates global table of routing having scoped not-found handlers is really tricky. Use built-in ways of handle 404 in ASP.NET (such as `UseDeveloperExceptionPage`)\r\n* Unlike Giraffe routing, Endpoint Routing doesn't ensure order of routing checks - this shouldn't be a problem in most cases, but I can imagine some edge cases in which this would matter.\r\n\r\nIn general, to reiterate - Endpoint Routing API in Giraffe/Saturn is still experimental. However, it probably is a future of Giraffe/Saturn so if possible please check if your applications can move to the Endpoint Routing API, and try it out. It's important for everyone involved to get feedback on this new routing engine."},{"uri":"https://saturnframework.org/explanations/overview.html","title":"Saturn Overview","content":"\r\n# Saturn Overview\r\n\r\nSaturn is a web development framework written in F# which implements the server-side MVC pattern. Many of its components and concepts will seem familiar to those of us with experience in other web frameworks like Ruby on Rails or Python’s Django. It's heavily inspired by Elixir's [Phoenix](http://phoenixframework.org/).\r\n\r\nBuilt on top of the battle-tested ASP.NET Core foundation and the highly flexible, extendable model of Giraffe, Saturn provides high level abstractions, helpers and tools to enable high developer productivity, at the same time keeping high application performance provided by Kestrel and Giraffe.\r\n\r\nSaturn is made up of a number of distinct parts, each with its own purpose and role to play in building a web application.\r\n\r\n - Application\r\n    - the start and end of the request life cycle\r\n    - handles all aspects of requests up until the point where the router takes over\r\n    - provides a core set of plugs to apply to all requests\r\n    - dispatches requests into a router\r\n    - enables application and hosting configuration\r\n - [Router](routing.html)\r\n    - parses incoming requests and dispatches them to the correct controller/action, passing parameters as needed\r\n    - provides helpers to generate route paths or urls to resources\r\n    - defines named pipelines through which we may pass our requests\r\n    - allows easy application of groups of plugs to a set of routes\r\n - [Controllers](controller.html)\r\n    - provide functions, called *actions*, to handle requests\r\n    - actions:\r\n        - prepare data and pass it into views\r\n        - invoke rendering via views\r\n        - perform redirects\r\n        - return data as JSON or XML\r\n        - and much more\r\n - [Views](view.html)\r\n    - render templates\r\n    - act as a presentation layer\r\n    - define helper functions, available in templates, to decorate data for presentation\r\n - Channels\r\n    - manage sockets for easy realtime communication\r\n    - are analogous to controllers except that they allow bi-directional communication with persistent connections\r\n - [Scaffolding scripts](scaffolding.html)\r\n    - `dotnet new` template providing good starting point for new applications - [https://github.com/SaturnFramework/Saturn.Template](https://github.com/SaturnFramework/Saturn.Template)\r\n    - `dotnet saturn` CLI tool that controls migrations and let you easily scaffold new parts of application - [https://github.com/SaturnFramework/Saturn.Dotnet](https://github.com/SaturnFramework/Saturn.Dotnet)\r\n\r\n\r\n### Saturn rings\r\n\r\nSaturn itself is the top layer of a multi-layer system designed to create a flexible, productive environment for creating web applications.\r\n\r\n#### Kestrel and ASP.NET Core\r\n\r\nASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-based, Internet-connected applications. Kestrel is a cross-platform web server for ASP.NET Core based on `libuv`, a cross-platform asynchronous I/O library. ASP.NET Core documentation can be found [here](https://docs.microsoft.com/en-us/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-3.1)\r\n\r\n#### [Giraffe](https://github.com/giraffe-fsharp/Giraffe)\r\n\r\nGiraffe is an F# micro web framework for building rich web applications. It has been heavily inspired and is similar to [Suave](https://suave.io), but has been specifically designed with ASP.NET Core in mind and can be plugged into the ASP.NET Core pipeline via middleware. Giraffe applications are composed of so-called HttpHandler functions which can be thought of as a mixture of Suave's WebParts and ASP.NET Core's middleware. As Saturn shares many basic helper functions with Giraffe it's highly recommended to also check out [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n\r\n### Saturn moons\r\n\r\nSaturn is not only a library building on top of Giraffe, but also a set of opinionated tooling for scaffolding a whole project and then generating some boilerplate code. At the moment our template is using (by default):\r\n\r\n#### [Dapper](https://github.com/StackExchange/Dapper)\r\n\r\nA simple, focused on performance object mapper for .Net that you can add in to your project and will extend your `IDbConnection` interface.\r\n\r\n#### [Simple.Migrations](https://github.com/canton7/Simple.Migrations)\r\n\r\nSimple.Migrations is a simple bare-bones migration framework for .NET Core (.NET Standard 1.2 and .NET 4.5). It doesn't provide SQL generation, nor an out-of-the-box command-line tool, nor any other fancy feature. It does however provide a set of simple, extendable, and composable tools for integrating migrations into your application.\r\n\r\n\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/scaffolding.html","title":"Scaffolding","content":"\r\n# Scaffolding\r\n\r\nSaturn provides a command line scaffolding tool to generate a model, database migration, controller, and associated views.\r\n\r\nTo use the generator, run the `dotnet saturn` command from the root of your application application.  If you have used the template to generate your project, this is the directory with `build.fsx` or `paket.dependencies` file.\r\n\r\nThere are three flavors of generators that provide flexibility about what types of code is generated to support your model.\r\n\r\n| Command      |  Generates                                                                     |\r\n|--------------|--------------------------------------------------------------------------------|\r\n| gen          | Creates a model, database layer, HTML views, and a controller.                 |\r\n| gen.json     | Creates a model, database layer, and an API controller to access the model.    |\r\n| gen.model    | Creates only the model and database layer (no controller or views)             |\r\n\r\nEach of these commands will generate a migration for your model as well as a folder containing generated files.\r\n\r\nFor example:\r\n\r\n`dotnet saturn gen Book Books id:string title:string`\r\n\r\nGenerates the following structure:\r\n\r\n```bash\r\nsrc\r\n├── Migrations\r\n│   └── 201903192143.Book.fs\r\n│\r\n└── SaturnSample\r\n    └── Books\r\n        ├── BooksController.fs\r\n        ├── BooksModel.fs\r\n        ├── BooksRepository.fs\r\n        └── BooksViews.fs\r\n```\r\n\r\nEach of the generators takes arguments in the same format:\r\n\r\n`dotnet saturn gen <SingularModelName> <PluralModelName> <List of model fields with types>`\r\n\r\nThe list of model fields are names and types separated by a colon.\r\n\r\n`<fieldname>:<type>`\r\n\r\nCurrently supported types are:\r\n\r\n* string\r\n* int\r\n* float\r\n* double\r\n* decimal\r\n* guid\r\n* datetime\r\n* bool\r\n\r\n## Migrations\r\n\r\nUsing the generator to create a model will also create a migration file that will create a supporting table in the database. Execute the migration script using:\r\n\r\n`dotnet saturn migration`"},{"uri":"https://saturnframework.org/explanations/view.html","title":"View Engine","content":"\r\n# View Engine\r\n\r\n> This post has been originally part of the [Giraffe documentation](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine)\r\n\r\nSaturn is built on top of Giraffe and can use any helpers it provides. This is a case for suggested view engine that you can use in Saturn - Giraffe has its own functional view engine which can be used to build rich UIs for web applications. The single biggest and best contrast to other view engines (e.g. Razor, Liquid, etc.) is that the Giraffe View Engine is entirely functional written in normal (and compiled) F# code.\r\n\r\nThis means that the Giraffe View Engine is by definition one of the most feature rich view engines available, requires no disk IO to load a view and views are automatically compiled at build time.\r\n\r\nThe Giraffe View Engine uses traditional functions and F# record types to generate rich HTML/XML views.\r\n\r\n### HTML Elements and Attributes\r\n\r\nHTML elements and attributes are defined as F# objects:\r\n\r\n```fsharp\r\nlet indexView =\r\n    html [] [\r\n        head [] [\r\n            title [] [ str \"Giraffe Sample\" ]\r\n        ]\r\n        body [] [\r\n            h1 [] [ str \"I |> F#\" ]\r\n            p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                str \"Hello World\"\r\n            ]\r\n        ]\r\n    ]\r\n```\r\n\r\nA HTML element can either be a `ParentNode`, a `VoidElement` or a `Text` element.\r\n\r\nFor example the `<html>` or `<div>` tags are typical `ParentNode` elements. They can hold an `XmlAttribute list` and a second `XmlElement list` for their child elements:\r\n\r\n```fsharp\r\nlet someHtml = div [] []\r\n```\r\n\r\nAll `ParentNode` elements accept these two parameters:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [ _id \"someId\"; _class \"css-class\" ] [\r\n        a [ _href \"https://example.org\" ] [ str \"Some text...\" ]\r\n    ]\r\n```\r\n\r\nMost HTML tags are `ParentNode` elements, however there is a few HTML tags which cannot hold any child elements, such as `<br>`, `<hr>` or `<meta>` tags. These are represented as `VoidElement` objects and only accept the `XmlAttribute list` as single parameter:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        br []\r\n        hr [ _class \"css-class-for-hr\" ]\r\n        p [] [ str \"bla blah\" ]\r\n    ]\r\n```\r\n\r\nAttributes are further classified into two different cases. First and most commonly there are `KeyValue` attributes:\r\n\r\n```fsharp\r\na [\r\n    _href \"http://url.com\"\r\n    _target \"_blank\"\r\n    _class \"class1\" ] [ str \"Click here\" ]\r\n```\r\n\r\nAs the name suggests, they have a key, such as `class` and a value such as the name of a CSS class.\r\n\r\nThe second category of attributes are `Boolean` flags. There are not many but some HTML attributes which do not require any value (e.g. `async` or `defer` in script tags). The presence of such an attribute means that the feature is turned on, otherwise it is turned off:\r\n\r\n```fsharp\r\nscript [ _src \"some.js\"; _async ] []\r\n```\r\n\r\nThere's also a wealth of [accessibility attributes](https://www.w3.org/TR/html-aria/) available under the `Giraffe.GiraffeViewEngine.Accessibility` module (needs to be explicitly opened).\r\n\r\n### Text Content\r\n\r\nNaturally the most frequent content in any HTML document is pure text:\r\n\r\n```html\r\n<div>\r\n    <h1>This is text content</h1>\r\n    <p>This is even more text content!</p>\r\n</div>\r\n```\r\n\r\nThe Giraffe View Engine lets one create pure text content as a `Text` element. A `Text` element can either be generated via the `rawText` or `encodedText` (or the short alias `str`) functions:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        p [] [ rawText \"<div>Hello World</div>\" ]\r\n        p [] [ encodedText \"<div>Hello World</div>\" ]\r\n    ]\r\n```\r\n\r\nThe `rawText` function will create an object of type `XmlNode` where the content will be rendered in its original form and the `encodedText`/`str` function will output a string where the content has been HTML encoded.\r\n\r\nIn this example the first `p` element will literally output the string as it is (`<div>Hello World</div>`) while the second `p` element will output the value as HTML encoded string `&lt;div&gt;Hello World&lt;/div&gt;`.\r\n\r\nPlease be aware that the the usage of `rawText` is mainly designed for edge cases where someone would purposefully want to inject HTML (or JavaScript) code into a rendered view. If not used carefully this could potentially lead to serious security vulnerabilities and therefore should be used only when explicitly required.\r\n\r\nMost cases and particularly any user provided content should always be output via the `encodedText`/`str` function.\r\n\r\n### Javascript event handlers\r\n\r\nIt is possible to add JavaScript event handlers to HTML elements using the Giraffe View Engine.  These event handlers (all prefixed with names starting with `_on`, for example `_onclick`, `_onmouseover`) can either execute inline JavaScript code or can invoke functions that are part of the `window` scope.\r\n\r\nThis example illustrates how inline JavaScript could be used to log to the console when a button is clicked:\r\n\r\n```fsharp\r\nlet inlineJSButton =\r\n    button [_id \"inline-js\"\r\n            _onclick \"console.log(\\\"Hello from the 'inline-js' button!\\\");\"] [str \"Say Hello\" ]\r\n```\r\n\r\nThere are some caveats with this approach, namely that\r\n* it is not very scalable to write JavaScript inline in this manner, and more pressing\r\n* the Giraffe View Engine HTML-encodes the text provided to the `_onX` attributes.\r\n\r\nTo get around this, you can write dedicated scripts in your HTML and reference the functions from your event handlers:\r\n\r\n```fsharp\r\nlet page =\r\n    div [] [\r\n        script [_type \"application/javascript\"] [\r\n            rawText \"\"\"\r\n            window.greet = function () {\r\n                console.log(\"ping from the greet method\");\r\n            }\r\n            \"\"\"\r\n        ]\r\n        button [_id \"script-tag-js\"\r\n                _onclick \"greet();\"] [str \"Say Hello\"]\r\n    ]\r\n```\r\n\r\nHere it's important to note that we've included the text of our script using the `rawText` tag.  This ensures that our text is not encoded by Giraffe so that it remains as we have written it.\r\n\r\nHowever, writing large quantities of JavaScript in this manner can be difficult, because you don't have access to the large ecosystem of javascript editor tooling.  In this case you should write your functions in another script and use a `script` tag element to reference your script, then add the desired function to your HTML element's event handler.\r\n\r\nSay you had a JavaScript file named `greet.js` and had configured Giraffe to serve that script from the WebRoot. Let us also say that the content of that script was:\r\n\r\n```javascript\r\nfunction greet() {\r\n    console.log(\"Hello from the greet function of greet.js!\");\r\n}\r\n```\r\n\r\nThen, you could reference that javascript via a script element, and use `greet` in your event handler like so:\r\n\r\n```fsharp\r\nlet page =\r\n    html [] [\r\n        head [] [\r\n            script [_type \"application/javascript\"\r\n                    _src \"/greet.js\"] [] // include our `greet.js` function dynamically\r\n        ]\r\n        body [] [\r\n            button [_id \"greet-btn\"\r\n                    _onclick \"greet()\"] [] // use the `greet()` function from `greet.js` to say hello\r\n        ]\r\n    ]\r\n```\r\n\r\nIn this way, you can write `greet.js` with all of your expected tooling, and still hook up the event handlers all in one place in Giraffe.\r\n\r\n### Naming Convention\r\n\r\nThe Giraffe View Engine has a naming convention which lets you easily determine the correct function name without having to know anything about the view engine's implementation.\r\n\r\nAll HTML tags are defined as `XmlNode` elements under the exact same name as they are named in HTML. For example the `<html>` tag would be `html [] []`, an `<a>` tag would be `a [] []` and a `<span>` or `<canvas>` would be the `span [] []` or `canvas [] []` function.\r\n\r\nHTML attributes follow the same naming convention except that attributes have an underscore prepended. For example the `class` attribute would be `_class` and the `src` attribute would be `_src` in Giraffe.\r\n\r\nThe underscore does not only help to distinguish an attribute from an element, but also avoid a naming conflict between tags and attributes of the same name (e.g. `<form>` vs. `<input form=\"form1\">`).\r\n\r\nIf a HTML attribute has a hyphen in the name (e.g. `accept-charset`) then the equivalent Giraffe attribute would be written in camel case notion (e.g. `acceptCharset`).\r\n\r\n*Should you find a HTML tag or attribute missing in the Giraffe View Engine then you can either [create it yourself](#custom-elements-and-attributes) or send a [pull request on GitHub](https://github.com/giraffe-fsharp/Giraffe/pulls).*\r\n\r\n### View Engine Best Practices\r\n\r\nDue to the huge amount of available HTML tags and their fairly generic (and short) names (e.g. `<form>`, `<option>`, `<select>`, etc.) there is a significant danger of accidentally overriding a function of the same name in an application's codebase. For that reason the Giraffe View Engine becomes only available after opening the `GiraffeViewEngine` module.\r\n\r\nAs a measure of good practice it is recommended to create all views in a separate module:\r\n\r\n```fsharp\r\nmodule MyWebApplication\r\n\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let index =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str \"Giraffe Sample\" ]\r\n            ]\r\n            body [] [\r\n                h1 [] [ str \"I |> F#\" ]\r\n                p [ _class \"some-css-class\"; _id \"someId\" ] [\r\n                    str \"Hello World\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let other = //...\r\n```\r\n\r\nThis ensures that the opening of the `GiraffeViewEngine` is only contained in a small context of an application's codebase and therefore less of a threat to accidental overrides. In the above example views can always be accessed through the `Views` sub module (e.g. `Views.index`).\r\n\r\n### Custom Elements and Attributes\r\n\r\nAdding new elements or attributes is normally as simple as a single line of code:\r\n\r\n```fsharp\r\nopen Giraffe.GiraffeViewEngine\r\n\r\n// If there was a new <foo></foo> HTML element:\r\nlet foo = tag \"foo\"\r\n\r\n// If <foo> is an element which cannot hold any content then create it as voidTag:\r\nlet foo = voidTag \"foo\"\r\n\r\n// If <foo> has a new attribute called bar then create a new bar attribute:\r\nlet _bar = attr \"bar\"\r\n\r\n// if the bar attribute is a boolean flag:\r\nlet _bar = flag \"bar\"\r\n```\r\n\r\nAlternatively you can also create new elements and attributes from inside another element:\r\n\r\n```fsharp\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n```\r\n\r\n### Rendering Views\r\n\r\nRendering views in Giraffe is done through one of the following functions:\r\n\r\n- `renderHtmlDocument`\r\n- `renderHtmlNodes`\r\n- `renderHtmlNode`\r\n- `renderXmlNodes`\r\n- `renderXmlNode`\r\n\r\nThe Giraffe View Engine cannot only be used to render HTML views, but also for any other XML based content such as `<svg>` images or other arbitrary XML based data.\r\n\r\nThe `renderHtmlDocument` function takes a single `XmlNode` as input parameter and renders a HTML page with a `DOCTYPE` declaration. This function should be used for rendering a complete HTML document. The `WriteHtmlViewAsync` extension method and the `htmlView` http handler both use the `renderHtmlDocument` function under the covers.\r\n\r\nThe `renderHtmlNodes` function takes an `XmlNode list` as input parameter and will output a single HTML string containing all the rendered HTML code. The `renderHtmlNode` function renders a single `XmlNode` element into a valid HTML string. Both, the `renderHtmlNodes` and `renderHtmlNode` function are useful for use cases where a HTML snippet needs to be created without a `DOCTYPE` declaration (e.g. templated emails, etc.).\r\n\r\nThe `renderXmlNodes` and `renderXmlNode` function are identical to `renderHtmlNodes` and `renderHtmlNode`, except that they will render void elements differently:\r\n\r\n```fsharp\r\nlet someTag = voidTag \"foo\"\r\nlet someContent = someTag []\r\n\r\n// Void tag will be rendered to valid HTML: <foo>\r\nlet output1 = renderHtmlNode someContent\r\n\r\n// Void tag will be rendered to valid XML: <foo />\r\nlet output2 = renderXmlNode someContent\r\n```\r\n\r\nAll `GiraffeViewEngine` http handlers are using a thread static `StringBuilderPool` to avoid the creation of large `StringBuilder` objects for each render call and dynamically grow/shrink that pool based on the application's needs. However if the application is running into any memory issues then this performance feature can be disabled by setting `StringBuilderPool.IsEnabled <- false`.\r\n\r\nAdditionally with Giraffe 3.0.0 or higher there is a new module called `ViewBuilder` under the `Giraffe.GiraffeViewEngine` namespace. This module exposes additional view rendering functions which compile a view into a `StringBuilder` object instead of returning a single `string`:\r\n\r\n- `ViewBuilder.buildHtmlDocument`\r\n- `ViewBuilder.buildHtmlNodes`\r\n- `ViewBuilder.buildHtmlNode`\r\n- `ViewBuilder.buildXmlNodes`\r\n- `ViewBuilder.buildXmlNode`\r\n\r\nThe `ViewBuilder.build[...]` functions can be useful if there is additional string processing required before/after composing a view by the `GiraffeViewEngine` (e.g. embedding HTML snippets in an email template, etc.). These functions also serve as the lower level building blocks of the equivalent `render[...]` functions.\r\n\r\nExample usage:\r\n\r\n```fsharp\r\nopen System.Text\r\nopen Giraffe.GiraffeViewEngine\r\n\r\nlet someHtml =\r\n    div [] [\r\n        tag \"foo\" [ attr \"bar\" \"blah\" ] [\r\n            voidTag \"otherFoo\" [ flag \"flag1\" ]\r\n        ]\r\n    ]\r\n\r\nlet sb = new StringBuilder()\r\n\r\n// Perform actions on the `sb` object...\r\nsb.AppendLine \"This is a HTML snippet inside a markdown string:\"\r\n  .AppendLine \"\"\r\n  .AppendLine \"```html\" |> ignore\r\n\r\nlet sb' = ViewBuilder.buildHtmlNode sb someHtml\r\n\r\n// Perform more actions on the `sb` object...\r\nsb'.AppendLine \"```\" |> ignore\r\n\r\nlet markdownOutput = sb'.ToString()\r\n```\r\n\r\n### Common View Engine Features\r\n\r\nThe Giraffe View Engine doesn't have any specially built functions for commonly known features such as master pages or partial views, mainly because the nature of the view engine itself doesn't require it in most cases.\r\n\r\n#### Master Pages\r\n\r\nCreating a master page is a simple matter of piping two functions together:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n... or even have multiple nested master pages:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let master1 (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n        ]\r\n\r\n    let master2 (content: XmlNode list) =\r\n        [\r\n            main [] content\r\n            footer [] [\r\n                p [] [\r\n                    str \"Copyright ...\"\r\n                ]\r\n            ]\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master2 |> master1 pageTitle\r\n```\r\n\r\n#### Partial Views\r\n\r\nA partial view is nothing more than one function or object being called from within another function:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index =\r\n        let pageTitle = \"Giraffe Sample\"\r\n        [\r\n            h1 [] [ str pageTitle ]\r\n            p [] [ str \"Hello world!\" ]\r\n        ] |> master pageTitle\r\n```\r\n\r\n#### Working with Models\r\n\r\nA view which accepts a model is basically a function with an additional parameter:\r\n\r\n```fsharp\r\nmodule Views =\r\n    open Giraffe.GiraffeViewEngine\r\n\r\n    let partial =\r\n        footer [] [\r\n            p [] [\r\n                str \"Copyright...\"\r\n            ]\r\n        ]\r\n\r\n    let master (pageTitle : string) (content: XmlNode list) =\r\n        html [] [\r\n            head [] [\r\n                title [] [ str pageTitle ]\r\n            ]\r\n            body [] content\r\n            partial\r\n        ]\r\n\r\n    let index (model : IndexViewModel) =\r\n        [\r\n            h1 [] [ str model.PageTitle ]\r\n            p [] [ str model.WelcomeText ]\r\n        ] |> master model.PageTitle\r\n```\r\n\r\n#### If Statements, Loops, etc.\r\n\r\nThings like if statements, loops and other normal F# language constructs work just as expected:\r\n\r\n```fsharp\r\nlet partial (books : Book list) =\r\n    ul [] [\r\n        yield!\r\n            books\r\n            |> List.map (fun b -> li [] [ str book.Title ])\r\n    ]\r\n```\r\n\r\nOverall the Giraffe View Engine is extremely flexible and feature rich by nature based on the fact that it is generated via normal compiled F# code."},{"uri":"https://saturnframework.org/tutorials/adding-pages.html","title":"Adding Pages","content":"\r\n# Adding Pages\r\n\r\nThis guide uses the same project from the [how to start guide](how-to-start.html). Let's add two pages to it - one hello page and a page that can get your name from the URL.\r\n\r\n## Creating the View\r\n\r\nTo begin, create a `Hello` folder inside the `src/SaturnSample` folder.\r\n\r\nInside the folder, create a new file called \"HelloViews.fs\". This file will contain the functions to create the page.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Giraffe.GiraffeViewEngine\r\nopen Saturn\r\n\r\nmodule Views =\r\n  let index =\r\n    div [] [\r\n        h2 [] [rawText \"Hello from Saturn!\"]\r\n    ]\r\n```\r\n\r\nOne of the dependencies required is [Giraffe View Engine](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine). This will allow your project to define HTML within your function. The `index` function will result in the following HTML code:\r\n\r\n```html\r\n<div>\r\n    <h2>Hello from Saturn!</h2>\r\n</div>\r\n```\r\n\r\n## Creating the Controller\r\n\r\nCreate a `HelloController.fs` file inside the `Hello` folder.\r\n\r\nThe `index` function tells us what the HTML will be but we still need to tell Saturn to return it as an HTML page. We also need to tell Saturn where the page is.\r\n\r\nInsert the following into the file:\r\n\r\n```fsharp\r\nnamespace Hello\r\n\r\nopen Saturn\r\nopen Giraffe.ResponseWriters\r\n\r\nmodule Controller =\r\n    let indexAction =\r\n        htmlView (Views.index)\r\n\r\n    let helloView = router {\r\n        get \"/\" indexAction\r\n    }\r\n```\r\n\r\nThe `indexAction` tells Saturn to create an HTML page using the `index` function inside \"HelloViews.fs\"\r\n\r\n`helloView` lets Saturn know that the page is located at the root.\r\n\r\n## Adding the 2 new files to the project\r\n\r\nFor the project to see the new files, modify SaturnSample.fsproj as below:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <Compile Include=\"Database.fs\" />\r\n    <Compile Include=\"Config.fs\" />\r\n\r\n    <Compile Include=\"Hello\\HelloViews.fs\" />\r\n    <Compile Include=\"Hello\\HelloController.fs\" />\r\n    ...\r\n```\r\n\r\n## Adding it to Router.fs\r\n\r\n\r\nAfter setting up the route, you need to update the project with the new route.\r\n\r\nIn \"Router.fs\", add the following to the inside of the `browserRouter` function:\r\n\r\n\r\n```fsharp\r\nforward \"/hello\" Hello.Controller.helloView\r\n```\r\n\r\nThis means that when we navigate to [http://localhost:8085/hello](http://localhost:8085/hello), the `helloView` function will determine what page to load there. Looking inside the `helloView` function, we said that `indexAction` is called at the root. In conclusion, the page will be located at [http://localhost:8085/hello/](http://localhost:8085/hello/). (Note the \"/\" at the end)\r\n\r\nNow run the program and go to [http://localhost:8085/hello/](http://localhost:8085/hello/) and you will see a page saying \"Hello from Saturn!\"\r\n\r\n## Sending a parameter to your page\r\n\r\nWhat if you want the page to display your name?\r\n\r\nOne way to retrieve your name is to get it from the route. So when you go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) with {yourname} being your actual name, it will grab your name which can then be used to display on the page.\r\n\r\nTo begin, add a new view in your `HelloViews.fs`:\r\n\r\n```fsharp\r\n  let index2 (name : string) =\r\n    div [] [\r\n        h2 [] [rawText (\"Hello \" + name + \"!\")]\r\n    ]\r\n```\r\n\r\nThis function requires passing in the name to be displayed. The name will be retrieved from the route.\r\n\r\nAdd the following to the `HelloController.fs` file below the `helloView` handler:\r\n\r\n```fsharp\r\nlet index2Action name=\r\n    htmlView (Hello.Views.index2 name)\r\n```\r\n\r\nNow to set up the route. Add the following to the `HelloView` handler:\r\n\r\n```fsharp\r\ngetf \"/%s\" index2Action\r\n```\r\n\r\n\"%s\" is a format string. This lets Saturn know to save whatever you type in that spot. Since we want to save a name, we want to save it as a string so we use `%s`.\r\n\r\nThere are other format strings for different types:\r\n\r\n| Format String | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nNow run the program and go to [http://localhost:8085/hello/{yourname}](http://localhost:8085/hello/{yourname}) and replace `{yourname}` with your name to see a page that will greet you.\r\n"},{"uri":"https://saturnframework.org/tutorials/adding-saturn-to-an-existing-giraffe-app.html","title":"Adding Saturn to an existing Giraffe application","content":"\r\n# Adding Saturn to an existing Giraffe application\r\n\r\nThe previous chapter showed how to get started with a new application.\r\n\r\nIf you already have a working Giraffe webserver, you can gradually opt-in to Saturn.\r\n\r\nFor example, if your existing app looks like this:\r\n\r\n```fsharp\r\n\r\ntype Customer = {\r\n    Name : string\r\n    Address : string\r\n}\r\n\r\nlet customers =\r\n    choose [\r\n      GET >=> (json { Name = \"Mr. Smith\"; Address = \"Santa Monika\"})\r\n      PUT >=> (bindJson<Customer> (fun customer -> printfn \"Adding customer %A\" customer; setStatusCode 200))\r\n    ]\r\n\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"               >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n    ]\r\n```\r\n\r\nand you need to add \"vendor\" functionality, you could implement it as a Saturn ``router`` while keeping everything else intact:\r\n\r\n\r\n```fsharp\r\n// the new Saturn router\r\nlet vendors = router {\r\n    getf \"/%i\" (fun vendorId -> (json (readVendorFromDb vendorId)))\r\n    post \"/\" (bindJson<Vendor> (fun customer -> addVendor vendor; setStatusCode 200))\r\n}\r\n\r\nlet webApp =\r\n    choose [\r\n        route \"/\"                >=> htmlFile \"/pages/index.html\"\r\n        route \"/api/customers\"   >=> customers\r\n        // plug the new Saturn router into the Giraffe app\r\n        route \"/api/vendors\"     >=> vendors\r\n    ]\r\n```\r\n\r\n## Embedding Giraffe Handlers into Saturn\r\n\r\nOf course the other way around also works.\r\n\r\nFor example, [Elmish.Bridge](https://github.com/Nhowka/Elmish.Bridge) does not provide a specialized implementation for Saturn. And it doesn't need to, because we can just use the Giraffe implementation!\r\n\r\n```fsharp\r\n\r\nopen Elmish\r\nopen Elmish.Bridge\r\n\r\nlet elmishBridgeHandler : HttpHandler =\r\n  Bridge.mkServer Shared.endpoint init update\r\n  |> Bridge.run Giraffe.server\r\n\r\n// our existing Saturn router\r\nlet router = router {\r\n\r\n    // ...\r\n\r\n    forward \"\" elmishBridgeHandler\r\n}\r\n```\r\n"},{"uri":"https://saturnframework.org/tutorials/how-to-start.html","title":"Getting started","content":"\r\n# How to start in 60 seconds\r\n\r\nRequirements:\r\n\r\n* `dotnet` SDK 3.1 [https://dotnet.microsoft.com/download/dotnet-core/3.1](https://dotnet.microsoft.com/download/dotnet-core/3.1)\r\n\r\n## Template\r\n\r\nThe easiest way to get started is to use the provided template:\r\n\r\n1. Install the `dotnet` template with `dotnet new -i Saturn.Template`\r\n2. Create a new folder and move into it - `mkdir SaturnSample && cd SaturnSample`\r\n3. Create a new Saturn application - `dotnet new saturn -lang F#`\r\n4. Install all necessary dev tools - `dotnet tool restore`\r\n6. Create a new controller with `dotnet saturn gen Book Books id:string title:string author:string`\r\n7. Run migrations that will create the database and Books table (as for now, the generator is using only SQLite DB) - `dotnet saturn migration`\r\n8. Open the folder in your favourite editor (VSCode) and insert the line (`forward \"/books\" Books.Controller.resource`) into `browserRouter` in `Router.fs` file\r\n9. Start the application by running `dotnet fake build -t run` from the root of the solution. This will start the application in watch mode (automatic recompilation on changes) and open your browser on [http://localhost:8085](http://localhost:8085) which should display the index page.\r\n10. Go to [http://localhost:8085/books](http://localhost:8085/books) to see the generated view. All buttons should be working; you can add new entries, and remove or edit old ones.\r\n\r\n\r\n## Hello World\r\n\r\nIf you want to start from scratch with a minimal Saturn webserver:\r\n\r\n1. Create a new F# Project (for example with `dotnet new console -lang F#`)\r\n2. Add the `Saturn` NuGet Package\r\n\r\n```fsharp\r\nopen Saturn\r\nopen Giraffe\r\n\r\nlet app = application {\r\n    use_router (text \"Hello World from Saturn\")\r\n}\r\n\r\nrun app\r\n```\r\n\r\nIf you compile and run this application, it will unconditionally return the text regardless of the path.\r\n\r\nFrom here on out you can add [routers](../explanations/routing.html), [controllers](../explanations/controller.html) and [views](../explanations/view.html).\r\n\r\n## Deep Dive\r\n\r\nTo get a better understanding of Saturn and the whole SAFE Stack you can look at the [SAFE-Dojo](https://github.com/CompositionalIT/SAFE-Dojo).\r\n\r\n"},{"uri":"https://saturnframework.org/explanations/controller.html","title":"Controllers","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Controller\r\n\r\nIn Saturn, a **controller** is a list of routes that is focused on a **model** (an object that contains your data). So if you have a user model, some common operations are to display the list of users, show details of a user, add a user, update or user, or remove a user. A controller is a great way to organize all of these actions.\r\n\r\nEach of the operations is a separate route and a controller is an easy way to group these routes together.\r\n\r\nA basic user controller is shown below:\r\n\r\n*)\r\nopen Saturn\r\n\r\nlet userController = controller {\r\n    index (fun ctx -> \"Index handler version 1\" |> Controller.text ctx) //View list of users\r\n    add (fun ctx -> \"Add handler version 1\" |> Controller.text ctx) //Add a user\r\n    create (fun ctx -> \"Create handler version 1\" |> Controller.text ctx) //Create a user\r\n    show (fun ctx id -> (sprintf \"Show handler version 1 - %i\" id) |> Controller.text ctx) //Show details of a user\r\n    edit (fun ctx id -> (sprintf \"Edit handler version 1 - %i\" id) |> Controller.text ctx)  //Edit a user\r\n    update (fun ctx id -> (sprintf \"Update handler version 1 - %i\" id) |> Controller.text ctx)  //Update a user\r\n}\r\n\r\n(**\r\nHere we can see the `index`, `add`, `create`, `show`, `edit`, and `update` operations but there are more operations that are not shown here like `patch` and `delete`. You can see all the operations int the [API Reference](../reference/Saturn/saturn-controller-controllerbuilder-10.html). You do not have to handle all of the operations.\r\n\r\nYou might be wondering what the difference is between `add` and `create` or `edit` and `update`. The `add` operation tells the application to return the form so that the user can enter the data for the user to be added. The `create` operation will commit the data to the database of the application. It is the same with `edit` for displaying the form and `update` for committing the change.\r\n\r\nTo add the controller for the routes, you can add it to the `defaultView` router like so:\r\n\r\n*)\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n    forward \"/users\" userController\r\n}\r\n\r\n(**\r\nThe route will now be:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            ├── \"/default.html\"     -redirect to yoursite.com/\r\n            └── \"/users\"\r\n                ├── index \"/\"           -yoursite.com/users/\r\n                ├── add \"/add\"          -yoursite.com/users/add\r\n                ├── create              -POST yoursite.com/users/add\r\n                ├── show \"/%i\"          -yoursite.com/users/%i\r\n                ├── edit \"/%i/edit\"     -yoursite.com/users/%i/edit\r\n                └── update \"\"           -POST yoursite.com/users/%i/edit\r\n```\r\n\r\nThe create and update operations make changes to the database so you have to make a POST request containing the information you want to save to the database.\r\n\r\n## Subcontroller\r\n\r\nNow that you know how to chain routers together to create routes, we can look at a common scenario for a website. A website usually has users and each user can create multiple comments.\r\n\r\n```bash\r\nyoursite.com\r\n└── \"/users\"\r\n    └── \"/%i\"           -yoursite.com/users/%i\r\n        └── \"/comments\" (commentController)\r\n            ├── index \"/\"           -yoursite.com/users/{userId}/comments/\r\n            └── show \"/%i\"          -yoursite.com/users/{userId}/comments/{commentId}\r\n```\r\n\r\nIn Saturn, you can make the comment controller a subcontroller of the user controller. It looks like the following code:\r\n\r\n*)\r\n\r\nlet commentController userId = controller {\r\n    index (fun ctx -> (sprintf \"Comment Index handler for user %i\" userId ) |> Controller.text ctx)\r\n    add (fun ctx -> (sprintf \"Comment Add handler for user %i\" userId ) |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show comment %s handler for user %i\" id userId ) |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit comment %s handler for user %i\" id userId )  |> Controller.text ctx)\r\n}\r\n\r\nlet userController = controller {\r\n    subController \"/comments\" commentController\r\n\r\n    plug [All] (setHttpHeader \"user-controller-common\" \"123\")\r\n    plug [Index; Show] (setHttpHeader \"user-controller-specialized\" \"123\")\r\n\r\n    index (fun ctx -> \"Index handler no version\" |> Controller.text ctx)\r\n    show (fun ctx id -> (sprintf \"Show handler no version - %i\" id) |> Controller.text ctx)\r\n    add (fun ctx -> \"Add handler no version\" |> Controller.text ctx)\r\n    create (fun ctx -> \"Create handler no version\" |> Controller.text ctx)\r\n    edit (fun ctx id -> (sprintf \"Edit handler no version - %i\" id) |> Controller.text ctx)\r\n    update (fun ctx id -> (sprintf \"Update handler no version - %i\" id) |> Controller.text ctx)\r\n    delete (fun ctx id -> failwith (sprintf \"Delete handler no version failed - %i\" id) |> Controller.text ctx)\r\n    error_handler (fun ctx ex -> sprintf \"Error handler no version - %s\" ex.Message |> Controller.text ctx)\r\n}\r\n\r\n(**\r\n\r\nTo create a subcontroller, start with creating a controller for your model. After that, define it as a subcontroller inside the main controller with the following code:\r\n\r\n```fsharp\r\n    subController \"/yourModel\" yourModelController\r\n```\r\n\r\n\r\n## API Reference\r\n\r\nFull API reference for `controller` CE can be found [here](../reference/Saturn/saturn-controller-controllerbuilder-10.html)\r\n\r\nFull API reference for `Controller` module containing useful helpers can be found [here](../reference/Saturn/saturn-controllerhelpers-controller.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/pipeline.html","title":"Pipeline","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\n(**\r\n# Pipelines\r\n\r\nPipeline is a computation expression used to combine `HttpHandlers` in a declarative manner.\r\n\r\nThe result of the computation expression is a standard Giraffe `HttpHandler` which means that it's easily composable with other parts of the Giraffe ecosystem.\r\n\r\n**Example:**\r\n\r\n*)\r\n\r\nopen Saturn\r\n\r\nlet headerPipe = pipeline {\r\n    set_header \"myCustomHeader\" \"abcd\"\r\n    set_header \"myCustomHeader2\" \"zxcv\"\r\n}\r\n\r\nlet endpointPipe = pipeline {\r\n    plug fetchSession\r\n    plug head\r\n    plug requestId\r\n}\r\n\r\n\r\n(**\r\n## API Reference\r\n\r\nFull API reference for `pipeline` CE can be found [here](../reference/Saturn/saturn-pipeline-pipelinebuilder.html)\r\n\r\nFull API reference for `PipelineHelpers` module containing useful helpers can be found [here](../reference/Saturn/saturn-pipelinehelpers.html)\r\n\r\nYou can also use in pipelines (using `plug`) any `HttpHandler` defined in Giraffe - documentation can be found [here](https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md)\r\n*)\r\n"},{"uri":"https://saturnframework.org/explanations/routing.html","title":"Router","content":"(*** hide ***)\r\n#I \"../../../temp/\"\r\n#I \"../../../packages/docsasp/Microsoft.AspNetCore.app.ref/ref/netcoreapp3.1\"\r\n#r \"Saturn.dll\"\r\n#r \"Giraffe.dll\"\r\n#r \"Microsoft.AspNetCore.Http.Abstractions.dll\"\r\n\r\nmodule Index =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nmodule NotFound =\r\n  open Giraffe.GiraffeViewEngine\r\n  let layout = div [] []\r\n\r\nlet someScopeOrController = Giraffe.ResponseWriters.text \"\"\r\n\r\n(**\r\n# Routing\r\n\r\nRoutes are how Saturn connects all the HTTP requests to the different actions. Think of a route as the URL of the application. The site is yoursite.com but you may have a route for your about page such as yoursite.com/about.\r\n\r\nIn Saturn, `Routers` contain all the routes of your application. A router is a list of routes. A website can have a router that handles the different routes to your page like so:\r\n\r\n```bash\r\nyoursite.com\r\n├── \"/\"             -yoursite.com/\r\n├── \"/about\"        -yoursite.com/about\r\n├── \"/contact\"      -yoursite.com/contact\r\n├── \"/news\"         -yoursite.com/news\r\n└── \"/investors\"    -yoursite.com/investors\r\n```\r\n\r\nSince this is at the root, this is your router at `\"\"` path. You can then add a router inside another router to have the following:\r\n\r\n```bash\r\nyoursite.com\r\n├── books           -yoursite.com/books\r\n|   ├── list        -yoursite.com/books/list\r\n|   ├── add         -yoursite.com/books/add\r\n|   ├── update      -yoursite.com/books/update\r\n|   └── delete      -yoursite.com/books/update\r\n├── about           -yoursite.com/about\r\n├── contact         -yoursite.com/contact\r\n├── news            -yoursite.com/news\r\n└── investors       -yoursite.com/investors\r\n```\r\n\r\nNow you have a router for the `\"/books\"` path inside another router for the `\"\"` path.\r\n\r\nNow to see it in code, create a Saturn project from the template and you will have a `Router.fs` file like this:\r\n\r\n*)\r\n\r\n\r\nopen Saturn\r\nopen Giraffe.Core\r\nopen Giraffe.ResponseWriters\r\n\r\n\r\nlet browser = pipeline {\r\n    plug acceptHtml\r\n    plug putSecureBrowserHeaders\r\n    plug fetchSession\r\n    set_header \"x-pipeline-type\" \"Browser\"\r\n}\r\n\r\nlet defaultView = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\nlet browserRouter = router {\r\n    not_found_handler (htmlView NotFound.layout) //Use the default 404 webpage\r\n    pipe_through browser //Use the default browser pipeline\r\n\r\n    forward \"\" defaultView //Use the default view\r\n}\r\n\r\n//Other scopes may use different pipelines and error handlers\r\n\r\n// let api = pipeline {\r\n//     plug acceptJson\r\n//     set_header \"x-pipeline-type\" \"Api\"\r\n// }\r\n\r\n// let apiRouter = router {\r\n//     not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n//     pipe_through api\r\n//\r\n//     forward \"/someApi\" someScopeOrController\r\n// }\r\n\r\nlet appRouter = router {\r\n    // forward \"/api\" apiRouter\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nFirst, take a look at the `router` function.\r\n\r\n*)\r\n\r\nlet appRouter' = router {\r\n    forward \"\" browserRouter\r\n}\r\n\r\n(**\r\n\r\nThe `appRouter` value is a `router`. Inside is the `forward \"\" browserRouter` line. The `forward` function needs a path and a router. In this case, the path is an empty string and the router is `browserRouter`. That means that the `browserRouter` router will handle the routes at the current location. Since `appRouter` is the first router called, the current location is the root of the application.\r\n\r\nNow let's look at `browserRouter`:\r\n\r\n*)\r\n\r\nlet browserRouter' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    forward \"\" defaultView\r\n}\r\n\r\n(**\r\n\r\nThere are three lines. The first line, `not_found_handler (htmlView NotFound.layout)` tells `browserRouter` to display a not found page if the user enters a route that the application does not handle. The second line tells the application to use the `browser` pipeline defined above. The pipeline is a list of settings on how the website will deliver the pages. Lastly, `forward \"\" defaultView` is like `forward \"\" browserRouter` from the `appRouter`. Again, `browserRouter` does not contain any routes but it tells the `defaultView` router to handle them. Finally, we get to the part where the application is told how to handle the routes. Inside `defaultView`, we created 3 routes:\r\n\r\n*)\r\n\r\nlet defaultView' = router {\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nHere, we see that `get` is used to define the routes. There are 3 routes here but 2 of them redirect to the first route. To illustrate, the routes are:\r\n\r\n```bash\r\nyoursite.com\r\n└── \"\" (router)\r\n    └── \"\" (browserRouter)\r\n        └── \"\" (defaultView)\r\n            ├── \"/\"                 -yoursite.com/\r\n            ├── \"/index.html\"       -redirect to yoursite.com/\r\n            └── \"/default.html\"     -redirect to yoursite.com/\r\n```\r\n\r\nLooking at the first line inside `defaultView`, `get \"/\" (htmlView Index.layout)` tells the application to display `Index.layout` at the root of the application. The `get` corresponds to the HTTP verb GET so when you type in a link, the browser tries to GET the page. The first parameter of `get` is \"/\", so basically when getting the root, the `get` function will return something. The second parameter is `(htmlView Index.layout)` so the `get` function returns an HTML page specified by Index.layout. The second and third line have `(redirectTo false \"/\")`, telling the application to go to \"yoursite.com/\" when going to \"yoursite.com/index\" or \"yoursite.com/default\"\r\n\r\n## Best Practices\r\n\r\nYou can combine all 3 routers into one router like so:\r\n\r\n*)\r\n\r\n\r\nlet appRouter'' = router {\r\n    not_found_handler (htmlView NotFound.layout)\r\n    pipe_through browser\r\n\r\n    get \"/\" (htmlView Index.layout)\r\n    get \"/index.html\" (redirectTo false \"/\")\r\n    get \"/default.html\" (redirectTo false \"/\")\r\n}\r\n\r\n(**\r\n\r\nThe template splits them into 3 to encourage good practices. In the first router, you can see the commented out code `forward \"/api\" apiRouter`. This is a good suggestion in the template to have a separate router to handle your API routes. We set up how to deliever the webpage with `pipe_through browser` in `browserRouter`. The settings are important for a browser to know how to handle your routes but not for a different application to access your routes as an API.\r\n\r\nThe template provides an example of how to set up the API routes in the commented out code, which I copied below:\r\n\r\n*)\r\n\r\nlet api = pipeline {\r\n    plug acceptJson\r\n    set_header \"x-pipeline-type\" \"Api\"\r\n}\r\n\r\nlet apiRouter = router {\r\n    not_found_handler (setStatusCode 404 >=> text \"Api 404\")\r\n    pipe_through api\r\n\r\n    forward \"/someApi\" someScopeOrController\r\n}\r\n\r\n(**\r\n\r\nHere we have the `apiRouter` router which does not return a 404 page but a 404 text instead which is appropriate for an API. The router also uses a pipeline that is more appropriate for an API such as accepting JSON inputs instead of HTML as in the `browser` pipeline.\r\n\r\n## Format Strings\r\n\r\nYou might be wondering how to make routes that accept a numerical ID. You can make multiple routes for each ID like so\r\n\r\n```fsharp\r\nget \"/1\" (getApplication 1)\r\nget \"/2\" (getApplication 2)\r\nget \"/3\" (getApplication 3)\r\n...\r\n```\r\n\r\nBut this is impracticle because there can be a large number of items or new items are constantly being created with new IDs. Instead the solution is to use format strings. Remember that in the [Adding Pages Guide](../tutorials/adding-pages.html), we used `getf \"/%s\" index2Action` to pass a string to page.\r\n\r\n| Format Char | Type |\r\n| ----------- | ---- |\r\n| `%b` | `bool` |\r\n| `%c` | `char` |\r\n| `%s` | `string` |\r\n| `%i` | `int` |\r\n| `%d` | `int64` |\r\n| `%f` | `float`/`double` |\r\n| `%O` | `Guid` |\r\n\r\nFor a numerical ID, we want to pass an int which is `%i` in the list above, so you can replace the lines above with\r\n\r\n```fsharp\r\ngetf \"/%i\" getApplication\r\n```\r\n\r\nNotice that `getf` is used instead of get. This is a separate version of get that handles `f`ormat characters.\r\n\r\n    You can use format strings with \"forward\" too by using \"forwardf\"\r\n\r\n## API Reference\r\n\r\nFull API reference for `router` CE can be found [here](../reference/Saturn/saturn-router-routerbuilder.html)\r\n\r\n*)\r\n"},{"uri":"https://saturnframework.org/reference/Saturn.Extensions.Turbolinks/index.html","title":"Saturn.Extensions.Turbolinks - API Reference","content":"Saturn.Extensions.Turbolinks \n global"},{"uri":"https://saturnframework.org/reference/Saturn.Extensions.Turbolinks/global-saturn.html","title":"Saturn","content":"Saturn \n  \n TurbolinksHelpers  \n TurbolinksMiddleware  \n turbolinks <p>HttpHandler enabling Turbolinks support for given pipelines</p>\r\n\r\n \n UseTurbolinks <p>Enable turbolinks supports for whole application (all endpoints)</p>\r\n\r\n"},{"uri":"https://saturnframework.org/reference/Saturn.Extensions.Turbolinks/saturn-turbolinkshelpers.html","title":"TurbolinksHelpers","content":"TurbolinksHelpers \n  \n  \n  \n isXhr  isTurbolink  js  redirect  \n "},{"uri":"https://saturnframework.org/reference/Saturn.Extensions.Turbolinks/saturn-turbolinksmiddleware.html","title":"TurbolinksMiddleware","content":"TurbolinksMiddleware \n  \n ( .ctor )  Invoke "}]